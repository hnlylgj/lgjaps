/* soapC.cpp

*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

//#include "soapH.h"
#include "CloudStackSoap12Wrapper.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.34 2017-01-01 12:05:12 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_ns2__MinutesOrSeconds:
		return soap_in_ns2__MinutesOrSeconds(soap, NULL, NULL, "ns2:MinutesOrSeconds");
	case SOAP_TYPE_ns2__HoursOfDay:
		return soap_in_ns2__HoursOfDay(soap, NULL, NULL, "ns2:HoursOfDay");
	case SOAP_TYPE_ns2__DayOfMonth:
		return soap_in_ns2__DayOfMonth(soap, NULL, NULL, "ns2:DayOfMonth");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns2__TransferType:
		return soap_in_ns2__TransferType(soap, NULL, NULL, "ns2:TransferType");
	case SOAP_TYPE_ns2__UpdateType:
		return soap_in_ns2__UpdateType(soap, NULL, NULL, "ns2:UpdateType");
	case SOAP_TYPE_ns2__RebootType:
		return soap_in_ns2__RebootType(soap, NULL, NULL, "ns2:RebootType");
	case SOAP_TYPE_ns2__DayOfWeek:
		return soap_in_ns2__DayOfWeek(soap, NULL, NULL, "ns2:DayOfWeek");
	case SOAP_TYPE_ns2__DateType:
		return soap_in_ns2__DateType(soap, NULL, NULL, "ns2:DateType");
	case SOAP_TYPE_ns2__DigitalInputEventType:
		return soap_in_ns2__DigitalInputEventType(soap, NULL, NULL, "ns2:DigitalInputEventType");
	case SOAP_TYPE_ns2__ClearZoneEventType:
		return soap_in_ns2__ClearZoneEventType(soap, NULL, NULL, "ns2:ClearZoneEventType");
	case SOAP_TYPE_ns2__FillEventType:
		return soap_in_ns2__FillEventType(soap, NULL, NULL, "ns2:FillEventType");
	case SOAP_TYPE_ns2__CountEventType:
		return soap_in_ns2__CountEventType(soap, NULL, NULL, "ns2:CountEventType");
	case SOAP_TYPE_ns2__DigitalOutputActivity:
		return soap_in_ns2__DigitalOutputActivity(soap, NULL, NULL, "ns2:DigitalOutputActivity");
	case SOAP_TYPE_ns2__DigitalInputValue:
		return soap_in_ns2__DigitalInputValue(soap, NULL, NULL, "ns2:DigitalInputValue");
	case SOAP_TYPE_ns2__SOAP_USCOREDeviceError:
		return soap_in_ns2__SOAP_USCOREDeviceError(soap, NULL, NULL, "ns2:SOAP_DeviceError");
	case SOAP_TYPE_ns2__SOAP_USCOREServerError:
		return soap_in_ns2__SOAP_USCOREServerError(soap, NULL, NULL, "ns2:SOAP_ServerError");
	case SOAP_TYPE_ns2__OSD_USCOREState:
		return soap_in_ns2__OSD_USCOREState(soap, NULL, NULL, "ns2:OSD_State");
	case SOAP_TYPE_ns2__TaskType:
		return soap_in_ns2__TaskType(soap, NULL, NULL, "ns2:TaskType");
	case SOAP_TYPE_ns2__ShortDuration:
		return soap_in_ns2__ShortDuration(soap, NULL, NULL, "ns2:ShortDuration");
	case SOAP_TYPE_ns2__ObjectClassName:
		return soap_in_ns2__ObjectClassName(soap, NULL, NULL, "ns2:ObjectClassName");
	case SOAP_TYPE_ns2__MeasuringChannelName:
		return soap_in_ns2__MeasuringChannelName(soap, NULL, NULL, "ns2:MeasuringChannelName");
	case SOAP_TYPE_ns2__MAC_USCOREAddress:
		return soap_in_ns2__MAC_USCOREAddress(soap, NULL, NULL, "ns2:MAC_Address");
	case SOAP_TYPE_ns2__IP_USCOREAddress:
		return soap_in_ns2__IP_USCOREAddress(soap, NULL, NULL, "ns2:IP_Address");
	case SOAP_TYPE_ns2__ErrorContainer:
		return soap_in_ns2__ErrorContainer(soap, NULL, NULL, "ns2:ErrorContainer");
	case SOAP_TYPE_ns2__AnswerContainer:
		return soap_in_ns2__AnswerContainer(soap, NULL, NULL, "ns2:AnswerContainer");
	case SOAP_TYPE_ns2__TaskContainer:
		return soap_in_ns2__TaskContainer(soap, NULL, NULL, "ns2:TaskContainer");
	case SOAP_TYPE_ns2__TaskDeleteAllNotifications:
		return soap_in_ns2__TaskDeleteAllNotifications(soap, NULL, NULL, "ns2:TaskDeleteAllNotifications");
	case SOAP_TYPE_ns2__TaskDeleteAllTasks:
		return soap_in_ns2__TaskDeleteAllTasks(soap, NULL, NULL, "ns2:TaskDeleteAllTasks");
	case SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo:
		return soap_in_ns2__TaskSubscribeFeaturesInfo(soap, NULL, NULL, "ns2:TaskSubscribeFeaturesInfo");
	case SOAP_TYPE_ns2__TaskSubscribeObjectList:
		return soap_in_ns2__TaskSubscribeObjectList(soap, NULL, NULL, "ns2:TaskSubscribeObjectList");
	case SOAP_TYPE_ns2__TaskSubscribeAlive:
		return soap_in_ns2__TaskSubscribeAlive(soap, NULL, NULL, "ns2:TaskSubscribeAlive");
	case SOAP_TYPE_ns2__TaskSubscribeVideoStore:
		return soap_in_ns2__TaskSubscribeVideoStore(soap, NULL, NULL, "ns2:TaskSubscribeVideoStore");
	case SOAP_TYPE_ns2__TaskSubscribeSendParameters:
		return soap_in_ns2__TaskSubscribeSendParameters(soap, NULL, NULL, "ns2:TaskSubscribeSendParameters");
	case SOAP_TYPE_ns2__TaskSubscribeCameraImages:
		return soap_in_ns2__TaskSubscribeCameraImages(soap, NULL, NULL, "ns2:TaskSubscribeCameraImages");
	case SOAP_TYPE_ns2__TaskSubscribeErrorLog:
		return soap_in_ns2__TaskSubscribeErrorLog(soap, NULL, NULL, "ns2:TaskSubscribeErrorLog");
	case SOAP_TYPE_ns2__TaskSubscribeLogfiles:
		return soap_in_ns2__TaskSubscribeLogfiles(soap, NULL, NULL, "ns2:TaskSubscribeLogfiles");
	case SOAP_TYPE_ns2__TaskSubscribeDigitalInput:
		return soap_in_ns2__TaskSubscribeDigitalInput(soap, NULL, NULL, "ns2:TaskSubscribeDigitalInput");
	case SOAP_TYPE_ns2__DigitalInputControl:
		return soap_in_ns2__DigitalInputControl(soap, NULL, NULL, "ns2:DigitalInputControl");
	case SOAP_TYPE_ns2__TaskSubscribeClearZone:
		return soap_in_ns2__TaskSubscribeClearZone(soap, NULL, NULL, "ns2:TaskSubscribeClearZone");
	case SOAP_TYPE_ns2__TaskSubscribeFill:
		return soap_in_ns2__TaskSubscribeFill(soap, NULL, NULL, "ns2:TaskSubscribeFill");
	case SOAP_TYPE_ns2__TaskSubscribeZoneChannels:
		return soap_in_ns2__TaskSubscribeZoneChannels(soap, NULL, NULL, "ns2:TaskSubscribeZoneChannels");
	case SOAP_TYPE_ns2__TaskSubscribeCountChannels:
		return soap_in_ns2__TaskSubscribeCountChannels(soap, NULL, NULL, "ns2:TaskSubscribeCountChannels");
	case SOAP_TYPE_ns2__TaskSubscribeCounting:
		return soap_in_ns2__TaskSubscribeCounting(soap, NULL, NULL, "ns2:TaskSubscribeCounting");
	case SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe:
		return soap_in_ns2__TaskSubscribeTriggeredSafe(soap, NULL, NULL, "ns2:TaskSubscribeTriggeredSafe");
	case SOAP_TYPE_ns2__TaskSubscribeTriggered:
		return soap_in_ns2__TaskSubscribeTriggered(soap, NULL, NULL, "ns2:TaskSubscribeTriggered");
	case SOAP_TYPE_ns2__TaskSetDateTime:
		return soap_in_ns2__TaskSetDateTime(soap, NULL, NULL, "ns2:TaskSetDateTime");
	case SOAP_TYPE_ns2__TaskSetDigitalOutput:
		return soap_in_ns2__TaskSetDigitalOutput(soap, NULL, NULL, "ns2:TaskSetDigitalOutput");
	case SOAP_TYPE_ns2__TaskWithActivity:
		return soap_in_ns2__TaskWithActivity(soap, NULL, NULL, "ns2:TaskWithActivity");
	case SOAP_TYPE_ns2__TaskRequestParameters:
		return soap_in_ns2__TaskRequestParameters(soap, NULL, NULL, "ns2:TaskRequestParameters");
	case SOAP_TYPE_ns2__TaskRequestUpdate:
		return soap_in_ns2__TaskRequestUpdate(soap, NULL, NULL, "ns2:TaskRequestUpdate");
	case SOAP_TYPE_ns2__TaskRebootNow:
		return soap_in_ns2__TaskRebootNow(soap, NULL, NULL, "ns2:TaskRebootNow");
	case SOAP_TYPE_ns2__Task:
		return soap_in_ns2__Task(soap, NULL, NULL, "ns2:Task");
	case SOAP_TYPE_ns2__NotificationContainer:
		return soap_in_ns2__NotificationContainer(soap, NULL, NULL, "ns2:NotificationContainer");
	case SOAP_TYPE_ns2__HistoricObjectListNotification:
		return soap_in_ns2__HistoricObjectListNotification(soap, NULL, NULL, "ns2:HistoricObjectListNotification");
	case SOAP_TYPE_ns2__HistoricObjectListNotificationBase:
		return soap_in_ns2__HistoricObjectListNotificationBase(soap, NULL, NULL, "ns2:HistoricObjectListNotificationBase");
	case SOAP_TYPE_ns2__CurrentObjectListNotification:
		return soap_in_ns2__CurrentObjectListNotification(soap, NULL, NULL, "ns2:CurrentObjectListNotification");
	case SOAP_TYPE_ns2__HistoricObject:
		return soap_in_ns2__HistoricObject(soap, NULL, NULL, "ns2:HistoricObject");
	case SOAP_TYPE_ns2__CurrentObject:
		return soap_in_ns2__CurrentObject(soap, NULL, NULL, "ns2:CurrentObject");
	case SOAP_TYPE_ns2__Object:
		return soap_in_ns2__Object(soap, NULL, NULL, "ns2:Object");
	case SOAP_TYPE_ns2__Coordinate_USCORE3D:
		return soap_in_ns2__Coordinate_USCORE3D(soap, NULL, NULL, "ns2:Coordinate_3D");
	case SOAP_TYPE_ns2__Coordinate_USCORE2D:
		return soap_in_ns2__Coordinate_USCORE2D(soap, NULL, NULL, "ns2:Coordinate_2D");
	case SOAP_TYPE_ns2__FeatureInfoNotification:
		return soap_in_ns2__FeatureInfoNotification(soap, NULL, NULL, "ns2:FeatureInfoNotification");
	case SOAP_TYPE_ns2__ZoneChannelsFeatureInfo:
		return soap_in_ns2__ZoneChannelsFeatureInfo(soap, NULL, NULL, "ns2:ZoneChannelsFeatureInfo");
	case SOAP_TYPE_ns2__ZoneChannelFeatureInfo:
		return soap_in_ns2__ZoneChannelFeatureInfo(soap, NULL, NULL, "ns2:ZoneChannelFeatureInfo");
	case SOAP_TYPE_ns2__CountChannelsFeatureInfo:
		return soap_in_ns2__CountChannelsFeatureInfo(soap, NULL, NULL, "ns2:CountChannelsFeatureInfo");
	case SOAP_TYPE_ns2__CountChannelFeatureInfo:
		return soap_in_ns2__CountChannelFeatureInfo(soap, NULL, NULL, "ns2:CountChannelFeatureInfo");
	case SOAP_TYPE_ns2__StartupNotification:
		return soap_in_ns2__StartupNotification(soap, NULL, NULL, "ns2:StartupNotification");
	case SOAP_TYPE_ns2__AliveNotification:
		return soap_in_ns2__AliveNotification(soap, NULL, NULL, "ns2:AliveNotification");
	case SOAP_TYPE_ns2__ErrorLogfilesNotification:
		return soap_in_ns2__ErrorLogfilesNotification(soap, NULL, NULL, "ns2:ErrorLogfilesNotification");
	case SOAP_TYPE_ns2__ParameterNotification:
		return soap_in_ns2__ParameterNotification(soap, NULL, NULL, "ns2:ParameterNotification");
	case SOAP_TYPE_ns2__LogfilesNotification:
		return soap_in_ns2__LogfilesNotification(soap, NULL, NULL, "ns2:LogfilesNotification");
	case SOAP_TYPE_ns2__CameraImagesNotification:
		return soap_in_ns2__CameraImagesNotification(soap, NULL, NULL, "ns2:CameraImagesNotification");
	case SOAP_TYPE_ns2__ClearZoneNotification:
		return soap_in_ns2__ClearZoneNotification(soap, NULL, NULL, "ns2:ClearZoneNotification");
	case SOAP_TYPE_ns2__DigitalInputNotification:
		return soap_in_ns2__DigitalInputNotification(soap, NULL, NULL, "ns2:DigitalInputNotification");
	case SOAP_TYPE_ns2__FillNotification:
		return soap_in_ns2__FillNotification(soap, NULL, NULL, "ns2:FillNotification");
	case SOAP_TYPE_ns2__ZoneChannelsNotification:
		return soap_in_ns2__ZoneChannelsNotification(soap, NULL, NULL, "ns2:ZoneChannelsNotification");
	case SOAP_TYPE_ns2__ZoneData:
		return soap_in_ns2__ZoneData(soap, NULL, NULL, "ns2:ZoneData");
	case SOAP_TYPE_ns2__CountChannelsNotification:
		return soap_in_ns2__CountChannelsNotification(soap, NULL, NULL, "ns2:CountChannelsNotification");
	case SOAP_TYPE_ns2__CountChannelData:
		return soap_in_ns2__CountChannelData(soap, NULL, NULL, "ns2:CountChannelData");
	case SOAP_TYPE_ns2__CountNotification:
		return soap_in_ns2__CountNotification(soap, NULL, NULL, "ns2:CountNotification");
	case SOAP_TYPE_ns2__ExtendedNotificationBase:
		return soap_in_ns2__ExtendedNotificationBase(soap, NULL, NULL, "ns2:ExtendedNotificationBase");
	case SOAP_TYPE_ns2__NotificationWithOSDState:
		return soap_in_ns2__NotificationWithOSDState(soap, NULL, NULL, "ns2:NotificationWithOSDState");
	case SOAP_TYPE_ns2__NotificationBase:
		return soap_in_ns2__NotificationBase(soap, NULL, NULL, "ns2:NotificationBase");
	case SOAP_TYPE_ns2__BinaryData:
		return soap_in_ns2__BinaryData(soap, NULL, NULL, "ns2:BinaryData");
	case SOAP_TYPE_ns2__ClearZoneID:
		return soap_in_ns2__ClearZoneID(soap, NULL, NULL, "ns2:ClearZoneID");
	case SOAP_TYPE_ns2__FillRegionID:
		return soap_in_ns2__FillRegionID(soap, NULL, NULL, "ns2:FillRegionID");
	case SOAP_TYPE_ns2__CountingGateID:
		return soap_in_ns2__CountingGateID(soap, NULL, NULL, "ns2:CountingGateID");
	case SOAP_TYPE_ns2__Trigger:
		return soap_in_ns2__Trigger(soap, NULL, NULL, "ns2:Trigger");
	case SOAP_TYPE_ns2__TimeTrigger:
		return soap_in_ns2__TimeTrigger(soap, NULL, NULL, "ns2:TimeTrigger");
	case SOAP_TYPE_ns2__ClockTime:
		return soap_in_ns2__ClockTime(soap, NULL, NULL, "ns2:ClockTime");
	case SOAP_TYPE_ns2__Date:
		return soap_in_ns2__Date(soap, NULL, NULL, "ns2:Date");
	case SOAP_TYPE_ns2__EventTrigger:
		return soap_in_ns2__EventTrigger(soap, NULL, NULL, "ns2:EventTrigger");
	case SOAP_TYPE_ns2__FeatureChangedEvent:
		return soap_in_ns2__FeatureChangedEvent(soap, NULL, NULL, "ns2:FeatureChangedEvent");
	case SOAP_TYPE_ns2__OSD_USCOREEvent:
		return soap_in_ns2__OSD_USCOREEvent(soap, NULL, NULL, "ns2:OSD_Event");
	case SOAP_TYPE_ns2__CurrentObjectListEvent:
		return soap_in_ns2__CurrentObjectListEvent(soap, NULL, NULL, "ns2:CurrentObjectListEvent");
	case SOAP_TYPE_ns2__OneTimeEvent:
		return soap_in_ns2__OneTimeEvent(soap, NULL, NULL, "ns2:OneTimeEvent");
	case SOAP_TYPE_ns2__DigitalInputEvent:
		return soap_in_ns2__DigitalInputEvent(soap, NULL, NULL, "ns2:DigitalInputEvent");
	case SOAP_TYPE_ns2__ClearZoneEvent:
		return soap_in_ns2__ClearZoneEvent(soap, NULL, NULL, "ns2:ClearZoneEvent");
	case SOAP_TYPE_ns2__FillEvent:
		return soap_in_ns2__FillEvent(soap, NULL, NULL, "ns2:FillEvent");
	case SOAP_TYPE_ns2__ZoneChannelsEvent:
		return soap_in_ns2__ZoneChannelsEvent(soap, NULL, NULL, "ns2:ZoneChannelsEvent");
	case SOAP_TYPE_ns2__CountChannelsEvent:
		return soap_in_ns2__CountChannelsEvent(soap, NULL, NULL, "ns2:CountChannelsEvent");
	case SOAP_TYPE_ns2__CountEvent:
		return soap_in_ns2__CountEvent(soap, NULL, NULL, "ns2:CountEvent");
	case SOAP_TYPE_ns2__DigitalOutputElement:
		return soap_in_ns2__DigitalOutputElement(soap, NULL, NULL, "ns2:DigitalOutputElement");
	case SOAP_TYPE_ns2__DigitalInputElement:
		return soap_in_ns2__DigitalInputElement(soap, NULL, NULL, "ns2:DigitalInputElement");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons2__ErrorContainer:
		return soap_in_PointerTons2__ErrorContainer(soap, NULL, NULL, "ns2:ErrorContainer");
	case SOAP_TYPE_PointerTons2__NotificationContainer:
		return soap_in_PointerTons2__NotificationContainer(soap, NULL, NULL, "ns2:NotificationContainer");
	case SOAP_TYPE_PointerToPointerTons2__DigitalInputControl:
		return soap_in_PointerToPointerTons2__DigitalInputControl(soap, NULL, NULL, "ns2:DigitalInputControl");
	case SOAP_TYPE_PointerTons2__DigitalInputControl:
		return soap_in_PointerTons2__DigitalInputControl(soap, NULL, NULL, "ns2:DigitalInputControl");
	case SOAP_TYPE_wstring:
	{	wchar_t **s;
		s = soap_in_wstring(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTons2__ZoneChannelsFeatureInfo:
		return soap_in_PointerTons2__ZoneChannelsFeatureInfo(soap, NULL, NULL, "ns2:ZoneChannelsFeatureInfo");
	case SOAP_TYPE_PointerTons2__CountChannelsFeatureInfo:
		return soap_in_PointerTons2__CountChannelsFeatureInfo(soap, NULL, NULL, "ns2:CountChannelsFeatureInfo");
	case SOAP_TYPE_PointerTons2__Trigger:
		return soap_in_PointerTons2__Trigger(soap, NULL, NULL, "ns2:Trigger");
	case SOAP_TYPE_PointerToPointerTons2__DigitalOutputElement:
		return soap_in_PointerToPointerTons2__DigitalOutputElement(soap, NULL, NULL, "ns2:DigitalOutputElement");
	case SOAP_TYPE_PointerTons2__DigitalOutputElement:
		return soap_in_PointerTons2__DigitalOutputElement(soap, NULL, NULL, "ns2:DigitalOutputElement");
	case SOAP_TYPE_PointerToPointerTons2__CurrentObject:
		return soap_in_PointerToPointerTons2__CurrentObject(soap, NULL, NULL, "ns2:CurrentObject");
	case SOAP_TYPE_PointerTons2__CurrentObject:
		return soap_in_PointerTons2__CurrentObject(soap, NULL, NULL, "ns2:CurrentObject");
	case SOAP_TYPE_PointerTons2__ClearZoneID:
		return soap_in_PointerTons2__ClearZoneID(soap, NULL, NULL, "ns2:ClearZoneID");
	case SOAP_TYPE_PointerTons2__FillRegionID:
		return soap_in_PointerTons2__FillRegionID(soap, NULL, NULL, "ns2:FillRegionID");
	case SOAP_TYPE_PointerToPointerTons2__ZoneData:
		return soap_in_PointerToPointerTons2__ZoneData(soap, NULL, NULL, "ns2:ZoneData");
	case SOAP_TYPE_PointerTons2__ZoneData:
		return soap_in_PointerTons2__ZoneData(soap, NULL, NULL, "ns2:ZoneData");
	case SOAP_TYPE_PointerToPointerTons2__CountChannelData:
		return soap_in_PointerToPointerTons2__CountChannelData(soap, NULL, NULL, "ns2:CountChannelData");
	case SOAP_TYPE_PointerTons2__CountChannelData:
		return soap_in_PointerTons2__CountChannelData(soap, NULL, NULL, "ns2:CountChannelData");
	case SOAP_TYPE_PointerTons2__CountingGateID:
		return soap_in_PointerTons2__CountingGateID(soap, NULL, NULL, "ns2:CountingGateID");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToPointerTons2__HistoricObject:
		return soap_in_PointerToPointerTons2__HistoricObject(soap, NULL, NULL, "ns2:HistoricObject");
	case SOAP_TYPE_PointerTons2__HistoricObject:
		return soap_in_PointerTons2__HistoricObject(soap, NULL, NULL, "ns2:HistoricObject");
	case SOAP_TYPE_PointerTons2__Coordinate_USCORE2D:
		return soap_in_PointerTons2__Coordinate_USCORE2D(soap, NULL, NULL, "ns2:Coordinate_2D");
	case SOAP_TYPE_PointerTons2__BinaryData:
		return soap_in_PointerTons2__BinaryData(soap, NULL, NULL, "ns2:BinaryData");
	case SOAP_TYPE_PointerToPointerTons2__DigitalInputElement:
		return soap_in_PointerToPointerTons2__DigitalInputElement(soap, NULL, NULL, "ns2:DigitalInputElement");
	case SOAP_TYPE_PointerTons2__DigitalInputElement:
		return soap_in_PointerTons2__DigitalInputElement(soap, NULL, NULL, "ns2:DigitalInputElement");
	case SOAP_TYPE_PointerTons2__TaskDeleteAllNotifications:
		return soap_in_PointerTons2__TaskDeleteAllNotifications(soap, NULL, NULL, "ns2:TaskDeleteAllNotifications");
	case SOAP_TYPE_PointerTons2__TaskDeleteAllTasks:
		return soap_in_PointerTons2__TaskDeleteAllTasks(soap, NULL, NULL, "ns2:TaskDeleteAllTasks");
	case SOAP_TYPE_PointerTons2__TaskSubscribeFeaturesInfo:
		return soap_in_PointerTons2__TaskSubscribeFeaturesInfo(soap, NULL, NULL, "ns2:TaskSubscribeFeaturesInfo");
	case SOAP_TYPE_PointerTons2__TaskSubscribeZoneChannels:
		return soap_in_PointerTons2__TaskSubscribeZoneChannels(soap, NULL, NULL, "ns2:TaskSubscribeZoneChannels");
	case SOAP_TYPE_PointerTons2__TaskSubscribeCountChannels:
		return soap_in_PointerTons2__TaskSubscribeCountChannels(soap, NULL, NULL, "ns2:TaskSubscribeCountChannels");
	case SOAP_TYPE_PointerTons2__TaskSubscribeClearZone:
		return soap_in_PointerTons2__TaskSubscribeClearZone(soap, NULL, NULL, "ns2:TaskSubscribeClearZone");
	case SOAP_TYPE_PointerTons2__TaskRebootNow:
		return soap_in_PointerTons2__TaskRebootNow(soap, NULL, NULL, "ns2:TaskRebootNow");
	case SOAP_TYPE_PointerTons2__TaskSubscribeObjectList:
		return soap_in_PointerTons2__TaskSubscribeObjectList(soap, NULL, NULL, "ns2:TaskSubscribeObjectList");
	case SOAP_TYPE_PointerTons2__TaskSubscribeAlive:
		return soap_in_PointerTons2__TaskSubscribeAlive(soap, NULL, NULL, "ns2:TaskSubscribeAlive");
	case SOAP_TYPE_PointerTons2__TaskSubscribeVideoStore:
		return soap_in_PointerTons2__TaskSubscribeVideoStore(soap, NULL, NULL, "ns2:TaskSubscribeVideoStore");
	case SOAP_TYPE_PointerTons2__TaskSubscribeSendParameters:
		return soap_in_PointerTons2__TaskSubscribeSendParameters(soap, NULL, NULL, "ns2:TaskSubscribeSendParameters");
	case SOAP_TYPE_PointerTons2__TaskSubscribeCameraImages:
		return soap_in_PointerTons2__TaskSubscribeCameraImages(soap, NULL, NULL, "ns2:TaskSubscribeCameraImages");
	case SOAP_TYPE_PointerTons2__TaskSubscribeDigitalInput:
		return soap_in_PointerTons2__TaskSubscribeDigitalInput(soap, NULL, NULL, "ns2:TaskSubscribeDigitalInput");
	case SOAP_TYPE_PointerTons2__TaskSubscribeFill:
		return soap_in_PointerTons2__TaskSubscribeFill(soap, NULL, NULL, "ns2:TaskSubscribeFill");
	case SOAP_TYPE_PointerTons2__TaskSubscribeCounting:
		return soap_in_PointerTons2__TaskSubscribeCounting(soap, NULL, NULL, "ns2:TaskSubscribeCounting");
	case SOAP_TYPE_PointerTons2__TaskSetDateTime:
		return soap_in_PointerTons2__TaskSetDateTime(soap, NULL, NULL, "ns2:TaskSetDateTime");
	case SOAP_TYPE_PointerTons2__TaskSetDigitalOutput:
		return soap_in_PointerTons2__TaskSetDigitalOutput(soap, NULL, NULL, "ns2:TaskSetDigitalOutput");
	case SOAP_TYPE_PointerTons2__TaskSubscribeErrorLog:
		return soap_in_PointerTons2__TaskSubscribeErrorLog(soap, NULL, NULL, "ns2:TaskSubscribeErrorLog");
	case SOAP_TYPE_PointerTons2__TaskSubscribeLogfiles:
		return soap_in_PointerTons2__TaskSubscribeLogfiles(soap, NULL, NULL, "ns2:TaskSubscribeLogfiles");
	case SOAP_TYPE_PointerTons2__TaskRequestParameters:
		return soap_in_PointerTons2__TaskRequestParameters(soap, NULL, NULL, "ns2:TaskRequestParameters");
	case SOAP_TYPE_PointerTons2__TaskRequestUpdate:
		return soap_in_PointerTons2__TaskRequestUpdate(soap, NULL, NULL, "ns2:TaskRequestUpdate");
	case SOAP_TYPE_PointerTons2__FeatureInfoNotification:
		return soap_in_PointerTons2__FeatureInfoNotification(soap, NULL, NULL, "ns2:FeatureInfoNotification");
	case SOAP_TYPE_PointerTons2__ZoneChannelsNotification:
		return soap_in_PointerTons2__ZoneChannelsNotification(soap, NULL, NULL, "ns2:ZoneChannelsNotification");
	case SOAP_TYPE_PointerTons2__CountChannelsNotification:
		return soap_in_PointerTons2__CountChannelsNotification(soap, NULL, NULL, "ns2:CountChannelsNotification");
	case SOAP_TYPE_PointerTons2__ClearZoneNotification:
		return soap_in_PointerTons2__ClearZoneNotification(soap, NULL, NULL, "ns2:ClearZoneNotification");
	case SOAP_TYPE_PointerTons2__StartupNotification:
		return soap_in_PointerTons2__StartupNotification(soap, NULL, NULL, "ns2:StartupNotification");
	case SOAP_TYPE_PointerTons2__HistoricObjectListNotification:
		return soap_in_PointerTons2__HistoricObjectListNotification(soap, NULL, NULL, "ns2:HistoricObjectListNotification");
	case SOAP_TYPE_PointerTons2__CurrentObjectListNotification:
		return soap_in_PointerTons2__CurrentObjectListNotification(soap, NULL, NULL, "ns2:CurrentObjectListNotification");
	case SOAP_TYPE_PointerTons2__AliveNotification:
		return soap_in_PointerTons2__AliveNotification(soap, NULL, NULL, "ns2:AliveNotification");
	case SOAP_TYPE_PointerTons2__ErrorLogfilesNotification:
		return soap_in_PointerTons2__ErrorLogfilesNotification(soap, NULL, NULL, "ns2:ErrorLogfilesNotification");
	case SOAP_TYPE_PointerTons2__LogfilesNotification:
		return soap_in_PointerTons2__LogfilesNotification(soap, NULL, NULL, "ns2:LogfilesNotification");
	case SOAP_TYPE_PointerTons2__ParameterNotification:
		return soap_in_PointerTons2__ParameterNotification(soap, NULL, NULL, "ns2:ParameterNotification");
	case SOAP_TYPE_PointerTons2__CameraImagesNotification:
		return soap_in_PointerTons2__CameraImagesNotification(soap, NULL, NULL, "ns2:CameraImagesNotification");
	case SOAP_TYPE_PointerTons2__DigitalInputNotification:
		return soap_in_PointerTons2__DigitalInputNotification(soap, NULL, NULL, "ns2:DigitalInputNotification");
	case SOAP_TYPE_PointerTons2__FillNotification:
		return soap_in_PointerTons2__FillNotification(soap, NULL, NULL, "ns2:FillNotification");
	case SOAP_TYPE_PointerTons2__CountNotification:
		return soap_in_PointerTons2__CountNotification(soap, NULL, NULL, "ns2:CountNotification");
	case SOAP_TYPE_PointerTons2__Coordinate_USCORE3D:
		return soap_in_PointerTons2__Coordinate_USCORE3D(soap, NULL, NULL, "ns2:Coordinate_3D");
	case SOAP_TYPE_PointerToPointerTons2__ZoneChannelFeatureInfo:
		return soap_in_PointerToPointerTons2__ZoneChannelFeatureInfo(soap, NULL, NULL, "ns2:ZoneChannelFeatureInfo");
	case SOAP_TYPE_PointerTons2__ZoneChannelFeatureInfo:
		return soap_in_PointerTons2__ZoneChannelFeatureInfo(soap, NULL, NULL, "ns2:ZoneChannelFeatureInfo");
	case SOAP_TYPE_PointerToPointerTons2__CountChannelFeatureInfo:
		return soap_in_PointerToPointerTons2__CountChannelFeatureInfo(soap, NULL, NULL, "ns2:CountChannelFeatureInfo");
	case SOAP_TYPE_PointerTons2__CountChannelFeatureInfo:
		return soap_in_PointerTons2__CountChannelFeatureInfo(soap, NULL, NULL, "ns2:CountChannelFeatureInfo");
	case SOAP_TYPE_PointerTons2__ObjectClassName:
		return soap_in_PointerTons2__ObjectClassName(soap, NULL, NULL, "ns2:ObjectClassName");
	case SOAP_TYPE_PointerTons2__MeasuringChannelName:
		return soap_in_PointerTons2__MeasuringChannelName(soap, NULL, NULL, "ns2:MeasuringChannelName");
	case SOAP_TYPE_PointerTons2__TimeTrigger:
		return soap_in_PointerTons2__TimeTrigger(soap, NULL, NULL, "ns2:TimeTrigger");
	case SOAP_TYPE_PointerTons2__EventTrigger:
		return soap_in_PointerTons2__EventTrigger(soap, NULL, NULL, "ns2:EventTrigger");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTons2__ClockTime:
		return soap_in_PointerTons2__ClockTime(soap, NULL, NULL, "ns2:ClockTime");
	case SOAP_TYPE_PointerTons2__Date:
		return soap_in_PointerTons2__Date(soap, NULL, NULL, "ns2:Date");
	case SOAP_TYPE_PointerTons2__DayOfMonth:
		return soap_in_PointerTons2__DayOfMonth(soap, NULL, NULL, "ns2:DayOfMonth");
	case SOAP_TYPE_PointerTons2__DayOfWeek:
		return soap_in_PointerTons2__DayOfWeek(soap, NULL, NULL, "ns2:DayOfWeek");
	case SOAP_TYPE_PointerTons2__FeatureChangedEvent:
		return soap_in_PointerTons2__FeatureChangedEvent(soap, NULL, NULL, "ns2:FeatureChangedEvent");
	case SOAP_TYPE_PointerTons2__ZoneChannelsEvent:
		return soap_in_PointerTons2__ZoneChannelsEvent(soap, NULL, NULL, "ns2:ZoneChannelsEvent");
	case SOAP_TYPE_PointerTons2__CountChannelsEvent:
		return soap_in_PointerTons2__CountChannelsEvent(soap, NULL, NULL, "ns2:CountChannelsEvent");
	case SOAP_TYPE_PointerTons2__ClearZoneEvent:
		return soap_in_PointerTons2__ClearZoneEvent(soap, NULL, NULL, "ns2:ClearZoneEvent");
	case SOAP_TYPE_PointerTons2__CurrentObjectListEvent:
		return soap_in_PointerTons2__CurrentObjectListEvent(soap, NULL, NULL, "ns2:CurrentObjectListEvent");
	case SOAP_TYPE_PointerTons2__OSD_USCOREEvent:
		return soap_in_PointerTons2__OSD_USCOREEvent(soap, NULL, NULL, "ns2:OSD_Event");
	case SOAP_TYPE_PointerTons2__OneTimeEvent:
		return soap_in_PointerTons2__OneTimeEvent(soap, NULL, NULL, "ns2:OneTimeEvent");
	case SOAP_TYPE_PointerTons2__DigitalInputEvent:
		return soap_in_PointerTons2__DigitalInputEvent(soap, NULL, NULL, "ns2:DigitalInputEvent");
	case SOAP_TYPE_PointerTons2__FillEvent:
		return soap_in_PointerTons2__FillEvent(soap, NULL, NULL, "ns2:FillEvent");
	case SOAP_TYPE_PointerTons2__CountEvent:
		return soap_in_PointerTons2__CountEvent(soap, NULL, NULL, "ns2:CountEvent");
	case SOAP_TYPE_PointerTons2__DigitalInputEventType:
		return soap_in_PointerTons2__DigitalInputEventType(soap, NULL, NULL, "ns2:DigitalInputEventType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_in_PointerTounsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:ShortDuration"))
		{	*type = SOAP_TYPE_ns2__ShortDuration;
			return soap_in_ns2__ShortDuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ObjectClassName"))
		{	*type = SOAP_TYPE_ns2__ObjectClassName;
			return soap_in_ns2__ObjectClassName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MeasuringChannelName"))
		{	*type = SOAP_TYPE_ns2__MeasuringChannelName;
			return soap_in_ns2__MeasuringChannelName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MAC_Address"))
		{	*type = SOAP_TYPE_ns2__MAC_USCOREAddress;
			return soap_in_ns2__MAC_USCOREAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IP_Address"))
		{	*type = SOAP_TYPE_ns2__IP_USCOREAddress;
			return soap_in_ns2__IP_USCOREAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ErrorContainer"))
		{	*type = SOAP_TYPE_ns2__ErrorContainer;
			return soap_in_ns2__ErrorContainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AnswerContainer"))
		{	*type = SOAP_TYPE_ns2__AnswerContainer;
			return soap_in_ns2__AnswerContainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskContainer"))
		{	*type = SOAP_TYPE_ns2__TaskContainer;
			return soap_in_ns2__TaskContainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskDeleteAllNotifications"))
		{	*type = SOAP_TYPE_ns2__TaskDeleteAllNotifications;
			return soap_in_ns2__TaskDeleteAllNotifications(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskDeleteAllTasks"))
		{	*type = SOAP_TYPE_ns2__TaskDeleteAllTasks;
			return soap_in_ns2__TaskDeleteAllTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeFeaturesInfo"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo;
			return soap_in_ns2__TaskSubscribeFeaturesInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeObjectList"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeObjectList;
			return soap_in_ns2__TaskSubscribeObjectList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeAlive"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeAlive;
			return soap_in_ns2__TaskSubscribeAlive(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeVideoStore"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeVideoStore;
			return soap_in_ns2__TaskSubscribeVideoStore(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeSendParameters"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeSendParameters;
			return soap_in_ns2__TaskSubscribeSendParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeCameraImages"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeCameraImages;
			return soap_in_ns2__TaskSubscribeCameraImages(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeErrorLog"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeErrorLog;
			return soap_in_ns2__TaskSubscribeErrorLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeLogfiles"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeLogfiles;
			return soap_in_ns2__TaskSubscribeLogfiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeDigitalInput"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeDigitalInput;
			return soap_in_ns2__TaskSubscribeDigitalInput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DigitalInputControl"))
		{	*type = SOAP_TYPE_ns2__DigitalInputControl;
			return soap_in_ns2__DigitalInputControl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeClearZone"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeClearZone;
			return soap_in_ns2__TaskSubscribeClearZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeFill"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeFill;
			return soap_in_ns2__TaskSubscribeFill(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeZoneChannels"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeZoneChannels;
			return soap_in_ns2__TaskSubscribeZoneChannels(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeCountChannels"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeCountChannels;
			return soap_in_ns2__TaskSubscribeCountChannels(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeCounting"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeCounting;
			return soap_in_ns2__TaskSubscribeCounting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeTriggeredSafe"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe;
			return soap_in_ns2__TaskSubscribeTriggeredSafe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSubscribeTriggered"))
		{	*type = SOAP_TYPE_ns2__TaskSubscribeTriggered;
			return soap_in_ns2__TaskSubscribeTriggered(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSetDateTime"))
		{	*type = SOAP_TYPE_ns2__TaskSetDateTime;
			return soap_in_ns2__TaskSetDateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskSetDigitalOutput"))
		{	*type = SOAP_TYPE_ns2__TaskSetDigitalOutput;
			return soap_in_ns2__TaskSetDigitalOutput(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskWithActivity"))
		{	*type = SOAP_TYPE_ns2__TaskWithActivity;
			return soap_in_ns2__TaskWithActivity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskRequestParameters"))
		{	*type = SOAP_TYPE_ns2__TaskRequestParameters;
			return soap_in_ns2__TaskRequestParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskRequestUpdate"))
		{	*type = SOAP_TYPE_ns2__TaskRequestUpdate;
			return soap_in_ns2__TaskRequestUpdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskRebootNow"))
		{	*type = SOAP_TYPE_ns2__TaskRebootNow;
			return soap_in_ns2__TaskRebootNow(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Task"))
		{	*type = SOAP_TYPE_ns2__Task;
			return soap_in_ns2__Task(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NotificationContainer"))
		{	*type = SOAP_TYPE_ns2__NotificationContainer;
			return soap_in_ns2__NotificationContainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HistoricObjectListNotification"))
		{	*type = SOAP_TYPE_ns2__HistoricObjectListNotification;
			return soap_in_ns2__HistoricObjectListNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HistoricObjectListNotificationBase"))
		{	*type = SOAP_TYPE_ns2__HistoricObjectListNotificationBase;
			return soap_in_ns2__HistoricObjectListNotificationBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CurrentObjectListNotification"))
		{	*type = SOAP_TYPE_ns2__CurrentObjectListNotification;
			return soap_in_ns2__CurrentObjectListNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HistoricObject"))
		{	*type = SOAP_TYPE_ns2__HistoricObject;
			return soap_in_ns2__HistoricObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CurrentObject"))
		{	*type = SOAP_TYPE_ns2__CurrentObject;
			return soap_in_ns2__CurrentObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Object"))
		{	*type = SOAP_TYPE_ns2__Object;
			return soap_in_ns2__Object(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Coordinate_3D"))
		{	*type = SOAP_TYPE_ns2__Coordinate_USCORE3D;
			return soap_in_ns2__Coordinate_USCORE3D(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Coordinate_2D"))
		{	*type = SOAP_TYPE_ns2__Coordinate_USCORE2D;
			return soap_in_ns2__Coordinate_USCORE2D(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FeatureInfoNotification"))
		{	*type = SOAP_TYPE_ns2__FeatureInfoNotification;
			return soap_in_ns2__FeatureInfoNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ZoneChannelsFeatureInfo"))
		{	*type = SOAP_TYPE_ns2__ZoneChannelsFeatureInfo;
			return soap_in_ns2__ZoneChannelsFeatureInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ZoneChannelFeatureInfo"))
		{	*type = SOAP_TYPE_ns2__ZoneChannelFeatureInfo;
			return soap_in_ns2__ZoneChannelFeatureInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CountChannelsFeatureInfo"))
		{	*type = SOAP_TYPE_ns2__CountChannelsFeatureInfo;
			return soap_in_ns2__CountChannelsFeatureInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CountChannelFeatureInfo"))
		{	*type = SOAP_TYPE_ns2__CountChannelFeatureInfo;
			return soap_in_ns2__CountChannelFeatureInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:StartupNotification"))
		{	*type = SOAP_TYPE_ns2__StartupNotification;
			return soap_in_ns2__StartupNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AliveNotification"))
		{	*type = SOAP_TYPE_ns2__AliveNotification;
			return soap_in_ns2__AliveNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ErrorLogfilesNotification"))
		{	*type = SOAP_TYPE_ns2__ErrorLogfilesNotification;
			return soap_in_ns2__ErrorLogfilesNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParameterNotification"))
		{	*type = SOAP_TYPE_ns2__ParameterNotification;
			return soap_in_ns2__ParameterNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LogfilesNotification"))
		{	*type = SOAP_TYPE_ns2__LogfilesNotification;
			return soap_in_ns2__LogfilesNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CameraImagesNotification"))
		{	*type = SOAP_TYPE_ns2__CameraImagesNotification;
			return soap_in_ns2__CameraImagesNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClearZoneNotification"))
		{	*type = SOAP_TYPE_ns2__ClearZoneNotification;
			return soap_in_ns2__ClearZoneNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DigitalInputNotification"))
		{	*type = SOAP_TYPE_ns2__DigitalInputNotification;
			return soap_in_ns2__DigitalInputNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FillNotification"))
		{	*type = SOAP_TYPE_ns2__FillNotification;
			return soap_in_ns2__FillNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ZoneChannelsNotification"))
		{	*type = SOAP_TYPE_ns2__ZoneChannelsNotification;
			return soap_in_ns2__ZoneChannelsNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ZoneData"))
		{	*type = SOAP_TYPE_ns2__ZoneData;
			return soap_in_ns2__ZoneData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CountChannelsNotification"))
		{	*type = SOAP_TYPE_ns2__CountChannelsNotification;
			return soap_in_ns2__CountChannelsNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CountChannelData"))
		{	*type = SOAP_TYPE_ns2__CountChannelData;
			return soap_in_ns2__CountChannelData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CountNotification"))
		{	*type = SOAP_TYPE_ns2__CountNotification;
			return soap_in_ns2__CountNotification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ExtendedNotificationBase"))
		{	*type = SOAP_TYPE_ns2__ExtendedNotificationBase;
			return soap_in_ns2__ExtendedNotificationBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NotificationWithOSDState"))
		{	*type = SOAP_TYPE_ns2__NotificationWithOSDState;
			return soap_in_ns2__NotificationWithOSDState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NotificationBase"))
		{	*type = SOAP_TYPE_ns2__NotificationBase;
			return soap_in_ns2__NotificationBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BinaryData"))
		{	*type = SOAP_TYPE_ns2__BinaryData;
			return soap_in_ns2__BinaryData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClearZoneID"))
		{	*type = SOAP_TYPE_ns2__ClearZoneID;
			return soap_in_ns2__ClearZoneID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FillRegionID"))
		{	*type = SOAP_TYPE_ns2__FillRegionID;
			return soap_in_ns2__FillRegionID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CountingGateID"))
		{	*type = SOAP_TYPE_ns2__CountingGateID;
			return soap_in_ns2__CountingGateID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Trigger"))
		{	*type = SOAP_TYPE_ns2__Trigger;
			return soap_in_ns2__Trigger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TimeTrigger"))
		{	*type = SOAP_TYPE_ns2__TimeTrigger;
			return soap_in_ns2__TimeTrigger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClockTime"))
		{	*type = SOAP_TYPE_ns2__ClockTime;
			return soap_in_ns2__ClockTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Date"))
		{	*type = SOAP_TYPE_ns2__Date;
			return soap_in_ns2__Date(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EventTrigger"))
		{	*type = SOAP_TYPE_ns2__EventTrigger;
			return soap_in_ns2__EventTrigger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FeatureChangedEvent"))
		{	*type = SOAP_TYPE_ns2__FeatureChangedEvent;
			return soap_in_ns2__FeatureChangedEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OSD_Event"))
		{	*type = SOAP_TYPE_ns2__OSD_USCOREEvent;
			return soap_in_ns2__OSD_USCOREEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CurrentObjectListEvent"))
		{	*type = SOAP_TYPE_ns2__CurrentObjectListEvent;
			return soap_in_ns2__CurrentObjectListEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OneTimeEvent"))
		{	*type = SOAP_TYPE_ns2__OneTimeEvent;
			return soap_in_ns2__OneTimeEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DigitalInputEvent"))
		{	*type = SOAP_TYPE_ns2__DigitalInputEvent;
			return soap_in_ns2__DigitalInputEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClearZoneEvent"))
		{	*type = SOAP_TYPE_ns2__ClearZoneEvent;
			return soap_in_ns2__ClearZoneEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FillEvent"))
		{	*type = SOAP_TYPE_ns2__FillEvent;
			return soap_in_ns2__FillEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ZoneChannelsEvent"))
		{	*type = SOAP_TYPE_ns2__ZoneChannelsEvent;
			return soap_in_ns2__ZoneChannelsEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CountChannelsEvent"))
		{	*type = SOAP_TYPE_ns2__CountChannelsEvent;
			return soap_in_ns2__CountChannelsEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CountEvent"))
		{	*type = SOAP_TYPE_ns2__CountEvent;
			return soap_in_ns2__CountEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DigitalOutputElement"))
		{	*type = SOAP_TYPE_ns2__DigitalOutputElement;
			return soap_in_ns2__DigitalOutputElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DigitalInputElement"))
		{	*type = SOAP_TYPE_ns2__DigitalInputElement;
			return soap_in_ns2__DigitalInputElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MinutesOrSeconds"))
		{	*type = SOAP_TYPE_ns2__MinutesOrSeconds;
			return soap_in_ns2__MinutesOrSeconds(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HoursOfDay"))
		{	*type = SOAP_TYPE_ns2__HoursOfDay;
			return soap_in_ns2__HoursOfDay(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DayOfMonth"))
		{	*type = SOAP_TYPE_ns2__DayOfMonth;
			return soap_in_ns2__DayOfMonth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TransferType"))
		{	*type = SOAP_TYPE_ns2__TransferType;
			return soap_in_ns2__TransferType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UpdateType"))
		{	*type = SOAP_TYPE_ns2__UpdateType;
			return soap_in_ns2__UpdateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RebootType"))
		{	*type = SOAP_TYPE_ns2__RebootType;
			return soap_in_ns2__RebootType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DayOfWeek"))
		{	*type = SOAP_TYPE_ns2__DayOfWeek;
			return soap_in_ns2__DayOfWeek(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DateType"))
		{	*type = SOAP_TYPE_ns2__DateType;
			return soap_in_ns2__DateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DigitalInputEventType"))
		{	*type = SOAP_TYPE_ns2__DigitalInputEventType;
			return soap_in_ns2__DigitalInputEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClearZoneEventType"))
		{	*type = SOAP_TYPE_ns2__ClearZoneEventType;
			return soap_in_ns2__ClearZoneEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FillEventType"))
		{	*type = SOAP_TYPE_ns2__FillEventType;
			return soap_in_ns2__FillEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CountEventType"))
		{	*type = SOAP_TYPE_ns2__CountEventType;
			return soap_in_ns2__CountEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DigitalOutputActivity"))
		{	*type = SOAP_TYPE_ns2__DigitalOutputActivity;
			return soap_in_ns2__DigitalOutputActivity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DigitalInputValue"))
		{	*type = SOAP_TYPE_ns2__DigitalInputValue;
			return soap_in_ns2__DigitalInputValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SOAP_DeviceError"))
		{	*type = SOAP_TYPE_ns2__SOAP_USCOREDeviceError;
			return soap_in_ns2__SOAP_USCOREDeviceError(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SOAP_ServerError"))
		{	*type = SOAP_TYPE_ns2__SOAP_USCOREServerError;
			return soap_in_ns2__SOAP_USCOREServerError(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OSD_State"))
		{	*type = SOAP_TYPE_ns2__OSD_USCOREState;
			return soap_in_ns2__OSD_USCOREState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaskType"))
		{	*type = SOAP_TYPE_ns2__TaskType;
			return soap_in_ns2__TaskType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	wchar_t **s;
			*type = SOAP_TYPE_wstring;
			s = soap_in_wstring(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const LONG64 *)ptr, "xsd:duration");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_ns2__MinutesOrSeconds:
		return soap_out_ns2__MinutesOrSeconds(soap, tag, id, (const unsigned int *)ptr, "ns2:MinutesOrSeconds");
	case SOAP_TYPE_ns2__HoursOfDay:
		return soap_out_ns2__HoursOfDay(soap, tag, id, (const unsigned int *)ptr, "ns2:HoursOfDay");
	case SOAP_TYPE_ns2__DayOfMonth:
		return soap_out_ns2__DayOfMonth(soap, tag, id, (const unsigned int *)ptr, "ns2:DayOfMonth");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns2__TransferType:
		return soap_out_ns2__TransferType(soap, tag, id, (const enum ns2__TransferType *)ptr, "ns2:TransferType");
	case SOAP_TYPE_ns2__UpdateType:
		return soap_out_ns2__UpdateType(soap, tag, id, (const enum ns2__UpdateType *)ptr, "ns2:UpdateType");
	case SOAP_TYPE_ns2__RebootType:
		return soap_out_ns2__RebootType(soap, tag, id, (const enum ns2__RebootType *)ptr, "ns2:RebootType");
	case SOAP_TYPE_ns2__DayOfWeek:
		return soap_out_ns2__DayOfWeek(soap, tag, id, (const enum ns2__DayOfWeek *)ptr, "ns2:DayOfWeek");
	case SOAP_TYPE_ns2__DateType:
		return soap_out_ns2__DateType(soap, tag, id, (const enum ns2__DateType *)ptr, "ns2:DateType");
	case SOAP_TYPE_ns2__DigitalInputEventType:
		return soap_out_ns2__DigitalInputEventType(soap, tag, id, (const enum ns2__DigitalInputEventType *)ptr, "ns2:DigitalInputEventType");
	case SOAP_TYPE_ns2__ClearZoneEventType:
		return soap_out_ns2__ClearZoneEventType(soap, tag, id, (const enum ns2__ClearZoneEventType *)ptr, "ns2:ClearZoneEventType");
	case SOAP_TYPE_ns2__FillEventType:
		return soap_out_ns2__FillEventType(soap, tag, id, (const enum ns2__FillEventType *)ptr, "ns2:FillEventType");
	case SOAP_TYPE_ns2__CountEventType:
		return soap_out_ns2__CountEventType(soap, tag, id, (const enum ns2__CountEventType *)ptr, "ns2:CountEventType");
	case SOAP_TYPE_ns2__DigitalOutputActivity:
		return soap_out_ns2__DigitalOutputActivity(soap, tag, id, (const enum ns2__DigitalOutputActivity *)ptr, "ns2:DigitalOutputActivity");
	case SOAP_TYPE_ns2__DigitalInputValue:
		return soap_out_ns2__DigitalInputValue(soap, tag, id, (const enum ns2__DigitalInputValue *)ptr, "ns2:DigitalInputValue");
	case SOAP_TYPE_ns2__SOAP_USCOREDeviceError:
		return soap_out_ns2__SOAP_USCOREDeviceError(soap, tag, id, (const enum ns2__SOAP_USCOREDeviceError *)ptr, "ns2:SOAP_DeviceError");
	case SOAP_TYPE_ns2__SOAP_USCOREServerError:
		return soap_out_ns2__SOAP_USCOREServerError(soap, tag, id, (const enum ns2__SOAP_USCOREServerError *)ptr, "ns2:SOAP_ServerError");
	case SOAP_TYPE_ns2__OSD_USCOREState:
		return soap_out_ns2__OSD_USCOREState(soap, tag, id, (const enum ns2__OSD_USCOREState *)ptr, "ns2:OSD_State");
	case SOAP_TYPE_ns2__TaskType:
		return soap_out_ns2__TaskType(soap, tag, id, (const enum ns2__TaskType *)ptr, "ns2:TaskType");
	case SOAP_TYPE_ns2__ShortDuration:
		return soap_out_ns2__ShortDuration(soap, tag, id, (const std::wstring *)ptr, "ns2:ShortDuration");
	case SOAP_TYPE_ns2__ObjectClassName:
		return soap_out_ns2__ObjectClassName(soap, tag, id, (const std::wstring *)ptr, "ns2:ObjectClassName");
	case SOAP_TYPE_ns2__MeasuringChannelName:
		return soap_out_ns2__MeasuringChannelName(soap, tag, id, (const std::wstring *)ptr, "ns2:MeasuringChannelName");
	case SOAP_TYPE_ns2__MAC_USCOREAddress:
		return soap_out_ns2__MAC_USCOREAddress(soap, tag, id, (const std::wstring *)ptr, "ns2:MAC_Address");
	case SOAP_TYPE_ns2__IP_USCOREAddress:
		return soap_out_ns2__IP_USCOREAddress(soap, tag, id, (const std::wstring *)ptr, "ns2:IP_Address");
	case SOAP_TYPE_ns2__ErrorContainer:
		return ((ns2__ErrorContainer *)ptr)->soap_out(soap, tag, id, "ns2:ErrorContainer");
	case SOAP_TYPE_ns2__AnswerContainer:
		return ((ns2__AnswerContainer *)ptr)->soap_out(soap, tag, id, "ns2:AnswerContainer");
	case SOAP_TYPE_ns2__TaskContainer:
		return ((ns2__TaskContainer *)ptr)->soap_out(soap, tag, id, "ns2:TaskContainer");
	case SOAP_TYPE_ns2__TaskDeleteAllNotifications:
		return ((ns2__TaskDeleteAllNotifications *)ptr)->soap_out(soap, tag, id, "ns2:TaskDeleteAllNotifications");
	case SOAP_TYPE_ns2__TaskDeleteAllTasks:
		return ((ns2__TaskDeleteAllTasks *)ptr)->soap_out(soap, tag, id, "ns2:TaskDeleteAllTasks");
	case SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo:
		return ((ns2__TaskSubscribeFeaturesInfo *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeFeaturesInfo");
	case SOAP_TYPE_ns2__TaskSubscribeObjectList:
		return ((ns2__TaskSubscribeObjectList *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeObjectList");
	case SOAP_TYPE_ns2__TaskSubscribeAlive:
		return ((ns2__TaskSubscribeAlive *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeAlive");
	case SOAP_TYPE_ns2__TaskSubscribeVideoStore:
		return ((ns2__TaskSubscribeVideoStore *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeVideoStore");
	case SOAP_TYPE_ns2__TaskSubscribeSendParameters:
		return ((ns2__TaskSubscribeSendParameters *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeSendParameters");
	case SOAP_TYPE_ns2__TaskSubscribeCameraImages:
		return ((ns2__TaskSubscribeCameraImages *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeCameraImages");
	case SOAP_TYPE_ns2__TaskSubscribeErrorLog:
		return ((ns2__TaskSubscribeErrorLog *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeErrorLog");
	case SOAP_TYPE_ns2__TaskSubscribeLogfiles:
		return ((ns2__TaskSubscribeLogfiles *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeLogfiles");
	case SOAP_TYPE_ns2__TaskSubscribeDigitalInput:
		return ((ns2__TaskSubscribeDigitalInput *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeDigitalInput");
	case SOAP_TYPE_ns2__DigitalInputControl:
		return ((ns2__DigitalInputControl *)ptr)->soap_out(soap, tag, id, "ns2:DigitalInputControl");
	case SOAP_TYPE_ns2__TaskSubscribeClearZone:
		return ((ns2__TaskSubscribeClearZone *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeClearZone");
	case SOAP_TYPE_ns2__TaskSubscribeFill:
		return ((ns2__TaskSubscribeFill *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeFill");
	case SOAP_TYPE_ns2__TaskSubscribeZoneChannels:
		return ((ns2__TaskSubscribeZoneChannels *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeZoneChannels");
	case SOAP_TYPE_ns2__TaskSubscribeCountChannels:
		return ((ns2__TaskSubscribeCountChannels *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeCountChannels");
	case SOAP_TYPE_ns2__TaskSubscribeCounting:
		return ((ns2__TaskSubscribeCounting *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeCounting");
	case SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe:
		return ((ns2__TaskSubscribeTriggeredSafe *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeTriggeredSafe");
	case SOAP_TYPE_ns2__TaskSubscribeTriggered:
		return ((ns2__TaskSubscribeTriggered *)ptr)->soap_out(soap, tag, id, "ns2:TaskSubscribeTriggered");
	case SOAP_TYPE_ns2__TaskSetDateTime:
		return ((ns2__TaskSetDateTime *)ptr)->soap_out(soap, tag, id, "ns2:TaskSetDateTime");
	case SOAP_TYPE_ns2__TaskSetDigitalOutput:
		return ((ns2__TaskSetDigitalOutput *)ptr)->soap_out(soap, tag, id, "ns2:TaskSetDigitalOutput");
	case SOAP_TYPE_ns2__TaskWithActivity:
		return ((ns2__TaskWithActivity *)ptr)->soap_out(soap, tag, id, "ns2:TaskWithActivity");
	case SOAP_TYPE_ns2__TaskRequestParameters:
		return ((ns2__TaskRequestParameters *)ptr)->soap_out(soap, tag, id, "ns2:TaskRequestParameters");
	case SOAP_TYPE_ns2__TaskRequestUpdate:
		return ((ns2__TaskRequestUpdate *)ptr)->soap_out(soap, tag, id, "ns2:TaskRequestUpdate");
	case SOAP_TYPE_ns2__TaskRebootNow:
		return ((ns2__TaskRebootNow *)ptr)->soap_out(soap, tag, id, "ns2:TaskRebootNow");
	case SOAP_TYPE_ns2__Task:
		return ((ns2__Task *)ptr)->soap_out(soap, tag, id, "ns2:Task");
	case SOAP_TYPE_ns2__NotificationContainer:
		return ((ns2__NotificationContainer *)ptr)->soap_out(soap, tag, id, "ns2:NotificationContainer");
	case SOAP_TYPE_ns2__HistoricObjectListNotification:
		return ((ns2__HistoricObjectListNotification *)ptr)->soap_out(soap, tag, id, "ns2:HistoricObjectListNotification");
	case SOAP_TYPE_ns2__HistoricObjectListNotificationBase:
		return ((ns2__HistoricObjectListNotificationBase *)ptr)->soap_out(soap, tag, id, "ns2:HistoricObjectListNotificationBase");
	case SOAP_TYPE_ns2__CurrentObjectListNotification:
		return ((ns2__CurrentObjectListNotification *)ptr)->soap_out(soap, tag, id, "ns2:CurrentObjectListNotification");
	case SOAP_TYPE_ns2__HistoricObject:
		return ((ns2__HistoricObject *)ptr)->soap_out(soap, tag, id, "ns2:HistoricObject");
	case SOAP_TYPE_ns2__CurrentObject:
		return ((ns2__CurrentObject *)ptr)->soap_out(soap, tag, id, "ns2:CurrentObject");
	case SOAP_TYPE_ns2__Object:
		return ((ns2__Object *)ptr)->soap_out(soap, tag, id, "ns2:Object");
	case SOAP_TYPE_ns2__Coordinate_USCORE3D:
		return ((ns2__Coordinate_USCORE3D *)ptr)->soap_out(soap, tag, id, "ns2:Coordinate_3D");
	case SOAP_TYPE_ns2__Coordinate_USCORE2D:
		return ((ns2__Coordinate_USCORE2D *)ptr)->soap_out(soap, tag, id, "ns2:Coordinate_2D");
	case SOAP_TYPE_ns2__FeatureInfoNotification:
		return ((ns2__FeatureInfoNotification *)ptr)->soap_out(soap, tag, id, "ns2:FeatureInfoNotification");
	case SOAP_TYPE_ns2__ZoneChannelsFeatureInfo:
		return ((ns2__ZoneChannelsFeatureInfo *)ptr)->soap_out(soap, tag, id, "ns2:ZoneChannelsFeatureInfo");
	case SOAP_TYPE_ns2__ZoneChannelFeatureInfo:
		return ((ns2__ZoneChannelFeatureInfo *)ptr)->soap_out(soap, tag, id, "ns2:ZoneChannelFeatureInfo");
	case SOAP_TYPE_ns2__CountChannelsFeatureInfo:
		return ((ns2__CountChannelsFeatureInfo *)ptr)->soap_out(soap, tag, id, "ns2:CountChannelsFeatureInfo");
	case SOAP_TYPE_ns2__CountChannelFeatureInfo:
		return ((ns2__CountChannelFeatureInfo *)ptr)->soap_out(soap, tag, id, "ns2:CountChannelFeatureInfo");
	case SOAP_TYPE_ns2__StartupNotification:
		return ((ns2__StartupNotification *)ptr)->soap_out(soap, tag, id, "ns2:StartupNotification");
	case SOAP_TYPE_ns2__AliveNotification:
		return ((ns2__AliveNotification *)ptr)->soap_out(soap, tag, id, "ns2:AliveNotification");
	case SOAP_TYPE_ns2__ErrorLogfilesNotification:
		return ((ns2__ErrorLogfilesNotification *)ptr)->soap_out(soap, tag, id, "ns2:ErrorLogfilesNotification");
	case SOAP_TYPE_ns2__ParameterNotification:
		return ((ns2__ParameterNotification *)ptr)->soap_out(soap, tag, id, "ns2:ParameterNotification");
	case SOAP_TYPE_ns2__LogfilesNotification:
		return ((ns2__LogfilesNotification *)ptr)->soap_out(soap, tag, id, "ns2:LogfilesNotification");
	case SOAP_TYPE_ns2__CameraImagesNotification:
		return ((ns2__CameraImagesNotification *)ptr)->soap_out(soap, tag, id, "ns2:CameraImagesNotification");
	case SOAP_TYPE_ns2__ClearZoneNotification:
		return ((ns2__ClearZoneNotification *)ptr)->soap_out(soap, tag, id, "ns2:ClearZoneNotification");
	case SOAP_TYPE_ns2__DigitalInputNotification:
		return ((ns2__DigitalInputNotification *)ptr)->soap_out(soap, tag, id, "ns2:DigitalInputNotification");
	case SOAP_TYPE_ns2__FillNotification:
		return ((ns2__FillNotification *)ptr)->soap_out(soap, tag, id, "ns2:FillNotification");
	case SOAP_TYPE_ns2__ZoneChannelsNotification:
		return ((ns2__ZoneChannelsNotification *)ptr)->soap_out(soap, tag, id, "ns2:ZoneChannelsNotification");
	case SOAP_TYPE_ns2__ZoneData:
		return ((ns2__ZoneData *)ptr)->soap_out(soap, tag, id, "ns2:ZoneData");
	case SOAP_TYPE_ns2__CountChannelsNotification:
		return ((ns2__CountChannelsNotification *)ptr)->soap_out(soap, tag, id, "ns2:CountChannelsNotification");
	case SOAP_TYPE_ns2__CountChannelData:
		return ((ns2__CountChannelData *)ptr)->soap_out(soap, tag, id, "ns2:CountChannelData");
	case SOAP_TYPE_ns2__CountNotification:
		return ((ns2__CountNotification *)ptr)->soap_out(soap, tag, id, "ns2:CountNotification");
	case SOAP_TYPE_ns2__ExtendedNotificationBase:
		return ((ns2__ExtendedNotificationBase *)ptr)->soap_out(soap, tag, id, "ns2:ExtendedNotificationBase");
	case SOAP_TYPE_ns2__NotificationWithOSDState:
		return ((ns2__NotificationWithOSDState *)ptr)->soap_out(soap, tag, id, "ns2:NotificationWithOSDState");
	case SOAP_TYPE_ns2__NotificationBase:
		return ((ns2__NotificationBase *)ptr)->soap_out(soap, tag, id, "ns2:NotificationBase");
	case SOAP_TYPE_ns2__BinaryData:
		return ((ns2__BinaryData *)ptr)->soap_out(soap, tag, id, "ns2:BinaryData");
	case SOAP_TYPE_ns2__ClearZoneID:
		return ((ns2__ClearZoneID *)ptr)->soap_out(soap, tag, id, "ns2:ClearZoneID");
	case SOAP_TYPE_ns2__FillRegionID:
		return ((ns2__FillRegionID *)ptr)->soap_out(soap, tag, id, "ns2:FillRegionID");
	case SOAP_TYPE_ns2__CountingGateID:
		return ((ns2__CountingGateID *)ptr)->soap_out(soap, tag, id, "ns2:CountingGateID");
	case SOAP_TYPE_ns2__Trigger:
		return ((ns2__Trigger *)ptr)->soap_out(soap, tag, id, "ns2:Trigger");
	case SOAP_TYPE_ns2__TimeTrigger:
		return ((ns2__TimeTrigger *)ptr)->soap_out(soap, tag, id, "ns2:TimeTrigger");
	case SOAP_TYPE_ns2__ClockTime:
		return ((ns2__ClockTime *)ptr)->soap_out(soap, tag, id, "ns2:ClockTime");
	case SOAP_TYPE_ns2__Date:
		return ((ns2__Date *)ptr)->soap_out(soap, tag, id, "ns2:Date");
	case SOAP_TYPE_ns2__EventTrigger:
		return ((ns2__EventTrigger *)ptr)->soap_out(soap, tag, id, "ns2:EventTrigger");
	case SOAP_TYPE_ns2__FeatureChangedEvent:
		return ((ns2__FeatureChangedEvent *)ptr)->soap_out(soap, tag, id, "ns2:FeatureChangedEvent");
	case SOAP_TYPE_ns2__OSD_USCOREEvent:
		return ((ns2__OSD_USCOREEvent *)ptr)->soap_out(soap, tag, id, "ns2:OSD_Event");
	case SOAP_TYPE_ns2__CurrentObjectListEvent:
		return ((ns2__CurrentObjectListEvent *)ptr)->soap_out(soap, tag, id, "ns2:CurrentObjectListEvent");
	case SOAP_TYPE_ns2__OneTimeEvent:
		return ((ns2__OneTimeEvent *)ptr)->soap_out(soap, tag, id, "ns2:OneTimeEvent");
	case SOAP_TYPE_ns2__DigitalInputEvent:
		return ((ns2__DigitalInputEvent *)ptr)->soap_out(soap, tag, id, "ns2:DigitalInputEvent");
	case SOAP_TYPE_ns2__ClearZoneEvent:
		return ((ns2__ClearZoneEvent *)ptr)->soap_out(soap, tag, id, "ns2:ClearZoneEvent");
	case SOAP_TYPE_ns2__FillEvent:
		return ((ns2__FillEvent *)ptr)->soap_out(soap, tag, id, "ns2:FillEvent");
	case SOAP_TYPE_ns2__ZoneChannelsEvent:
		return ((ns2__ZoneChannelsEvent *)ptr)->soap_out(soap, tag, id, "ns2:ZoneChannelsEvent");
	case SOAP_TYPE_ns2__CountChannelsEvent:
		return ((ns2__CountChannelsEvent *)ptr)->soap_out(soap, tag, id, "ns2:CountChannelsEvent");
	case SOAP_TYPE_ns2__CountEvent:
		return ((ns2__CountEvent *)ptr)->soap_out(soap, tag, id, "ns2:CountEvent");
	case SOAP_TYPE_ns2__DigitalOutputElement:
		return ((ns2__DigitalOutputElement *)ptr)->soap_out(soap, tag, id, "ns2:DigitalOutputElement");
	case SOAP_TYPE_ns2__DigitalInputElement:
		return ((ns2__DigitalInputElement *)ptr)->soap_out(soap, tag, id, "ns2:DigitalInputElement");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::wstring *)ptr, "xsd:decimal");
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons2__ErrorContainer:
		return soap_out_PointerTons2__ErrorContainer(soap, tag, id, (ns2__ErrorContainer *const*)ptr, "ns2:ErrorContainer");
	case SOAP_TYPE_PointerTons2__NotificationContainer:
		return soap_out_PointerTons2__NotificationContainer(soap, tag, id, (ns2__NotificationContainer *const*)ptr, "ns2:NotificationContainer");
	case SOAP_TYPE_PointerToPointerTons2__DigitalInputControl:
		return soap_out_PointerToPointerTons2__DigitalInputControl(soap, tag, id, (ns2__DigitalInputControl **const*)ptr, "ns2:DigitalInputControl");
	case SOAP_TYPE_PointerTons2__DigitalInputControl:
		return soap_out_PointerTons2__DigitalInputControl(soap, tag, id, (ns2__DigitalInputControl *const*)ptr, "ns2:DigitalInputControl");
	case SOAP_TYPE_wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)(void*)&ptr, "xsd:string");
	case SOAP_TYPE_PointerTons2__ZoneChannelsFeatureInfo:
		return soap_out_PointerTons2__ZoneChannelsFeatureInfo(soap, tag, id, (ns2__ZoneChannelsFeatureInfo *const*)ptr, "ns2:ZoneChannelsFeatureInfo");
	case SOAP_TYPE_PointerTons2__CountChannelsFeatureInfo:
		return soap_out_PointerTons2__CountChannelsFeatureInfo(soap, tag, id, (ns2__CountChannelsFeatureInfo *const*)ptr, "ns2:CountChannelsFeatureInfo");
	case SOAP_TYPE_PointerTons2__Trigger:
		return soap_out_PointerTons2__Trigger(soap, tag, id, (ns2__Trigger *const*)ptr, "ns2:Trigger");
	case SOAP_TYPE_PointerToPointerTons2__DigitalOutputElement:
		return soap_out_PointerToPointerTons2__DigitalOutputElement(soap, tag, id, (ns2__DigitalOutputElement **const*)ptr, "ns2:DigitalOutputElement");
	case SOAP_TYPE_PointerTons2__DigitalOutputElement:
		return soap_out_PointerTons2__DigitalOutputElement(soap, tag, id, (ns2__DigitalOutputElement *const*)ptr, "ns2:DigitalOutputElement");
	case SOAP_TYPE_PointerToPointerTons2__CurrentObject:
		return soap_out_PointerToPointerTons2__CurrentObject(soap, tag, id, (ns2__CurrentObject **const*)ptr, "ns2:CurrentObject");
	case SOAP_TYPE_PointerTons2__CurrentObject:
		return soap_out_PointerTons2__CurrentObject(soap, tag, id, (ns2__CurrentObject *const*)ptr, "ns2:CurrentObject");
	case SOAP_TYPE_PointerTons2__ClearZoneID:
		return soap_out_PointerTons2__ClearZoneID(soap, tag, id, (ns2__ClearZoneID *const*)ptr, "ns2:ClearZoneID");
	case SOAP_TYPE_PointerTons2__FillRegionID:
		return soap_out_PointerTons2__FillRegionID(soap, tag, id, (ns2__FillRegionID *const*)ptr, "ns2:FillRegionID");
	case SOAP_TYPE_PointerToPointerTons2__ZoneData:
		return soap_out_PointerToPointerTons2__ZoneData(soap, tag, id, (ns2__ZoneData **const*)ptr, "ns2:ZoneData");
	case SOAP_TYPE_PointerTons2__ZoneData:
		return soap_out_PointerTons2__ZoneData(soap, tag, id, (ns2__ZoneData *const*)ptr, "ns2:ZoneData");
	case SOAP_TYPE_PointerToPointerTons2__CountChannelData:
		return soap_out_PointerToPointerTons2__CountChannelData(soap, tag, id, (ns2__CountChannelData **const*)ptr, "ns2:CountChannelData");
	case SOAP_TYPE_PointerTons2__CountChannelData:
		return soap_out_PointerTons2__CountChannelData(soap, tag, id, (ns2__CountChannelData *const*)ptr, "ns2:CountChannelData");
	case SOAP_TYPE_PointerTons2__CountingGateID:
		return soap_out_PointerTons2__CountingGateID(soap, tag, id, (ns2__CountingGateID *const*)ptr, "ns2:CountingGateID");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::wstring *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToPointerTons2__HistoricObject:
		return soap_out_PointerToPointerTons2__HistoricObject(soap, tag, id, (ns2__HistoricObject **const*)ptr, "ns2:HistoricObject");
	case SOAP_TYPE_PointerTons2__HistoricObject:
		return soap_out_PointerTons2__HistoricObject(soap, tag, id, (ns2__HistoricObject *const*)ptr, "ns2:HistoricObject");
	case SOAP_TYPE_PointerTons2__Coordinate_USCORE2D:
		return soap_out_PointerTons2__Coordinate_USCORE2D(soap, tag, id, (ns2__Coordinate_USCORE2D *const*)ptr, "ns2:Coordinate_2D");
	case SOAP_TYPE_PointerTons2__BinaryData:
		return soap_out_PointerTons2__BinaryData(soap, tag, id, (ns2__BinaryData *const*)ptr, "ns2:BinaryData");
	case SOAP_TYPE_PointerToPointerTons2__DigitalInputElement:
		return soap_out_PointerToPointerTons2__DigitalInputElement(soap, tag, id, (ns2__DigitalInputElement **const*)ptr, "ns2:DigitalInputElement");
	case SOAP_TYPE_PointerTons2__DigitalInputElement:
		return soap_out_PointerTons2__DigitalInputElement(soap, tag, id, (ns2__DigitalInputElement *const*)ptr, "ns2:DigitalInputElement");
	case SOAP_TYPE_PointerTons2__TaskDeleteAllNotifications:
		return soap_out_PointerTons2__TaskDeleteAllNotifications(soap, tag, id, (ns2__TaskDeleteAllNotifications *const*)ptr, "ns2:TaskDeleteAllNotifications");
	case SOAP_TYPE_PointerTons2__TaskDeleteAllTasks:
		return soap_out_PointerTons2__TaskDeleteAllTasks(soap, tag, id, (ns2__TaskDeleteAllTasks *const*)ptr, "ns2:TaskDeleteAllTasks");
	case SOAP_TYPE_PointerTons2__TaskSubscribeFeaturesInfo:
		return soap_out_PointerTons2__TaskSubscribeFeaturesInfo(soap, tag, id, (ns2__TaskSubscribeFeaturesInfo *const*)ptr, "ns2:TaskSubscribeFeaturesInfo");
	case SOAP_TYPE_PointerTons2__TaskSubscribeZoneChannels:
		return soap_out_PointerTons2__TaskSubscribeZoneChannels(soap, tag, id, (ns2__TaskSubscribeZoneChannels *const*)ptr, "ns2:TaskSubscribeZoneChannels");
	case SOAP_TYPE_PointerTons2__TaskSubscribeCountChannels:
		return soap_out_PointerTons2__TaskSubscribeCountChannels(soap, tag, id, (ns2__TaskSubscribeCountChannels *const*)ptr, "ns2:TaskSubscribeCountChannels");
	case SOAP_TYPE_PointerTons2__TaskSubscribeClearZone:
		return soap_out_PointerTons2__TaskSubscribeClearZone(soap, tag, id, (ns2__TaskSubscribeClearZone *const*)ptr, "ns2:TaskSubscribeClearZone");
	case SOAP_TYPE_PointerTons2__TaskRebootNow:
		return soap_out_PointerTons2__TaskRebootNow(soap, tag, id, (ns2__TaskRebootNow *const*)ptr, "ns2:TaskRebootNow");
	case SOAP_TYPE_PointerTons2__TaskSubscribeObjectList:
		return soap_out_PointerTons2__TaskSubscribeObjectList(soap, tag, id, (ns2__TaskSubscribeObjectList *const*)ptr, "ns2:TaskSubscribeObjectList");
	case SOAP_TYPE_PointerTons2__TaskSubscribeAlive:
		return soap_out_PointerTons2__TaskSubscribeAlive(soap, tag, id, (ns2__TaskSubscribeAlive *const*)ptr, "ns2:TaskSubscribeAlive");
	case SOAP_TYPE_PointerTons2__TaskSubscribeVideoStore:
		return soap_out_PointerTons2__TaskSubscribeVideoStore(soap, tag, id, (ns2__TaskSubscribeVideoStore *const*)ptr, "ns2:TaskSubscribeVideoStore");
	case SOAP_TYPE_PointerTons2__TaskSubscribeSendParameters:
		return soap_out_PointerTons2__TaskSubscribeSendParameters(soap, tag, id, (ns2__TaskSubscribeSendParameters *const*)ptr, "ns2:TaskSubscribeSendParameters");
	case SOAP_TYPE_PointerTons2__TaskSubscribeCameraImages:
		return soap_out_PointerTons2__TaskSubscribeCameraImages(soap, tag, id, (ns2__TaskSubscribeCameraImages *const*)ptr, "ns2:TaskSubscribeCameraImages");
	case SOAP_TYPE_PointerTons2__TaskSubscribeDigitalInput:
		return soap_out_PointerTons2__TaskSubscribeDigitalInput(soap, tag, id, (ns2__TaskSubscribeDigitalInput *const*)ptr, "ns2:TaskSubscribeDigitalInput");
	case SOAP_TYPE_PointerTons2__TaskSubscribeFill:
		return soap_out_PointerTons2__TaskSubscribeFill(soap, tag, id, (ns2__TaskSubscribeFill *const*)ptr, "ns2:TaskSubscribeFill");
	case SOAP_TYPE_PointerTons2__TaskSubscribeCounting:
		return soap_out_PointerTons2__TaskSubscribeCounting(soap, tag, id, (ns2__TaskSubscribeCounting *const*)ptr, "ns2:TaskSubscribeCounting");
	case SOAP_TYPE_PointerTons2__TaskSetDateTime:
		return soap_out_PointerTons2__TaskSetDateTime(soap, tag, id, (ns2__TaskSetDateTime *const*)ptr, "ns2:TaskSetDateTime");
	case SOAP_TYPE_PointerTons2__TaskSetDigitalOutput:
		return soap_out_PointerTons2__TaskSetDigitalOutput(soap, tag, id, (ns2__TaskSetDigitalOutput *const*)ptr, "ns2:TaskSetDigitalOutput");
	case SOAP_TYPE_PointerTons2__TaskSubscribeErrorLog:
		return soap_out_PointerTons2__TaskSubscribeErrorLog(soap, tag, id, (ns2__TaskSubscribeErrorLog *const*)ptr, "ns2:TaskSubscribeErrorLog");
	case SOAP_TYPE_PointerTons2__TaskSubscribeLogfiles:
		return soap_out_PointerTons2__TaskSubscribeLogfiles(soap, tag, id, (ns2__TaskSubscribeLogfiles *const*)ptr, "ns2:TaskSubscribeLogfiles");
	case SOAP_TYPE_PointerTons2__TaskRequestParameters:
		return soap_out_PointerTons2__TaskRequestParameters(soap, tag, id, (ns2__TaskRequestParameters *const*)ptr, "ns2:TaskRequestParameters");
	case SOAP_TYPE_PointerTons2__TaskRequestUpdate:
		return soap_out_PointerTons2__TaskRequestUpdate(soap, tag, id, (ns2__TaskRequestUpdate *const*)ptr, "ns2:TaskRequestUpdate");
	case SOAP_TYPE_PointerTons2__FeatureInfoNotification:
		return soap_out_PointerTons2__FeatureInfoNotification(soap, tag, id, (ns2__FeatureInfoNotification *const*)ptr, "ns2:FeatureInfoNotification");
	case SOAP_TYPE_PointerTons2__ZoneChannelsNotification:
		return soap_out_PointerTons2__ZoneChannelsNotification(soap, tag, id, (ns2__ZoneChannelsNotification *const*)ptr, "ns2:ZoneChannelsNotification");
	case SOAP_TYPE_PointerTons2__CountChannelsNotification:
		return soap_out_PointerTons2__CountChannelsNotification(soap, tag, id, (ns2__CountChannelsNotification *const*)ptr, "ns2:CountChannelsNotification");
	case SOAP_TYPE_PointerTons2__ClearZoneNotification:
		return soap_out_PointerTons2__ClearZoneNotification(soap, tag, id, (ns2__ClearZoneNotification *const*)ptr, "ns2:ClearZoneNotification");
	case SOAP_TYPE_PointerTons2__StartupNotification:
		return soap_out_PointerTons2__StartupNotification(soap, tag, id, (ns2__StartupNotification *const*)ptr, "ns2:StartupNotification");
	case SOAP_TYPE_PointerTons2__HistoricObjectListNotification:
		return soap_out_PointerTons2__HistoricObjectListNotification(soap, tag, id, (ns2__HistoricObjectListNotification *const*)ptr, "ns2:HistoricObjectListNotification");
	case SOAP_TYPE_PointerTons2__CurrentObjectListNotification:
		return soap_out_PointerTons2__CurrentObjectListNotification(soap, tag, id, (ns2__CurrentObjectListNotification *const*)ptr, "ns2:CurrentObjectListNotification");
	case SOAP_TYPE_PointerTons2__AliveNotification:
		return soap_out_PointerTons2__AliveNotification(soap, tag, id, (ns2__AliveNotification *const*)ptr, "ns2:AliveNotification");
	case SOAP_TYPE_PointerTons2__ErrorLogfilesNotification:
		return soap_out_PointerTons2__ErrorLogfilesNotification(soap, tag, id, (ns2__ErrorLogfilesNotification *const*)ptr, "ns2:ErrorLogfilesNotification");
	case SOAP_TYPE_PointerTons2__LogfilesNotification:
		return soap_out_PointerTons2__LogfilesNotification(soap, tag, id, (ns2__LogfilesNotification *const*)ptr, "ns2:LogfilesNotification");
	case SOAP_TYPE_PointerTons2__ParameterNotification:
		return soap_out_PointerTons2__ParameterNotification(soap, tag, id, (ns2__ParameterNotification *const*)ptr, "ns2:ParameterNotification");
	case SOAP_TYPE_PointerTons2__CameraImagesNotification:
		return soap_out_PointerTons2__CameraImagesNotification(soap, tag, id, (ns2__CameraImagesNotification *const*)ptr, "ns2:CameraImagesNotification");
	case SOAP_TYPE_PointerTons2__DigitalInputNotification:
		return soap_out_PointerTons2__DigitalInputNotification(soap, tag, id, (ns2__DigitalInputNotification *const*)ptr, "ns2:DigitalInputNotification");
	case SOAP_TYPE_PointerTons2__FillNotification:
		return soap_out_PointerTons2__FillNotification(soap, tag, id, (ns2__FillNotification *const*)ptr, "ns2:FillNotification");
	case SOAP_TYPE_PointerTons2__CountNotification:
		return soap_out_PointerTons2__CountNotification(soap, tag, id, (ns2__CountNotification *const*)ptr, "ns2:CountNotification");
	case SOAP_TYPE_PointerTons2__Coordinate_USCORE3D:
		return soap_out_PointerTons2__Coordinate_USCORE3D(soap, tag, id, (ns2__Coordinate_USCORE3D *const*)ptr, "ns2:Coordinate_3D");
	case SOAP_TYPE_PointerToPointerTons2__ZoneChannelFeatureInfo:
		return soap_out_PointerToPointerTons2__ZoneChannelFeatureInfo(soap, tag, id, (ns2__ZoneChannelFeatureInfo **const*)ptr, "ns2:ZoneChannelFeatureInfo");
	case SOAP_TYPE_PointerTons2__ZoneChannelFeatureInfo:
		return soap_out_PointerTons2__ZoneChannelFeatureInfo(soap, tag, id, (ns2__ZoneChannelFeatureInfo *const*)ptr, "ns2:ZoneChannelFeatureInfo");
	case SOAP_TYPE_PointerToPointerTons2__CountChannelFeatureInfo:
		return soap_out_PointerToPointerTons2__CountChannelFeatureInfo(soap, tag, id, (ns2__CountChannelFeatureInfo **const*)ptr, "ns2:CountChannelFeatureInfo");
	case SOAP_TYPE_PointerTons2__CountChannelFeatureInfo:
		return soap_out_PointerTons2__CountChannelFeatureInfo(soap, tag, id, (ns2__CountChannelFeatureInfo *const*)ptr, "ns2:CountChannelFeatureInfo");
	case SOAP_TYPE_PointerTons2__ObjectClassName:
		return soap_out_PointerTons2__ObjectClassName(soap, tag, id, (std::wstring *const*)ptr, "ns2:ObjectClassName");
	case SOAP_TYPE_PointerTons2__MeasuringChannelName:
		return soap_out_PointerTons2__MeasuringChannelName(soap, tag, id, (std::wstring *const*)ptr, "ns2:MeasuringChannelName");
	case SOAP_TYPE_PointerTons2__TimeTrigger:
		return soap_out_PointerTons2__TimeTrigger(soap, tag, id, (ns2__TimeTrigger *const*)ptr, "ns2:TimeTrigger");
	case SOAP_TYPE_PointerTons2__EventTrigger:
		return soap_out_PointerTons2__EventTrigger(soap, tag, id, (ns2__EventTrigger *const*)ptr, "ns2:EventTrigger");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (LONG64 *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTons2__ClockTime:
		return soap_out_PointerTons2__ClockTime(soap, tag, id, (ns2__ClockTime *const*)ptr, "ns2:ClockTime");
	case SOAP_TYPE_PointerTons2__Date:
		return soap_out_PointerTons2__Date(soap, tag, id, (ns2__Date *const*)ptr, "ns2:Date");
	case SOAP_TYPE_PointerTons2__DayOfMonth:
		return soap_out_PointerTons2__DayOfMonth(soap, tag, id, (unsigned int *const*)ptr, "ns2:DayOfMonth");
	case SOAP_TYPE_PointerTons2__DayOfWeek:
		return soap_out_PointerTons2__DayOfWeek(soap, tag, id, (enum ns2__DayOfWeek *const*)ptr, "ns2:DayOfWeek");
	case SOAP_TYPE_PointerTons2__FeatureChangedEvent:
		return soap_out_PointerTons2__FeatureChangedEvent(soap, tag, id, (ns2__FeatureChangedEvent *const*)ptr, "ns2:FeatureChangedEvent");
	case SOAP_TYPE_PointerTons2__ZoneChannelsEvent:
		return soap_out_PointerTons2__ZoneChannelsEvent(soap, tag, id, (ns2__ZoneChannelsEvent *const*)ptr, "ns2:ZoneChannelsEvent");
	case SOAP_TYPE_PointerTons2__CountChannelsEvent:
		return soap_out_PointerTons2__CountChannelsEvent(soap, tag, id, (ns2__CountChannelsEvent *const*)ptr, "ns2:CountChannelsEvent");
	case SOAP_TYPE_PointerTons2__ClearZoneEvent:
		return soap_out_PointerTons2__ClearZoneEvent(soap, tag, id, (ns2__ClearZoneEvent *const*)ptr, "ns2:ClearZoneEvent");
	case SOAP_TYPE_PointerTons2__CurrentObjectListEvent:
		return soap_out_PointerTons2__CurrentObjectListEvent(soap, tag, id, (ns2__CurrentObjectListEvent *const*)ptr, "ns2:CurrentObjectListEvent");
	case SOAP_TYPE_PointerTons2__OSD_USCOREEvent:
		return soap_out_PointerTons2__OSD_USCOREEvent(soap, tag, id, (ns2__OSD_USCOREEvent *const*)ptr, "ns2:OSD_Event");
	case SOAP_TYPE_PointerTons2__OneTimeEvent:
		return soap_out_PointerTons2__OneTimeEvent(soap, tag, id, (ns2__OneTimeEvent *const*)ptr, "ns2:OneTimeEvent");
	case SOAP_TYPE_PointerTons2__DigitalInputEvent:
		return soap_out_PointerTons2__DigitalInputEvent(soap, tag, id, (ns2__DigitalInputEvent *const*)ptr, "ns2:DigitalInputEvent");
	case SOAP_TYPE_PointerTons2__FillEvent:
		return soap_out_PointerTons2__FillEvent(soap, tag, id, (ns2__FillEvent *const*)ptr, "ns2:FillEvent");
	case SOAP_TYPE_PointerTons2__CountEvent:
		return soap_out_PointerTons2__CountEvent(soap, tag, id, (ns2__CountEvent *const*)ptr, "ns2:CountEvent");
	case SOAP_TYPE_PointerTons2__DigitalInputEventType:
		return soap_out_PointerTons2__DigitalInputEventType(soap, tag, id, (enum ns2__DigitalInputEventType *const*)ptr, "ns2:DigitalInputEventType");
	case SOAP_TYPE_PointerTounsignedInt:
		return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns2__union_TaskContainer:
		((__ns2__union_TaskContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ShortDuration:
		soap_serialize_ns2__ShortDuration(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_ns2__ObjectClassName:
		soap_serialize_ns2__ObjectClassName(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_ns2__MeasuringChannelName:
		soap_serialize_ns2__MeasuringChannelName(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_ns2__MAC_USCOREAddress:
		soap_serialize_ns2__MAC_USCOREAddress(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_ns2__IP_USCOREAddress:
		soap_serialize_ns2__IP_USCOREAddress(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_ns2__ErrorContainer:
		((ns2__ErrorContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AnswerContainer:
		((ns2__AnswerContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskContainer:
		((ns2__TaskContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskDeleteAllNotifications:
		((ns2__TaskDeleteAllNotifications *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskDeleteAllTasks:
		((ns2__TaskDeleteAllTasks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo:
		((ns2__TaskSubscribeFeaturesInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeObjectList:
		((ns2__TaskSubscribeObjectList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeAlive:
		((ns2__TaskSubscribeAlive *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeVideoStore:
		((ns2__TaskSubscribeVideoStore *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeSendParameters:
		((ns2__TaskSubscribeSendParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeCameraImages:
		((ns2__TaskSubscribeCameraImages *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeErrorLog:
		((ns2__TaskSubscribeErrorLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeLogfiles:
		((ns2__TaskSubscribeLogfiles *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeDigitalInput:
		((ns2__TaskSubscribeDigitalInput *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DigitalInputControl:
		((ns2__DigitalInputControl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeClearZone:
		((ns2__TaskSubscribeClearZone *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeFill:
		((ns2__TaskSubscribeFill *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeZoneChannels:
		((ns2__TaskSubscribeZoneChannels *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeCountChannels:
		((ns2__TaskSubscribeCountChannels *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeCounting:
		((ns2__TaskSubscribeCounting *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe:
		((ns2__TaskSubscribeTriggeredSafe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSubscribeTriggered:
		((ns2__TaskSubscribeTriggered *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSetDateTime:
		((ns2__TaskSetDateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskSetDigitalOutput:
		((ns2__TaskSetDigitalOutput *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskWithActivity:
		((ns2__TaskWithActivity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskRequestParameters:
		((ns2__TaskRequestParameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskRequestUpdate:
		((ns2__TaskRequestUpdate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaskRebootNow:
		((ns2__TaskRebootNow *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Task:
		((ns2__Task *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NotificationContainer:
		((ns2__NotificationContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HistoricObjectListNotification:
		((ns2__HistoricObjectListNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HistoricObjectListNotificationBase:
		((ns2__HistoricObjectListNotificationBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CurrentObjectListNotification:
		((ns2__CurrentObjectListNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HistoricObject:
		((ns2__HistoricObject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CurrentObject:
		((ns2__CurrentObject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Object:
		((ns2__Object *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Coordinate_USCORE3D:
		((ns2__Coordinate_USCORE3D *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Coordinate_USCORE2D:
		((ns2__Coordinate_USCORE2D *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FeatureInfoNotification:
		((ns2__FeatureInfoNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ZoneChannelsFeatureInfo:
		((ns2__ZoneChannelsFeatureInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ZoneChannelFeatureInfo:
		((ns2__ZoneChannelFeatureInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CountChannelsFeatureInfo:
		((ns2__CountChannelsFeatureInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CountChannelFeatureInfo:
		((ns2__CountChannelFeatureInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__StartupNotification:
		((ns2__StartupNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AliveNotification:
		((ns2__AliveNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ErrorLogfilesNotification:
		((ns2__ErrorLogfilesNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParameterNotification:
		((ns2__ParameterNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LogfilesNotification:
		((ns2__LogfilesNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CameraImagesNotification:
		((ns2__CameraImagesNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ClearZoneNotification:
		((ns2__ClearZoneNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DigitalInputNotification:
		((ns2__DigitalInputNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FillNotification:
		((ns2__FillNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ZoneChannelsNotification:
		((ns2__ZoneChannelsNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ZoneData:
		((ns2__ZoneData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CountChannelsNotification:
		((ns2__CountChannelsNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CountChannelData:
		((ns2__CountChannelData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CountNotification:
		((ns2__CountNotification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ExtendedNotificationBase:
		((ns2__ExtendedNotificationBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NotificationWithOSDState:
		((ns2__NotificationWithOSDState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NotificationBase:
		((ns2__NotificationBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BinaryData:
		((ns2__BinaryData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ClearZoneID:
		((ns2__ClearZoneID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FillRegionID:
		((ns2__FillRegionID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CountingGateID:
		((ns2__CountingGateID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Trigger:
		((ns2__Trigger *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TimeTrigger:
		((ns2__TimeTrigger *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ClockTime:
		((ns2__ClockTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Date:
		((ns2__Date *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EventTrigger:
		((ns2__EventTrigger *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FeatureChangedEvent:
		((ns2__FeatureChangedEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OSD_USCOREEvent:
		((ns2__OSD_USCOREEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CurrentObjectListEvent:
		((ns2__CurrentObjectListEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OneTimeEvent:
		((ns2__OneTimeEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DigitalInputEvent:
		((ns2__DigitalInputEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ClearZoneEvent:
		((ns2__ClearZoneEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FillEvent:
		((ns2__FillEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ZoneChannelsEvent:
		((ns2__ZoneChannelsEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CountChannelsEvent:
		((ns2__CountChannelsEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CountEvent:
		((ns2__CountEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DigitalOutputElement:
		((ns2__DigitalOutputElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DigitalInputElement:
		((ns2__DigitalInputElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__Error:
		soap_serialize___ns1__Error(soap, (const struct __ns1__Error *)ptr);
		break;
	case SOAP_TYPE___ns1__Notification:
		soap_serialize___ns1__Notification(soap, (const struct __ns1__Notification *)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ErrorContainer:
		soap_serialize_PointerTons2__ErrorContainer(soap, (ns2__ErrorContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NotificationContainer:
		soap_serialize_PointerTons2__NotificationContainer(soap, (ns2__NotificationContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__DigitalInputControl:
		soap_serialize_PointerToPointerTons2__DigitalInputControl(soap, (ns2__DigitalInputControl **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DigitalInputControl:
		soap_serialize_PointerTons2__DigitalInputControl(soap, (ns2__DigitalInputControl *const*)ptr);
		break;
	case SOAP_TYPE_wstring:
		soap_serialize_wstring(soap, (wchar_t*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTons2__ZoneChannelsFeatureInfo:
		soap_serialize_PointerTons2__ZoneChannelsFeatureInfo(soap, (ns2__ZoneChannelsFeatureInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CountChannelsFeatureInfo:
		soap_serialize_PointerTons2__CountChannelsFeatureInfo(soap, (ns2__CountChannelsFeatureInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Trigger:
		soap_serialize_PointerTons2__Trigger(soap, (ns2__Trigger *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__DigitalOutputElement:
		soap_serialize_PointerToPointerTons2__DigitalOutputElement(soap, (ns2__DigitalOutputElement **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DigitalOutputElement:
		soap_serialize_PointerTons2__DigitalOutputElement(soap, (ns2__DigitalOutputElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__CurrentObject:
		soap_serialize_PointerToPointerTons2__CurrentObject(soap, (ns2__CurrentObject **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CurrentObject:
		soap_serialize_PointerTons2__CurrentObject(soap, (ns2__CurrentObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ClearZoneID:
		soap_serialize_PointerTons2__ClearZoneID(soap, (ns2__ClearZoneID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FillRegionID:
		soap_serialize_PointerTons2__FillRegionID(soap, (ns2__FillRegionID *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__ZoneData:
		soap_serialize_PointerToPointerTons2__ZoneData(soap, (ns2__ZoneData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ZoneData:
		soap_serialize_PointerTons2__ZoneData(soap, (ns2__ZoneData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__CountChannelData:
		soap_serialize_PointerToPointerTons2__CountChannelData(soap, (ns2__CountChannelData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CountChannelData:
		soap_serialize_PointerTons2__CountChannelData(soap, (ns2__CountChannelData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CountingGateID:
		soap_serialize_PointerTons2__CountingGateID(soap, (ns2__CountingGateID *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__HistoricObject:
		soap_serialize_PointerToPointerTons2__HistoricObject(soap, (ns2__HistoricObject **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HistoricObject:
		soap_serialize_PointerTons2__HistoricObject(soap, (ns2__HistoricObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Coordinate_USCORE2D:
		soap_serialize_PointerTons2__Coordinate_USCORE2D(soap, (ns2__Coordinate_USCORE2D *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BinaryData:
		soap_serialize_PointerTons2__BinaryData(soap, (ns2__BinaryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__DigitalInputElement:
		soap_serialize_PointerToPointerTons2__DigitalInputElement(soap, (ns2__DigitalInputElement **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DigitalInputElement:
		soap_serialize_PointerTons2__DigitalInputElement(soap, (ns2__DigitalInputElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_TaskContainer:
		soap_serialize_PointerTo__ns2__union_TaskContainer(soap, (__ns2__union_TaskContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskDeleteAllNotifications:
		soap_serialize_PointerTons2__TaskDeleteAllNotifications(soap, (ns2__TaskDeleteAllNotifications *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskDeleteAllTasks:
		soap_serialize_PointerTons2__TaskDeleteAllTasks(soap, (ns2__TaskDeleteAllTasks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeFeaturesInfo:
		soap_serialize_PointerTons2__TaskSubscribeFeaturesInfo(soap, (ns2__TaskSubscribeFeaturesInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeZoneChannels:
		soap_serialize_PointerTons2__TaskSubscribeZoneChannels(soap, (ns2__TaskSubscribeZoneChannels *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeCountChannels:
		soap_serialize_PointerTons2__TaskSubscribeCountChannels(soap, (ns2__TaskSubscribeCountChannels *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeClearZone:
		soap_serialize_PointerTons2__TaskSubscribeClearZone(soap, (ns2__TaskSubscribeClearZone *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskRebootNow:
		soap_serialize_PointerTons2__TaskRebootNow(soap, (ns2__TaskRebootNow *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeObjectList:
		soap_serialize_PointerTons2__TaskSubscribeObjectList(soap, (ns2__TaskSubscribeObjectList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeAlive:
		soap_serialize_PointerTons2__TaskSubscribeAlive(soap, (ns2__TaskSubscribeAlive *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeVideoStore:
		soap_serialize_PointerTons2__TaskSubscribeVideoStore(soap, (ns2__TaskSubscribeVideoStore *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeSendParameters:
		soap_serialize_PointerTons2__TaskSubscribeSendParameters(soap, (ns2__TaskSubscribeSendParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeCameraImages:
		soap_serialize_PointerTons2__TaskSubscribeCameraImages(soap, (ns2__TaskSubscribeCameraImages *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeDigitalInput:
		soap_serialize_PointerTons2__TaskSubscribeDigitalInput(soap, (ns2__TaskSubscribeDigitalInput *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeFill:
		soap_serialize_PointerTons2__TaskSubscribeFill(soap, (ns2__TaskSubscribeFill *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeCounting:
		soap_serialize_PointerTons2__TaskSubscribeCounting(soap, (ns2__TaskSubscribeCounting *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSetDateTime:
		soap_serialize_PointerTons2__TaskSetDateTime(soap, (ns2__TaskSetDateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSetDigitalOutput:
		soap_serialize_PointerTons2__TaskSetDigitalOutput(soap, (ns2__TaskSetDigitalOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeErrorLog:
		soap_serialize_PointerTons2__TaskSubscribeErrorLog(soap, (ns2__TaskSubscribeErrorLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskSubscribeLogfiles:
		soap_serialize_PointerTons2__TaskSubscribeLogfiles(soap, (ns2__TaskSubscribeLogfiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskRequestParameters:
		soap_serialize_PointerTons2__TaskRequestParameters(soap, (ns2__TaskRequestParameters *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaskRequestUpdate:
		soap_serialize_PointerTons2__TaskRequestUpdate(soap, (ns2__TaskRequestUpdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FeatureInfoNotification:
		soap_serialize_PointerTons2__FeatureInfoNotification(soap, (ns2__FeatureInfoNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ZoneChannelsNotification:
		soap_serialize_PointerTons2__ZoneChannelsNotification(soap, (ns2__ZoneChannelsNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CountChannelsNotification:
		soap_serialize_PointerTons2__CountChannelsNotification(soap, (ns2__CountChannelsNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ClearZoneNotification:
		soap_serialize_PointerTons2__ClearZoneNotification(soap, (ns2__ClearZoneNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__StartupNotification:
		soap_serialize_PointerTons2__StartupNotification(soap, (ns2__StartupNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HistoricObjectListNotification:
		soap_serialize_PointerTons2__HistoricObjectListNotification(soap, (ns2__HistoricObjectListNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CurrentObjectListNotification:
		soap_serialize_PointerTons2__CurrentObjectListNotification(soap, (ns2__CurrentObjectListNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AliveNotification:
		soap_serialize_PointerTons2__AliveNotification(soap, (ns2__AliveNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ErrorLogfilesNotification:
		soap_serialize_PointerTons2__ErrorLogfilesNotification(soap, (ns2__ErrorLogfilesNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LogfilesNotification:
		soap_serialize_PointerTons2__LogfilesNotification(soap, (ns2__LogfilesNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParameterNotification:
		soap_serialize_PointerTons2__ParameterNotification(soap, (ns2__ParameterNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CameraImagesNotification:
		soap_serialize_PointerTons2__CameraImagesNotification(soap, (ns2__CameraImagesNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DigitalInputNotification:
		soap_serialize_PointerTons2__DigitalInputNotification(soap, (ns2__DigitalInputNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FillNotification:
		soap_serialize_PointerTons2__FillNotification(soap, (ns2__FillNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CountNotification:
		soap_serialize_PointerTons2__CountNotification(soap, (ns2__CountNotification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Coordinate_USCORE3D:
		soap_serialize_PointerTons2__Coordinate_USCORE3D(soap, (ns2__Coordinate_USCORE3D *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__ZoneChannelFeatureInfo:
		soap_serialize_PointerToPointerTons2__ZoneChannelFeatureInfo(soap, (ns2__ZoneChannelFeatureInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ZoneChannelFeatureInfo:
		soap_serialize_PointerTons2__ZoneChannelFeatureInfo(soap, (ns2__ZoneChannelFeatureInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__CountChannelFeatureInfo:
		soap_serialize_PointerToPointerTons2__CountChannelFeatureInfo(soap, (ns2__CountChannelFeatureInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CountChannelFeatureInfo:
		soap_serialize_PointerTons2__CountChannelFeatureInfo(soap, (ns2__CountChannelFeatureInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ObjectClassName:
		soap_serialize_PointerTons2__ObjectClassName(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MeasuringChannelName:
		soap_serialize_PointerTons2__MeasuringChannelName(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TimeTrigger:
		soap_serialize_PointerTons2__TimeTrigger(soap, (ns2__TimeTrigger *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EventTrigger:
		soap_serialize_PointerTons2__EventTrigger(soap, (ns2__EventTrigger *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ClockTime:
		soap_serialize_PointerTons2__ClockTime(soap, (ns2__ClockTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Date:
		soap_serialize_PointerTons2__Date(soap, (ns2__Date *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DayOfMonth:
		soap_serialize_PointerTons2__DayOfMonth(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DayOfWeek:
		soap_serialize_PointerTons2__DayOfWeek(soap, (enum ns2__DayOfWeek *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FeatureChangedEvent:
		soap_serialize_PointerTons2__FeatureChangedEvent(soap, (ns2__FeatureChangedEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ZoneChannelsEvent:
		soap_serialize_PointerTons2__ZoneChannelsEvent(soap, (ns2__ZoneChannelsEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CountChannelsEvent:
		soap_serialize_PointerTons2__CountChannelsEvent(soap, (ns2__CountChannelsEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ClearZoneEvent:
		soap_serialize_PointerTons2__ClearZoneEvent(soap, (ns2__ClearZoneEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CurrentObjectListEvent:
		soap_serialize_PointerTons2__CurrentObjectListEvent(soap, (ns2__CurrentObjectListEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OSD_USCOREEvent:
		soap_serialize_PointerTons2__OSD_USCOREEvent(soap, (ns2__OSD_USCOREEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OneTimeEvent:
		soap_serialize_PointerTons2__OneTimeEvent(soap, (ns2__OneTimeEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DigitalInputEvent:
		soap_serialize_PointerTons2__DigitalInputEvent(soap, (ns2__DigitalInputEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FillEvent:
		soap_serialize_PointerTons2__FillEvent(soap, (ns2__FillEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CountEvent:
		soap_serialize_PointerTons2__CountEvent(soap, (ns2__CountEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DigitalInputEventType:
		soap_serialize_PointerTons2__DigitalInputEventType(soap, (enum ns2__DigitalInputEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedInt:
		soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DigitalInputElement:
		return (void*)soap_instantiate_ns2__DigitalInputElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DigitalOutputElement:
		return (void*)soap_instantiate_ns2__DigitalOutputElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CountEvent:
		return (void*)soap_instantiate_ns2__CountEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CountChannelsEvent:
		return (void*)soap_instantiate_ns2__CountChannelsEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ZoneChannelsEvent:
		return (void*)soap_instantiate_ns2__ZoneChannelsEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FillEvent:
		return (void*)soap_instantiate_ns2__FillEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ClearZoneEvent:
		return (void*)soap_instantiate_ns2__ClearZoneEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DigitalInputEvent:
		return (void*)soap_instantiate_ns2__DigitalInputEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OneTimeEvent:
		return (void*)soap_instantiate_ns2__OneTimeEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CurrentObjectListEvent:
		return (void*)soap_instantiate_ns2__CurrentObjectListEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OSD_USCOREEvent:
		return (void*)soap_instantiate_ns2__OSD_USCOREEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FeatureChangedEvent:
		return (void*)soap_instantiate_ns2__FeatureChangedEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EventTrigger:
		return (void*)soap_instantiate_ns2__EventTrigger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Date:
		return (void*)soap_instantiate_ns2__Date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ClockTime:
		return (void*)soap_instantiate_ns2__ClockTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TimeTrigger:
		return (void*)soap_instantiate_ns2__TimeTrigger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Trigger:
		return (void*)soap_instantiate_ns2__Trigger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CountingGateID:
		return (void*)soap_instantiate_ns2__CountingGateID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FillRegionID:
		return (void*)soap_instantiate_ns2__FillRegionID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ClearZoneID:
		return (void*)soap_instantiate_ns2__ClearZoneID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BinaryData:
		return (void*)soap_instantiate_ns2__BinaryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NotificationBase:
		return (void*)soap_instantiate_ns2__NotificationBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CountChannelData:
		return (void*)soap_instantiate_ns2__CountChannelData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ZoneData:
		return (void*)soap_instantiate_ns2__ZoneData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CountChannelFeatureInfo:
		return (void*)soap_instantiate_ns2__CountChannelFeatureInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CountChannelsFeatureInfo:
		return (void*)soap_instantiate_ns2__CountChannelsFeatureInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ZoneChannelFeatureInfo:
		return (void*)soap_instantiate_ns2__ZoneChannelFeatureInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ZoneChannelsFeatureInfo:
		return (void*)soap_instantiate_ns2__ZoneChannelsFeatureInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Coordinate_USCORE2D:
		return (void*)soap_instantiate_ns2__Coordinate_USCORE2D(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Object:
		return (void*)soap_instantiate_ns2__Object(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NotificationContainer:
		return (void*)soap_instantiate_ns2__NotificationContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Task:
		return (void*)soap_instantiate_ns2__Task(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DigitalInputControl:
		return (void*)soap_instantiate_ns2__DigitalInputControl(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__union_TaskContainer:
		return (void*)soap_instantiate___ns2__union_TaskContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskContainer:
		return (void*)soap_instantiate_ns2__TaskContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NotificationWithOSDState:
		return (void*)soap_instantiate_ns2__NotificationWithOSDState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DigitalInputNotification:
		return (void*)soap_instantiate_ns2__DigitalInputNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LogfilesNotification:
		return (void*)soap_instantiate_ns2__LogfilesNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParameterNotification:
		return (void*)soap_instantiate_ns2__ParameterNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Coordinate_USCORE3D:
		return (void*)soap_instantiate_ns2__Coordinate_USCORE3D(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CurrentObject:
		return (void*)soap_instantiate_ns2__CurrentObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HistoricObject:
		return (void*)soap_instantiate_ns2__HistoricObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HistoricObjectListNotificationBase:
		return (void*)soap_instantiate_ns2__HistoricObjectListNotificationBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskRebootNow:
		return (void*)soap_instantiate_ns2__TaskRebootNow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskRequestUpdate:
		return (void*)soap_instantiate_ns2__TaskRequestUpdate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskRequestParameters:
		return (void*)soap_instantiate_ns2__TaskRequestParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskWithActivity:
		return (void*)soap_instantiate_ns2__TaskWithActivity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSetDateTime:
		return (void*)soap_instantiate_ns2__TaskSetDateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskDeleteAllTasks:
		return (void*)soap_instantiate_ns2__TaskDeleteAllTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskDeleteAllNotifications:
		return (void*)soap_instantiate_ns2__TaskDeleteAllNotifications(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AnswerContainer:
		return (void*)soap_instantiate_ns2__AnswerContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ExtendedNotificationBase:
		return (void*)soap_instantiate_ns2__ExtendedNotificationBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CountNotification:
		return (void*)soap_instantiate_ns2__CountNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CountChannelsNotification:
		return (void*)soap_instantiate_ns2__CountChannelsNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ZoneChannelsNotification:
		return (void*)soap_instantiate_ns2__ZoneChannelsNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FillNotification:
		return (void*)soap_instantiate_ns2__FillNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ClearZoneNotification:
		return (void*)soap_instantiate_ns2__ClearZoneNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CameraImagesNotification:
		return (void*)soap_instantiate_ns2__CameraImagesNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CurrentObjectListNotification:
		return (void*)soap_instantiate_ns2__CurrentObjectListNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HistoricObjectListNotification:
		return (void*)soap_instantiate_ns2__HistoricObjectListNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSetDigitalOutput:
		return (void*)soap_instantiate_ns2__TaskSetDigitalOutput(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeTriggered:
		return (void*)soap_instantiate_ns2__TaskSubscribeTriggered(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ErrorLogfilesNotification:
		return (void*)soap_instantiate_ns2__ErrorLogfilesNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AliveNotification:
		return (void*)soap_instantiate_ns2__AliveNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__StartupNotification:
		return (void*)soap_instantiate_ns2__StartupNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FeatureInfoNotification:
		return (void*)soap_instantiate_ns2__FeatureInfoNotification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe:
		return (void*)soap_instantiate_ns2__TaskSubscribeTriggeredSafe(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeLogfiles:
		return (void*)soap_instantiate_ns2__TaskSubscribeLogfiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeErrorLog:
		return (void*)soap_instantiate_ns2__TaskSubscribeErrorLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeCameraImages:
		return (void*)soap_instantiate_ns2__TaskSubscribeCameraImages(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeSendParameters:
		return (void*)soap_instantiate_ns2__TaskSubscribeSendParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeVideoStore:
		return (void*)soap_instantiate_ns2__TaskSubscribeVideoStore(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeAlive:
		return (void*)soap_instantiate_ns2__TaskSubscribeAlive(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeObjectList:
		return (void*)soap_instantiate_ns2__TaskSubscribeObjectList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo:
		return (void*)soap_instantiate_ns2__TaskSubscribeFeaturesInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ErrorContainer:
		return (void*)soap_instantiate_ns2__ErrorContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeCounting:
		return (void*)soap_instantiate_ns2__TaskSubscribeCounting(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeCountChannels:
		return (void*)soap_instantiate_ns2__TaskSubscribeCountChannels(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeZoneChannels:
		return (void*)soap_instantiate_ns2__TaskSubscribeZoneChannels(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeFill:
		return (void*)soap_instantiate_ns2__TaskSubscribeFill(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeClearZone:
		return (void*)soap_instantiate_ns2__TaskSubscribeClearZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaskSubscribeDigitalInput:
		return (void*)soap_instantiate_ns2__TaskSubscribeDigitalInput(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Notification:
		return (void*)soap_instantiate___ns1__Notification(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Error:
		return (void*)soap_instantiate___ns1__Error(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__IP_USCOREAddress:
		return (void*)soap_instantiate_ns2__IP_USCOREAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MAC_USCOREAddress:
		return (void*)soap_instantiate_ns2__MAC_USCOREAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MeasuringChannelName:
		return (void*)soap_instantiate_ns2__MeasuringChannelName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ObjectClassName:
		return (void*)soap_instantiate_ns2__ObjectClassName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ShortDuration:
		return (void*)soap_instantiate_ns2__ShortDuration(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__base64Binary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__base64Binary*>(p->ptr));
		break;
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::wstring*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::wstring*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DigitalInputElement:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DigitalInputElement*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DigitalInputElement*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DigitalOutputElement:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DigitalOutputElement*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DigitalOutputElement*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CountEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CountEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CountEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CountChannelsEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CountChannelsEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CountChannelsEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ZoneChannelsEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ZoneChannelsEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ZoneChannelsEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FillEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FillEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FillEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ClearZoneEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ClearZoneEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ClearZoneEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DigitalInputEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DigitalInputEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DigitalInputEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__OneTimeEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__OneTimeEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__OneTimeEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CurrentObjectListEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CurrentObjectListEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CurrentObjectListEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__OSD_USCOREEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__OSD_USCOREEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__OSD_USCOREEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FeatureChangedEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FeatureChangedEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FeatureChangedEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__EventTrigger:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__EventTrigger*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__EventTrigger*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Date:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Date*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Date*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ClockTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ClockTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ClockTime*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TimeTrigger:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TimeTrigger*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TimeTrigger*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Trigger:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Trigger*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Trigger*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CountingGateID:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CountingGateID*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CountingGateID*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FillRegionID:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FillRegionID*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FillRegionID*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ClearZoneID:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ClearZoneID*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ClearZoneID*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BinaryData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BinaryData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BinaryData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__NotificationBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__NotificationBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__NotificationBase*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CountChannelData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CountChannelData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CountChannelData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ZoneData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ZoneData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ZoneData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CountChannelFeatureInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CountChannelFeatureInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CountChannelFeatureInfo*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CountChannelsFeatureInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CountChannelsFeatureInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CountChannelsFeatureInfo*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ZoneChannelFeatureInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ZoneChannelFeatureInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ZoneChannelFeatureInfo*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ZoneChannelsFeatureInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ZoneChannelsFeatureInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ZoneChannelsFeatureInfo*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Coordinate_USCORE2D:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Coordinate_USCORE2D*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Coordinate_USCORE2D*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Object:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Object*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Object*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__NotificationContainer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__NotificationContainer*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__NotificationContainer*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Task:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Task*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Task*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DigitalInputControl:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DigitalInputControl*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DigitalInputControl*>(p->ptr));
		break;
	case SOAP_TYPE___ns2__union_TaskContainer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<__ns2__union_TaskContainer*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<__ns2__union_TaskContainer*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskContainer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskContainer*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskContainer*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__NotificationWithOSDState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__NotificationWithOSDState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__NotificationWithOSDState*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DigitalInputNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DigitalInputNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DigitalInputNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__LogfilesNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__LogfilesNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__LogfilesNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ParameterNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ParameterNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ParameterNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Coordinate_USCORE3D:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Coordinate_USCORE3D*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Coordinate_USCORE3D*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CurrentObject:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CurrentObject*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CurrentObject*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__HistoricObject:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__HistoricObject*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__HistoricObject*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__HistoricObjectListNotificationBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__HistoricObjectListNotificationBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__HistoricObjectListNotificationBase*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskRebootNow:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskRebootNow*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskRebootNow*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskRequestUpdate:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskRequestUpdate*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskRequestUpdate*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskRequestParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskRequestParameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskRequestParameters*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskWithActivity:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskWithActivity*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskWithActivity*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSetDateTime:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSetDateTime*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSetDateTime*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskDeleteAllTasks:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskDeleteAllTasks*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskDeleteAllTasks*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskDeleteAllNotifications:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskDeleteAllNotifications*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskDeleteAllNotifications*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AnswerContainer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AnswerContainer*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AnswerContainer*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ExtendedNotificationBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ExtendedNotificationBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ExtendedNotificationBase*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CountNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CountNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CountNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CountChannelsNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CountChannelsNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CountChannelsNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ZoneChannelsNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ZoneChannelsNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ZoneChannelsNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FillNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FillNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FillNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ClearZoneNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ClearZoneNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ClearZoneNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CameraImagesNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CameraImagesNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CameraImagesNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CurrentObjectListNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CurrentObjectListNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CurrentObjectListNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__HistoricObjectListNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__HistoricObjectListNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__HistoricObjectListNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSetDigitalOutput:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSetDigitalOutput*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSetDigitalOutput*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeTriggered:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeTriggered*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeTriggered*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ErrorLogfilesNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ErrorLogfilesNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ErrorLogfilesNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AliveNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AliveNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AliveNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__StartupNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__StartupNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__StartupNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FeatureInfoNotification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FeatureInfoNotification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FeatureInfoNotification*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeTriggeredSafe*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeTriggeredSafe*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeLogfiles:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeLogfiles*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeLogfiles*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeErrorLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeErrorLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeErrorLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeCameraImages:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeCameraImages*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeCameraImages*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeSendParameters:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeSendParameters*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeSendParameters*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeVideoStore:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeVideoStore*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeVideoStore*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeAlive:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeAlive*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeAlive*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeObjectList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeObjectList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeObjectList*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeFeaturesInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeFeaturesInfo*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ErrorContainer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ErrorContainer*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ErrorContainer*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeCounting:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeCounting*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeCounting*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeCountChannels:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeCountChannels*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeCountChannels*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeZoneChannels:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeZoneChannels*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeZoneChannels*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeFill:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeFill*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeFill*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeClearZone:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeClearZone*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeClearZone*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaskSubscribeDigitalInput:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaskSubscribeDigitalInput*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaskSubscribeDigitalInput*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__Notification:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Notification*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Notification*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__Error:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Error*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Error*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::wstring*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::wstring*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__IP_USCOREAddress:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::wstring*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::wstring*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__MAC_USCOREAddress:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::wstring*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::wstring*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__MeasuringChannelName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::wstring*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::wstring*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ObjectClassName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::wstring*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::wstring*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ShortDuration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::wstring*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::wstring*>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		case SOAP_TYPE_ns2__NotificationWithOSDState: t = SOAP_TYPE_ns2__NotificationBase; break;
		case SOAP_TYPE_ns2__DigitalInputNotification: t = SOAP_TYPE_ns2__NotificationBase; break;
		case SOAP_TYPE_ns2__LogfilesNotification: t = SOAP_TYPE_ns2__NotificationBase; break;
		case SOAP_TYPE_ns2__ParameterNotification: t = SOAP_TYPE_ns2__NotificationBase; break;
		case SOAP_TYPE_ns2__Coordinate_USCORE3D: t = SOAP_TYPE_ns2__Coordinate_USCORE2D; break;
		case SOAP_TYPE_ns2__CurrentObject: t = SOAP_TYPE_ns2__Object; break;
		case SOAP_TYPE_ns2__HistoricObject: t = SOAP_TYPE_ns2__Object; break;
		case SOAP_TYPE_ns2__HistoricObjectListNotificationBase: t = SOAP_TYPE_ns2__NotificationBase; break;
		case SOAP_TYPE_ns2__TaskRebootNow: t = SOAP_TYPE_ns2__Task; break;
		case SOAP_TYPE_ns2__TaskRequestUpdate: t = SOAP_TYPE_ns2__Task; break;
		case SOAP_TYPE_ns2__TaskRequestParameters: t = SOAP_TYPE_ns2__Task; break;
		case SOAP_TYPE_ns2__TaskWithActivity: t = SOAP_TYPE_ns2__Task; break;
		case SOAP_TYPE_ns2__TaskSetDateTime: t = SOAP_TYPE_ns2__Task; break;
		case SOAP_TYPE_ns2__TaskDeleteAllTasks: t = SOAP_TYPE_ns2__Task; break;
		case SOAP_TYPE_ns2__TaskDeleteAllNotifications: t = SOAP_TYPE_ns2__Task; break;
		case SOAP_TYPE_ns2__AnswerContainer: t = SOAP_TYPE_ns2__TaskContainer; break;
		case SOAP_TYPE_ns2__ExtendedNotificationBase: t = SOAP_TYPE_ns2__NotificationWithOSDState; break;
		case SOAP_TYPE_ns2__CountNotification: t = SOAP_TYPE_ns2__NotificationWithOSDState; break;
		case SOAP_TYPE_ns2__CountChannelsNotification: t = SOAP_TYPE_ns2__NotificationWithOSDState; break;
		case SOAP_TYPE_ns2__ZoneChannelsNotification: t = SOAP_TYPE_ns2__NotificationWithOSDState; break;
		case SOAP_TYPE_ns2__FillNotification: t = SOAP_TYPE_ns2__NotificationWithOSDState; break;
		case SOAP_TYPE_ns2__ClearZoneNotification: t = SOAP_TYPE_ns2__NotificationWithOSDState; break;
		case SOAP_TYPE_ns2__CameraImagesNotification: t = SOAP_TYPE_ns2__NotificationWithOSDState; break;
		case SOAP_TYPE_ns2__CurrentObjectListNotification: t = SOAP_TYPE_ns2__NotificationWithOSDState; break;
		case SOAP_TYPE_ns2__HistoricObjectListNotification: t = SOAP_TYPE_ns2__HistoricObjectListNotificationBase; break;
		case SOAP_TYPE_ns2__TaskSetDigitalOutput: t = SOAP_TYPE_ns2__TaskWithActivity; break;
		case SOAP_TYPE_ns2__TaskSubscribeTriggered: t = SOAP_TYPE_ns2__TaskWithActivity; break;
		case SOAP_TYPE_ns2__ErrorLogfilesNotification: t = SOAP_TYPE_ns2__ExtendedNotificationBase; break;
		case SOAP_TYPE_ns2__AliveNotification: t = SOAP_TYPE_ns2__ExtendedNotificationBase; break;
		case SOAP_TYPE_ns2__StartupNotification: t = SOAP_TYPE_ns2__ExtendedNotificationBase; break;
		case SOAP_TYPE_ns2__FeatureInfoNotification: t = SOAP_TYPE_ns2__ExtendedNotificationBase; break;
		case SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe: t = SOAP_TYPE_ns2__TaskSubscribeTriggered; break;
		case SOAP_TYPE_ns2__TaskSubscribeLogfiles: t = SOAP_TYPE_ns2__TaskSubscribeTriggered; break;
		case SOAP_TYPE_ns2__TaskSubscribeErrorLog: t = SOAP_TYPE_ns2__TaskSubscribeTriggered; break;
		case SOAP_TYPE_ns2__TaskSubscribeCameraImages: t = SOAP_TYPE_ns2__TaskSubscribeTriggered; break;
		case SOAP_TYPE_ns2__TaskSubscribeSendParameters: t = SOAP_TYPE_ns2__TaskSubscribeTriggered; break;
		case SOAP_TYPE_ns2__TaskSubscribeVideoStore: t = SOAP_TYPE_ns2__TaskSubscribeTriggered; break;
		case SOAP_TYPE_ns2__TaskSubscribeAlive: t = SOAP_TYPE_ns2__TaskSubscribeTriggered; break;
		case SOAP_TYPE_ns2__TaskSubscribeObjectList: t = SOAP_TYPE_ns2__TaskSubscribeTriggered; break;
		case SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo: t = SOAP_TYPE_ns2__TaskSubscribeTriggered; break;
		case SOAP_TYPE_ns2__ErrorContainer: t = SOAP_TYPE_ns2__ExtendedNotificationBase; break;
		case SOAP_TYPE_ns2__TaskSubscribeCounting: t = SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe; break;
		case SOAP_TYPE_ns2__TaskSubscribeCountChannels: t = SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe; break;
		case SOAP_TYPE_ns2__TaskSubscribeZoneChannels: t = SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe; break;
		case SOAP_TYPE_ns2__TaskSubscribeFill: t = SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe; break;
		case SOAP_TYPE_ns2__TaskSubscribeClearZone: t = SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe; break;
		case SOAP_TYPE_ns2__TaskSubscribeDigitalInput: t = SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_std__wstring:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::wstring type=%d location=%p object=%p\n", t, p, q));
		*(std::wstring*)p = *(std::wstring*)q;
		break;
	case SOAP_TYPE_ns2__DigitalInputElement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DigitalInputElement type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DigitalInputElement*)p = *(ns2__DigitalInputElement*)q;
		break;
	case SOAP_TYPE_ns2__DigitalOutputElement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DigitalOutputElement type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DigitalOutputElement*)p = *(ns2__DigitalOutputElement*)q;
		break;
	case SOAP_TYPE_ns2__CountEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CountEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CountEvent*)p = *(ns2__CountEvent*)q;
		break;
	case SOAP_TYPE_ns2__CountChannelsEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CountChannelsEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CountChannelsEvent*)p = *(ns2__CountChannelsEvent*)q;
		break;
	case SOAP_TYPE_ns2__ZoneChannelsEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ZoneChannelsEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ZoneChannelsEvent*)p = *(ns2__ZoneChannelsEvent*)q;
		break;
	case SOAP_TYPE_ns2__FillEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FillEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FillEvent*)p = *(ns2__FillEvent*)q;
		break;
	case SOAP_TYPE_ns2__ClearZoneEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ClearZoneEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ClearZoneEvent*)p = *(ns2__ClearZoneEvent*)q;
		break;
	case SOAP_TYPE_ns2__DigitalInputEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DigitalInputEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DigitalInputEvent*)p = *(ns2__DigitalInputEvent*)q;
		break;
	case SOAP_TYPE_ns2__OneTimeEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__OneTimeEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__OneTimeEvent*)p = *(ns2__OneTimeEvent*)q;
		break;
	case SOAP_TYPE_ns2__CurrentObjectListEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CurrentObjectListEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CurrentObjectListEvent*)p = *(ns2__CurrentObjectListEvent*)q;
		break;
	case SOAP_TYPE_ns2__OSD_USCOREEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__OSD_USCOREEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__OSD_USCOREEvent*)p = *(ns2__OSD_USCOREEvent*)q;
		break;
	case SOAP_TYPE_ns2__FeatureChangedEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FeatureChangedEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FeatureChangedEvent*)p = *(ns2__FeatureChangedEvent*)q;
		break;
	case SOAP_TYPE__ns2__union_EventTrigger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns2__union_EventTrigger type=%d location=%p object=%p\n", t, p, q));
		*(union _ns2__union_EventTrigger*)p = *(union _ns2__union_EventTrigger*)q;
		break;
	case SOAP_TYPE_ns2__EventTrigger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__EventTrigger type=%d location=%p object=%p\n", t, p, q));
		*(ns2__EventTrigger*)p = *(ns2__EventTrigger*)q;
		break;
	case SOAP_TYPE_ns2__Date:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Date type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Date*)p = *(ns2__Date*)q;
		break;
	case SOAP_TYPE_ns2__ClockTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ClockTime type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ClockTime*)p = *(ns2__ClockTime*)q;
		break;
	case SOAP_TYPE_ns2__TimeTrigger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TimeTrigger type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TimeTrigger*)p = *(ns2__TimeTrigger*)q;
		break;
	case SOAP_TYPE__ns2__union_Trigger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns2__union_Trigger type=%d location=%p object=%p\n", t, p, q));
		*(union _ns2__union_Trigger*)p = *(union _ns2__union_Trigger*)q;
		break;
	case SOAP_TYPE_ns2__Trigger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Trigger type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Trigger*)p = *(ns2__Trigger*)q;
		break;
	case SOAP_TYPE_ns2__CountingGateID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CountingGateID type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CountingGateID*)p = *(ns2__CountingGateID*)q;
		break;
	case SOAP_TYPE_ns2__FillRegionID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FillRegionID type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FillRegionID*)p = *(ns2__FillRegionID*)q;
		break;
	case SOAP_TYPE_ns2__ClearZoneID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ClearZoneID type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ClearZoneID*)p = *(ns2__ClearZoneID*)q;
		break;
	case SOAP_TYPE_ns2__BinaryData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BinaryData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BinaryData*)p = *(ns2__BinaryData*)q;
		break;
	case SOAP_TYPE_ns2__NotificationBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__NotificationBase type=%d location=%p object=%p\n", t, p, q));
		*(ns2__NotificationBase*)p = *(ns2__NotificationBase*)q;
		break;
	case SOAP_TYPE_ns2__CountChannelData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CountChannelData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CountChannelData*)p = *(ns2__CountChannelData*)q;
		break;
	case SOAP_TYPE_ns2__ZoneData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ZoneData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ZoneData*)p = *(ns2__ZoneData*)q;
		break;
	case SOAP_TYPE_ns2__CountChannelFeatureInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CountChannelFeatureInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CountChannelFeatureInfo*)p = *(ns2__CountChannelFeatureInfo*)q;
		break;
	case SOAP_TYPE_ns2__CountChannelsFeatureInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CountChannelsFeatureInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CountChannelsFeatureInfo*)p = *(ns2__CountChannelsFeatureInfo*)q;
		break;
	case SOAP_TYPE_ns2__ZoneChannelFeatureInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ZoneChannelFeatureInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ZoneChannelFeatureInfo*)p = *(ns2__ZoneChannelFeatureInfo*)q;
		break;
	case SOAP_TYPE_ns2__ZoneChannelsFeatureInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ZoneChannelsFeatureInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ZoneChannelsFeatureInfo*)p = *(ns2__ZoneChannelsFeatureInfo*)q;
		break;
	case SOAP_TYPE_ns2__Coordinate_USCORE2D:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Coordinate_USCORE2D type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Coordinate_USCORE2D*)p = *(ns2__Coordinate_USCORE2D*)q;
		break;
	case SOAP_TYPE_ns2__Object:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Object type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Object*)p = *(ns2__Object*)q;
		break;
	case SOAP_TYPE__ns2__union_NotificationContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns2__union_NotificationContainer type=%d location=%p object=%p\n", t, p, q));
		*(union _ns2__union_NotificationContainer*)p = *(union _ns2__union_NotificationContainer*)q;
		break;
	case SOAP_TYPE_ns2__NotificationContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__NotificationContainer type=%d location=%p object=%p\n", t, p, q));
		*(ns2__NotificationContainer*)p = *(ns2__NotificationContainer*)q;
		break;
	case SOAP_TYPE_ns2__Task:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Task type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Task*)p = *(ns2__Task*)q;
		break;
	case SOAP_TYPE_ns2__DigitalInputControl:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DigitalInputControl type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DigitalInputControl*)p = *(ns2__DigitalInputControl*)q;
		break;
	case SOAP_TYPE__ns2__union_TaskContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _ns2__union_TaskContainer type=%d location=%p object=%p\n", t, p, q));
		*(union _ns2__union_TaskContainer*)p = *(union _ns2__union_TaskContainer*)q;
		break;
	case SOAP_TYPE___ns2__union_TaskContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy __ns2__union_TaskContainer type=%d location=%p object=%p\n", t, p, q));
		*(__ns2__union_TaskContainer*)p = *(__ns2__union_TaskContainer*)q;
		break;
	case SOAP_TYPE_ns2__TaskContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskContainer type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskContainer*)p = *(ns2__TaskContainer*)q;
		break;
	case SOAP_TYPE_ns2__NotificationWithOSDState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__NotificationWithOSDState type=%d location=%p object=%p\n", t, p, q));
		*(ns2__NotificationWithOSDState*)p = *(ns2__NotificationWithOSDState*)q;
		break;
	case SOAP_TYPE_ns2__DigitalInputNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DigitalInputNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DigitalInputNotification*)p = *(ns2__DigitalInputNotification*)q;
		break;
	case SOAP_TYPE_ns2__LogfilesNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__LogfilesNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__LogfilesNotification*)p = *(ns2__LogfilesNotification*)q;
		break;
	case SOAP_TYPE_ns2__ParameterNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ParameterNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ParameterNotification*)p = *(ns2__ParameterNotification*)q;
		break;
	case SOAP_TYPE_ns2__Coordinate_USCORE3D:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Coordinate_USCORE3D type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Coordinate_USCORE3D*)p = *(ns2__Coordinate_USCORE3D*)q;
		break;
	case SOAP_TYPE_ns2__CurrentObject:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CurrentObject type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CurrentObject*)p = *(ns2__CurrentObject*)q;
		break;
	case SOAP_TYPE_ns2__HistoricObject:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__HistoricObject type=%d location=%p object=%p\n", t, p, q));
		*(ns2__HistoricObject*)p = *(ns2__HistoricObject*)q;
		break;
	case SOAP_TYPE_ns2__HistoricObjectListNotificationBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__HistoricObjectListNotificationBase type=%d location=%p object=%p\n", t, p, q));
		*(ns2__HistoricObjectListNotificationBase*)p = *(ns2__HistoricObjectListNotificationBase*)q;
		break;
	case SOAP_TYPE_ns2__TaskRebootNow:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskRebootNow type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskRebootNow*)p = *(ns2__TaskRebootNow*)q;
		break;
	case SOAP_TYPE_ns2__TaskRequestUpdate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskRequestUpdate type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskRequestUpdate*)p = *(ns2__TaskRequestUpdate*)q;
		break;
	case SOAP_TYPE_ns2__TaskRequestParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskRequestParameters type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskRequestParameters*)p = *(ns2__TaskRequestParameters*)q;
		break;
	case SOAP_TYPE_ns2__TaskWithActivity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskWithActivity type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskWithActivity*)p = *(ns2__TaskWithActivity*)q;
		break;
	case SOAP_TYPE_ns2__TaskSetDateTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSetDateTime type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSetDateTime*)p = *(ns2__TaskSetDateTime*)q;
		break;
	case SOAP_TYPE_ns2__TaskDeleteAllTasks:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskDeleteAllTasks type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskDeleteAllTasks*)p = *(ns2__TaskDeleteAllTasks*)q;
		break;
	case SOAP_TYPE_ns2__TaskDeleteAllNotifications:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskDeleteAllNotifications type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskDeleteAllNotifications*)p = *(ns2__TaskDeleteAllNotifications*)q;
		break;
	case SOAP_TYPE_ns2__AnswerContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AnswerContainer type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AnswerContainer*)p = *(ns2__AnswerContainer*)q;
		break;
	case SOAP_TYPE_ns2__ExtendedNotificationBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ExtendedNotificationBase type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ExtendedNotificationBase*)p = *(ns2__ExtendedNotificationBase*)q;
		break;
	case SOAP_TYPE_ns2__CountNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CountNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CountNotification*)p = *(ns2__CountNotification*)q;
		break;
	case SOAP_TYPE_ns2__CountChannelsNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CountChannelsNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CountChannelsNotification*)p = *(ns2__CountChannelsNotification*)q;
		break;
	case SOAP_TYPE_ns2__ZoneChannelsNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ZoneChannelsNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ZoneChannelsNotification*)p = *(ns2__ZoneChannelsNotification*)q;
		break;
	case SOAP_TYPE_ns2__FillNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FillNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FillNotification*)p = *(ns2__FillNotification*)q;
		break;
	case SOAP_TYPE_ns2__ClearZoneNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ClearZoneNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ClearZoneNotification*)p = *(ns2__ClearZoneNotification*)q;
		break;
	case SOAP_TYPE_ns2__CameraImagesNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CameraImagesNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CameraImagesNotification*)p = *(ns2__CameraImagesNotification*)q;
		break;
	case SOAP_TYPE_ns2__CurrentObjectListNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CurrentObjectListNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CurrentObjectListNotification*)p = *(ns2__CurrentObjectListNotification*)q;
		break;
	case SOAP_TYPE_ns2__HistoricObjectListNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__HistoricObjectListNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__HistoricObjectListNotification*)p = *(ns2__HistoricObjectListNotification*)q;
		break;
	case SOAP_TYPE_ns2__TaskSetDigitalOutput:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSetDigitalOutput type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSetDigitalOutput*)p = *(ns2__TaskSetDigitalOutput*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeTriggered:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeTriggered type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeTriggered*)p = *(ns2__TaskSubscribeTriggered*)q;
		break;
	case SOAP_TYPE_ns2__ErrorLogfilesNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ErrorLogfilesNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ErrorLogfilesNotification*)p = *(ns2__ErrorLogfilesNotification*)q;
		break;
	case SOAP_TYPE_ns2__AliveNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AliveNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AliveNotification*)p = *(ns2__AliveNotification*)q;
		break;
	case SOAP_TYPE_ns2__StartupNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__StartupNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__StartupNotification*)p = *(ns2__StartupNotification*)q;
		break;
	case SOAP_TYPE_ns2__FeatureInfoNotification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FeatureInfoNotification type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FeatureInfoNotification*)p = *(ns2__FeatureInfoNotification*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeTriggeredSafe type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeTriggeredSafe*)p = *(ns2__TaskSubscribeTriggeredSafe*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeLogfiles:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeLogfiles type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeLogfiles*)p = *(ns2__TaskSubscribeLogfiles*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeErrorLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeErrorLog type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeErrorLog*)p = *(ns2__TaskSubscribeErrorLog*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeCameraImages:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeCameraImages type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeCameraImages*)p = *(ns2__TaskSubscribeCameraImages*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeSendParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeSendParameters type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeSendParameters*)p = *(ns2__TaskSubscribeSendParameters*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeVideoStore:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeVideoStore type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeVideoStore*)p = *(ns2__TaskSubscribeVideoStore*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeAlive:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeAlive type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeAlive*)p = *(ns2__TaskSubscribeAlive*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeObjectList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeObjectList type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeObjectList*)p = *(ns2__TaskSubscribeObjectList*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeFeaturesInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeFeaturesInfo*)p = *(ns2__TaskSubscribeFeaturesInfo*)q;
		break;
	case SOAP_TYPE_ns2__ErrorContainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ErrorContainer type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ErrorContainer*)p = *(ns2__ErrorContainer*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeCounting:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeCounting type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeCounting*)p = *(ns2__TaskSubscribeCounting*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeCountChannels:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeCountChannels type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeCountChannels*)p = *(ns2__TaskSubscribeCountChannels*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeZoneChannels:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeZoneChannels type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeZoneChannels*)p = *(ns2__TaskSubscribeZoneChannels*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeFill:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeFill type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeFill*)p = *(ns2__TaskSubscribeFill*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeClearZone:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeClearZone type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeClearZone*)p = *(ns2__TaskSubscribeClearZone*)q;
		break;
	case SOAP_TYPE_ns2__TaskSubscribeDigitalInput:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaskSubscribeDigitalInput type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaskSubscribeDigitalInput*)p = *(ns2__TaskSubscribeDigitalInput*)q;
		break;
	case SOAP_TYPE___ns1__Notification:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Notification type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Notification*)p = *(struct __ns1__Notification*)q;
		break;
	case SOAP_TYPE___ns1__Error:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Error type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Error*)p = *(struct __ns1__Error*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::wstring type=%d location=%p object=%p\n", t, p, q));
		*(std::wstring*)p = *(std::wstring*)q;
		break;
	case SOAP_TYPE_ns2__IP_USCOREAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::wstring type=%d location=%p object=%p\n", t, p, q));
		*(std::wstring*)p = *(std::wstring*)q;
		break;
	case SOAP_TYPE_ns2__MAC_USCOREAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::wstring type=%d location=%p object=%p\n", t, p, q));
		*(std::wstring*)p = *(std::wstring*)q;
		break;
	case SOAP_TYPE_ns2__MeasuringChannelName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::wstring type=%d location=%p object=%p\n", t, p, q));
		*(std::wstring*)p = *(std::wstring*)q;
		break;
	case SOAP_TYPE_ns2__ObjectClassName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::wstring type=%d location=%p object=%p\n", t, p, q));
		*(std::wstring*)p = *(std::wstring*)q;
		break;
	case SOAP_TYPE_ns2__ShortDuration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::wstring type=%d location=%p object=%p\n", t, p, q));
		*(std::wstring*)p = *(std::wstring*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MinutesOrSeconds(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__MinutesOrSeconds
	*a = SOAP_DEFAULT_ns2__MinutesOrSeconds;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MinutesOrSeconds(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_ns2__MinutesOrSeconds);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__MinutesOrSeconds(struct soap *soap, const char *s, unsigned int *a)
{
	int err = soap_s2unsignedInt(soap, s, a);
	if (!err)
	{
		if (*a > 59)
			return soap->error = SOAP_LENGTH;
	}
	return err;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_ns2__MinutesOrSeconds(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_ns2__MinutesOrSeconds);
	if (a && *a > 59)
	{	soap->error = SOAP_LENGTH;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MinutesOrSeconds(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_ns2__MinutesOrSeconds(soap, tag ? tag : "ns2:MinutesOrSeconds", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_ns2__MinutesOrSeconds(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MinutesOrSeconds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__HoursOfDay(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__HoursOfDay
	*a = SOAP_DEFAULT_ns2__HoursOfDay;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HoursOfDay(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_ns2__HoursOfDay);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__HoursOfDay(struct soap *soap, const char *s, unsigned int *a)
{
	int err = soap_s2unsignedInt(soap, s, a);
	if (!err)
	{
		if (*a > 23)
			return soap->error = SOAP_LENGTH;
	}
	return err;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_ns2__HoursOfDay(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_ns2__HoursOfDay);
	if (a && *a > 23)
	{	soap->error = SOAP_LENGTH;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__HoursOfDay(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_ns2__HoursOfDay(soap, tag ? tag : "ns2:HoursOfDay", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_ns2__HoursOfDay(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HoursOfDay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DayOfMonth(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DayOfMonth
	*a = SOAP_DEFAULT_ns2__DayOfMonth;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DayOfMonth(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_ns2__DayOfMonth);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DayOfMonth(struct soap *soap, const char *s, unsigned int *a)
{
	int err = soap_s2unsignedInt(soap, s, a);
	if (!err)
	{
		if (*a > 31)
			return soap->error = SOAP_LENGTH;
	}
	return err;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_ns2__DayOfMonth(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_ns2__DayOfMonth);
	if (a && *a > 31)
	{	soap->error = SOAP_LENGTH;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DayOfMonth(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_ns2__DayOfMonth(soap, tag ? tag : "ns2:DayOfMonth", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_ns2__DayOfMonth(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DayOfMonth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dateTime(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dateTime
	*a = SOAP_DEFAULT_dateTime;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TransferType(struct soap *soap, enum ns2__TransferType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__TransferType
	*a = SOAP_DEFAULT_ns2__TransferType;
#else
	*a = (enum ns2__TransferType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__TransferType[] =
{	{ (LONG64)ns2__TransferType__TRANSFER_USCOREINLINE, "TRANSFER_INLINE" },
	{ (LONG64)ns2__TransferType__TRANSFER_USCOREBINARY, "TRANSFER_BINARY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__TransferType2s(struct soap *soap, enum ns2__TransferType n)
{	const char *s = soap_code_str(soap_codes_ns2__TransferType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TransferType(struct soap *soap, const char *tag, int id, const enum ns2__TransferType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TransferType), type) || soap_send(soap, soap_ns2__TransferType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__TransferType(struct soap *soap, const char *s, enum ns2__TransferType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__TransferType, s);
	if (map)
		*a = (enum ns2__TransferType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__TransferType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__TransferType * SOAP_FMAC4 soap_in_ns2__TransferType(struct soap *soap, const char *tag, enum ns2__TransferType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__TransferType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TransferType, sizeof(enum ns2__TransferType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__TransferType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__TransferType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TransferType, SOAP_TYPE_ns2__TransferType, sizeof(enum ns2__TransferType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TransferType(struct soap *soap, const enum ns2__TransferType *a, const char *tag, const char *type)
{
	if (soap_out_ns2__TransferType(soap, tag ? tag : "ns2:TransferType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__TransferType * SOAP_FMAC4 soap_get_ns2__TransferType(struct soap *soap, enum ns2__TransferType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TransferType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__UpdateType(struct soap *soap, enum ns2__UpdateType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__UpdateType
	*a = SOAP_DEFAULT_ns2__UpdateType;
#else
	*a = (enum ns2__UpdateType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__UpdateType[] =
{	{ (LONG64)ns2__UpdateType__UPDATE_USCOREFIRMWARE, "UPDATE_FIRMWARE" },
	{ (LONG64)ns2__UpdateType__UPDATE_USCORECUSTOMER_USCORESOFTWARE, "UPDATE_CUSTOMER_SOFTWARE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__UpdateType2s(struct soap *soap, enum ns2__UpdateType n)
{	const char *s = soap_code_str(soap_codes_ns2__UpdateType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UpdateType(struct soap *soap, const char *tag, int id, const enum ns2__UpdateType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UpdateType), type) || soap_send(soap, soap_ns2__UpdateType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__UpdateType(struct soap *soap, const char *s, enum ns2__UpdateType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__UpdateType, s);
	if (map)
		*a = (enum ns2__UpdateType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__UpdateType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__UpdateType * SOAP_FMAC4 soap_in_ns2__UpdateType(struct soap *soap, const char *tag, enum ns2__UpdateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__UpdateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UpdateType, sizeof(enum ns2__UpdateType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__UpdateType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__UpdateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UpdateType, SOAP_TYPE_ns2__UpdateType, sizeof(enum ns2__UpdateType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UpdateType(struct soap *soap, const enum ns2__UpdateType *a, const char *tag, const char *type)
{
	if (soap_out_ns2__UpdateType(soap, tag ? tag : "ns2:UpdateType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__UpdateType * SOAP_FMAC4 soap_get_ns2__UpdateType(struct soap *soap, enum ns2__UpdateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UpdateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RebootType(struct soap *soap, enum ns2__RebootType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__RebootType
	*a = SOAP_DEFAULT_ns2__RebootType;
#else
	*a = (enum ns2__RebootType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__RebootType[] =
{	{ (LONG64)ns2__RebootType__SOAP_USCOREREBOOT_USCOREPOWERON, "SOAP_REBOOT_POWERON" },
	{ (LONG64)ns2__RebootType__SOAP_USCOREREBOOT_USCOREWATCHDOG, "SOAP_REBOOT_WATCHDOG" },
	{ (LONG64)ns2__RebootType__SOAP_USCOREREBOOT_USCOREUPDATE, "SOAP_REBOOT_UPDATE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__RebootType2s(struct soap *soap, enum ns2__RebootType n)
{	const char *s = soap_code_str(soap_codes_ns2__RebootType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RebootType(struct soap *soap, const char *tag, int id, const enum ns2__RebootType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RebootType), type) || soap_send(soap, soap_ns2__RebootType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__RebootType(struct soap *soap, const char *s, enum ns2__RebootType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__RebootType, s);
	if (map)
		*a = (enum ns2__RebootType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__RebootType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__RebootType * SOAP_FMAC4 soap_in_ns2__RebootType(struct soap *soap, const char *tag, enum ns2__RebootType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__RebootType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RebootType, sizeof(enum ns2__RebootType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__RebootType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__RebootType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RebootType, SOAP_TYPE_ns2__RebootType, sizeof(enum ns2__RebootType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RebootType(struct soap *soap, const enum ns2__RebootType *a, const char *tag, const char *type)
{
	if (soap_out_ns2__RebootType(soap, tag ? tag : "ns2:RebootType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__RebootType * SOAP_FMAC4 soap_get_ns2__RebootType(struct soap *soap, enum ns2__RebootType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RebootType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DayOfWeek(struct soap *soap, enum ns2__DayOfWeek *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DayOfWeek
	*a = SOAP_DEFAULT_ns2__DayOfWeek;
#else
	*a = (enum ns2__DayOfWeek)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DayOfWeek[] =
{	{ (LONG64)ns2__DayOfWeek__MONDAY, "MONDAY" },
	{ (LONG64)ns2__DayOfWeek__TUESDAY, "TUESDAY" },
	{ (LONG64)ns2__DayOfWeek__WEDNESDAY, "WEDNESDAY" },
	{ (LONG64)ns2__DayOfWeek__THURSDAY, "THURSDAY" },
	{ (LONG64)ns2__DayOfWeek__FRIDAY, "FRIDAY" },
	{ (LONG64)ns2__DayOfWeek__SATURDAY, "SATURDAY" },
	{ (LONG64)ns2__DayOfWeek__SUNDAY, "SUNDAY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DayOfWeek2s(struct soap *soap, enum ns2__DayOfWeek n)
{	const char *s = soap_code_str(soap_codes_ns2__DayOfWeek, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DayOfWeek(struct soap *soap, const char *tag, int id, const enum ns2__DayOfWeek *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DayOfWeek), type) || soap_send(soap, soap_ns2__DayOfWeek2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DayOfWeek(struct soap *soap, const char *s, enum ns2__DayOfWeek *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DayOfWeek, s);
	if (map)
		*a = (enum ns2__DayOfWeek)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DayOfWeek)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DayOfWeek * SOAP_FMAC4 soap_in_ns2__DayOfWeek(struct soap *soap, const char *tag, enum ns2__DayOfWeek *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DayOfWeek *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DayOfWeek, sizeof(enum ns2__DayOfWeek), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__DayOfWeek(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DayOfWeek *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DayOfWeek, SOAP_TYPE_ns2__DayOfWeek, sizeof(enum ns2__DayOfWeek), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DayOfWeek(struct soap *soap, const enum ns2__DayOfWeek *a, const char *tag, const char *type)
{
	if (soap_out_ns2__DayOfWeek(soap, tag ? tag : "ns2:DayOfWeek", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DayOfWeek * SOAP_FMAC4 soap_get_ns2__DayOfWeek(struct soap *soap, enum ns2__DayOfWeek *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DayOfWeek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DateType(struct soap *soap, enum ns2__DateType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DateType
	*a = SOAP_DEFAULT_ns2__DateType;
#else
	*a = (enum ns2__DateType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DateType[] =
{	{ (LONG64)ns2__DateType__DATE_USCOREDONT_USCORECARE, "DATE_DONT_CARE" },
	{ (LONG64)ns2__DateType__DATE_USCOREDAY_USCOREOF_USCOREWEEK, "DATE_DAY_OF_WEEK" },
	{ (LONG64)ns2__DateType__DATE_USCOREDAY_USCOREOF_USCOREMONTH, "DATE_DAY_OF_MONTH" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DateType2s(struct soap *soap, enum ns2__DateType n)
{	const char *s = soap_code_str(soap_codes_ns2__DateType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DateType(struct soap *soap, const char *tag, int id, const enum ns2__DateType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DateType), type) || soap_send(soap, soap_ns2__DateType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DateType(struct soap *soap, const char *s, enum ns2__DateType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DateType, s);
	if (map)
		*a = (enum ns2__DateType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DateType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DateType * SOAP_FMAC4 soap_in_ns2__DateType(struct soap *soap, const char *tag, enum ns2__DateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DateType, sizeof(enum ns2__DateType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__DateType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DateType, SOAP_TYPE_ns2__DateType, sizeof(enum ns2__DateType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DateType(struct soap *soap, const enum ns2__DateType *a, const char *tag, const char *type)
{
	if (soap_out_ns2__DateType(soap, tag ? tag : "ns2:DateType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DateType * SOAP_FMAC4 soap_get_ns2__DateType(struct soap *soap, enum ns2__DateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DigitalInputEventType(struct soap *soap, enum ns2__DigitalInputEventType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DigitalInputEventType
	*a = SOAP_DEFAULT_ns2__DigitalInputEventType;
#else
	*a = (enum ns2__DigitalInputEventType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DigitalInputEventType[] =
{	{ (LONG64)ns2__DigitalInputEventType__DIGITAL_USCOREINPUT_USCOREEVENT_USCOREINACTIVE, "DIGITAL_INPUT_EVENT_INACTIVE" },
	{ (LONG64)ns2__DigitalInputEventType__DIGITAL_USCOREINPUT_USCOREEVENT_USCOREACTIVE, "DIGITAL_INPUT_EVENT_ACTIVE" },
	{ (LONG64)ns2__DigitalInputEventType__DIGITAL_USCOREINPUT_USCOREEVENT_USCOREANY, "DIGITAL_INPUT_EVENT_ANY" },
	{ (LONG64)ns2__DigitalInputEventType__DIGITAL_USCOREINPUT_USCOREEVENT_USCOREIGNORE, "DIGITAL_INPUT_EVENT_IGNORE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DigitalInputEventType2s(struct soap *soap, enum ns2__DigitalInputEventType n)
{	const char *s = soap_code_str(soap_codes_ns2__DigitalInputEventType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DigitalInputEventType(struct soap *soap, const char *tag, int id, const enum ns2__DigitalInputEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DigitalInputEventType), type) || soap_send(soap, soap_ns2__DigitalInputEventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DigitalInputEventType(struct soap *soap, const char *s, enum ns2__DigitalInputEventType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DigitalInputEventType, s);
	if (map)
		*a = (enum ns2__DigitalInputEventType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DigitalInputEventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DigitalInputEventType * SOAP_FMAC4 soap_in_ns2__DigitalInputEventType(struct soap *soap, const char *tag, enum ns2__DigitalInputEventType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DigitalInputEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DigitalInputEventType, sizeof(enum ns2__DigitalInputEventType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__DigitalInputEventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DigitalInputEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DigitalInputEventType, SOAP_TYPE_ns2__DigitalInputEventType, sizeof(enum ns2__DigitalInputEventType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DigitalInputEventType(struct soap *soap, const enum ns2__DigitalInputEventType *a, const char *tag, const char *type)
{
	if (soap_out_ns2__DigitalInputEventType(soap, tag ? tag : "ns2:DigitalInputEventType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DigitalInputEventType * SOAP_FMAC4 soap_get_ns2__DigitalInputEventType(struct soap *soap, enum ns2__DigitalInputEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DigitalInputEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ClearZoneEventType(struct soap *soap, enum ns2__ClearZoneEventType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ClearZoneEventType
	*a = SOAP_DEFAULT_ns2__ClearZoneEventType;
#else
	*a = (enum ns2__ClearZoneEventType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ClearZoneEventType[] =
{	{ (LONG64)ns2__ClearZoneEventType__CLEAR_USCOREZONE_USCOREEVENT_USCOREFREE, "CLEAR_ZONE_EVENT_FREE" },
	{ (LONG64)ns2__ClearZoneEventType__CLEAR_USCOREZONE_USCOREEVENT_USCOREBLOCKED, "CLEAR_ZONE_EVENT_BLOCKED" },
	{ (LONG64)ns2__ClearZoneEventType__CLEAR_USCOREZONE_USCOREEVENT_USCOREANY, "CLEAR_ZONE_EVENT_ANY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ClearZoneEventType2s(struct soap *soap, enum ns2__ClearZoneEventType n)
{	const char *s = soap_code_str(soap_codes_ns2__ClearZoneEventType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ClearZoneEventType(struct soap *soap, const char *tag, int id, const enum ns2__ClearZoneEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ClearZoneEventType), type) || soap_send(soap, soap_ns2__ClearZoneEventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ClearZoneEventType(struct soap *soap, const char *s, enum ns2__ClearZoneEventType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ClearZoneEventType, s);
	if (map)
		*a = (enum ns2__ClearZoneEventType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ClearZoneEventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ClearZoneEventType * SOAP_FMAC4 soap_in_ns2__ClearZoneEventType(struct soap *soap, const char *tag, enum ns2__ClearZoneEventType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ClearZoneEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ClearZoneEventType, sizeof(enum ns2__ClearZoneEventType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__ClearZoneEventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ClearZoneEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ClearZoneEventType, SOAP_TYPE_ns2__ClearZoneEventType, sizeof(enum ns2__ClearZoneEventType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ClearZoneEventType(struct soap *soap, const enum ns2__ClearZoneEventType *a, const char *tag, const char *type)
{
	if (soap_out_ns2__ClearZoneEventType(soap, tag ? tag : "ns2:ClearZoneEventType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ClearZoneEventType * SOAP_FMAC4 soap_get_ns2__ClearZoneEventType(struct soap *soap, enum ns2__ClearZoneEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ClearZoneEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__FillEventType(struct soap *soap, enum ns2__FillEventType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__FillEventType
	*a = SOAP_DEFAULT_ns2__FillEventType;
#else
	*a = (enum ns2__FillEventType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__FillEventType[] =
{	{ (LONG64)ns2__FillEventType__FILL_USCOREEVENT_USCOREABOVE_USCORETHRESHOLD, "FILL_EVENT_ABOVE_THRESHOLD" },
	{ (LONG64)ns2__FillEventType__FILL_USCOREEVENT_USCOREBELOW_USCORETHRESHOLD, "FILL_EVENT_BELOW_THRESHOLD" },
	{ (LONG64)ns2__FillEventType__FILL_USCOREEVENT_USCOREANY, "FILL_EVENT_ANY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__FillEventType2s(struct soap *soap, enum ns2__FillEventType n)
{	const char *s = soap_code_str(soap_codes_ns2__FillEventType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FillEventType(struct soap *soap, const char *tag, int id, const enum ns2__FillEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FillEventType), type) || soap_send(soap, soap_ns2__FillEventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__FillEventType(struct soap *soap, const char *s, enum ns2__FillEventType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__FillEventType, s);
	if (map)
		*a = (enum ns2__FillEventType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__FillEventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__FillEventType * SOAP_FMAC4 soap_in_ns2__FillEventType(struct soap *soap, const char *tag, enum ns2__FillEventType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__FillEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FillEventType, sizeof(enum ns2__FillEventType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__FillEventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__FillEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FillEventType, SOAP_TYPE_ns2__FillEventType, sizeof(enum ns2__FillEventType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__FillEventType(struct soap *soap, const enum ns2__FillEventType *a, const char *tag, const char *type)
{
	if (soap_out_ns2__FillEventType(soap, tag ? tag : "ns2:FillEventType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__FillEventType * SOAP_FMAC4 soap_get_ns2__FillEventType(struct soap *soap, enum ns2__FillEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FillEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CountEventType(struct soap *soap, enum ns2__CountEventType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CountEventType
	*a = SOAP_DEFAULT_ns2__CountEventType;
#else
	*a = (enum ns2__CountEventType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CountEventType[] =
{	{ (LONG64)ns2__CountEventType__COUNT_USCOREEVENT_USCOREALWAYS, "COUNT_EVENT_ALWAYS" },
	{ (LONG64)ns2__CountEventType__COUNT_USCOREEVENT_USCOREDELTA_USCOREIN, "COUNT_EVENT_DELTA_IN" },
	{ (LONG64)ns2__CountEventType__COUNT_USCOREEVENT_USCOREDELTA_USCOREOUT, "COUNT_EVENT_DELTA_OUT" },
	{ (LONG64)ns2__CountEventType__COUNT_USCOREEVENT_USCOREDELTA_USCORESUM_USCOREIN_USCOREOUT, "COUNT_EVENT_DELTA_SUM_IN_OUT" },
	{ (LONG64)ns2__CountEventType__COUNT_USCOREEVENT_USCOREDELTA_USCOREMAX_USCOREIN_USCOREOUT, "COUNT_EVENT_DELTA_MAX_IN_OUT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CountEventType2s(struct soap *soap, enum ns2__CountEventType n)
{	const char *s = soap_code_str(soap_codes_ns2__CountEventType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CountEventType(struct soap *soap, const char *tag, int id, const enum ns2__CountEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CountEventType), type) || soap_send(soap, soap_ns2__CountEventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CountEventType(struct soap *soap, const char *s, enum ns2__CountEventType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CountEventType, s);
	if (map)
		*a = (enum ns2__CountEventType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CountEventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CountEventType * SOAP_FMAC4 soap_in_ns2__CountEventType(struct soap *soap, const char *tag, enum ns2__CountEventType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CountEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CountEventType, sizeof(enum ns2__CountEventType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__CountEventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CountEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CountEventType, SOAP_TYPE_ns2__CountEventType, sizeof(enum ns2__CountEventType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CountEventType(struct soap *soap, const enum ns2__CountEventType *a, const char *tag, const char *type)
{
	if (soap_out_ns2__CountEventType(soap, tag ? tag : "ns2:CountEventType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CountEventType * SOAP_FMAC4 soap_get_ns2__CountEventType(struct soap *soap, enum ns2__CountEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CountEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DigitalOutputActivity(struct soap *soap, enum ns2__DigitalOutputActivity *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DigitalOutputActivity
	*a = SOAP_DEFAULT_ns2__DigitalOutputActivity;
#else
	*a = (enum ns2__DigitalOutputActivity)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DigitalOutputActivity[] =
{	{ (LONG64)ns2__DigitalOutputActivity__DIGITAL_USCOREOUTPUT_USCORELOW, "DIGITAL_OUTPUT_LOW" },
	{ (LONG64)ns2__DigitalOutputActivity__DIGITAL_USCOREOUTPUT_USCOREHIGH, "DIGITAL_OUTPUT_HIGH" },
	{ (LONG64)ns2__DigitalOutputActivity__DIGITAL_USCOREOUTPUT_USCOREHOLD_USCORELOW, "DIGITAL_OUTPUT_HOLD_LOW" },
	{ (LONG64)ns2__DigitalOutputActivity__DIGITAL_USCOREOUTPUT_USCOREHOLD_USCOREHIGH, "DIGITAL_OUTPUT_HOLD_HIGH" },
	{ (LONG64)ns2__DigitalOutputActivity__DIGITAL_USCOREOUTPUT_USCOREUNTOUCHED, "DIGITAL_OUTPUT_UNTOUCHED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DigitalOutputActivity2s(struct soap *soap, enum ns2__DigitalOutputActivity n)
{	const char *s = soap_code_str(soap_codes_ns2__DigitalOutputActivity, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DigitalOutputActivity(struct soap *soap, const char *tag, int id, const enum ns2__DigitalOutputActivity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DigitalOutputActivity), type) || soap_send(soap, soap_ns2__DigitalOutputActivity2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DigitalOutputActivity(struct soap *soap, const char *s, enum ns2__DigitalOutputActivity *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DigitalOutputActivity, s);
	if (map)
		*a = (enum ns2__DigitalOutputActivity)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DigitalOutputActivity)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DigitalOutputActivity * SOAP_FMAC4 soap_in_ns2__DigitalOutputActivity(struct soap *soap, const char *tag, enum ns2__DigitalOutputActivity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DigitalOutputActivity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DigitalOutputActivity, sizeof(enum ns2__DigitalOutputActivity), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__DigitalOutputActivity(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DigitalOutputActivity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DigitalOutputActivity, SOAP_TYPE_ns2__DigitalOutputActivity, sizeof(enum ns2__DigitalOutputActivity), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DigitalOutputActivity(struct soap *soap, const enum ns2__DigitalOutputActivity *a, const char *tag, const char *type)
{
	if (soap_out_ns2__DigitalOutputActivity(soap, tag ? tag : "ns2:DigitalOutputActivity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DigitalOutputActivity * SOAP_FMAC4 soap_get_ns2__DigitalOutputActivity(struct soap *soap, enum ns2__DigitalOutputActivity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DigitalOutputActivity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DigitalInputValue(struct soap *soap, enum ns2__DigitalInputValue *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DigitalInputValue
	*a = SOAP_DEFAULT_ns2__DigitalInputValue;
#else
	*a = (enum ns2__DigitalInputValue)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DigitalInputValue[] =
{	{ (LONG64)ns2__DigitalInputValue__DIGITAL_USCOREINPUT_USCOREACTIVE, "DIGITAL_INPUT_ACTIVE" },
	{ (LONG64)ns2__DigitalInputValue__DIGITAL_USCOREINPUT_USCOREINACTIVE, "DIGITAL_INPUT_INACTIVE" },
	{ (LONG64)ns2__DigitalInputValue__DIGITAL_USCOREINPUT_USCORENOT_USCOREAVAIL, "DIGITAL_INPUT_NOT_AVAIL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DigitalInputValue2s(struct soap *soap, enum ns2__DigitalInputValue n)
{	const char *s = soap_code_str(soap_codes_ns2__DigitalInputValue, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DigitalInputValue(struct soap *soap, const char *tag, int id, const enum ns2__DigitalInputValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DigitalInputValue), type) || soap_send(soap, soap_ns2__DigitalInputValue2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DigitalInputValue(struct soap *soap, const char *s, enum ns2__DigitalInputValue *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DigitalInputValue, s);
	if (map)
		*a = (enum ns2__DigitalInputValue)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DigitalInputValue)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DigitalInputValue * SOAP_FMAC4 soap_in_ns2__DigitalInputValue(struct soap *soap, const char *tag, enum ns2__DigitalInputValue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DigitalInputValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DigitalInputValue, sizeof(enum ns2__DigitalInputValue), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__DigitalInputValue(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DigitalInputValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DigitalInputValue, SOAP_TYPE_ns2__DigitalInputValue, sizeof(enum ns2__DigitalInputValue), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DigitalInputValue(struct soap *soap, const enum ns2__DigitalInputValue *a, const char *tag, const char *type)
{
	if (soap_out_ns2__DigitalInputValue(soap, tag ? tag : "ns2:DigitalInputValue", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DigitalInputValue * SOAP_FMAC4 soap_get_ns2__DigitalInputValue(struct soap *soap, enum ns2__DigitalInputValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DigitalInputValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SOAP_USCOREDeviceError(struct soap *soap, enum ns2__SOAP_USCOREDeviceError *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__SOAP_USCOREDeviceError
	*a = SOAP_DEFAULT_ns2__SOAP_USCOREDeviceError;
#else
	*a = (enum ns2__SOAP_USCOREDeviceError)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__SOAP_USCOREDeviceError[] =
{	{ (LONG64)ns2__SOAP_USCOREDeviceError__SOAP_USCOREDEVICE_USCOREOK, "SOAP_DEVICE_OK" },
	{ (LONG64)ns2__SOAP_USCOREDeviceError__SOAP_USCOREERROR_USCOREUNKNOWN_USCORETASK, "SOAP_ERROR_UNKNOWN_TASK" },
	{ (LONG64)ns2__SOAP_USCOREDeviceError__SOAP_USCOREERROR_USCOREUNKNOWN_USCOREPARAM, "SOAP_ERROR_UNKNOWN_PARAM" },
	{ (LONG64)ns2__SOAP_USCOREDeviceError__SOAP_USCOREERROR_USCOREOUT_USCOREOF_USCORERESSOURCES, "SOAP_ERROR_OUT_OF_RESSOURCES" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__SOAP_USCOREDeviceError2s(struct soap *soap, enum ns2__SOAP_USCOREDeviceError n)
{	const char *s = soap_code_str(soap_codes_ns2__SOAP_USCOREDeviceError, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SOAP_USCOREDeviceError(struct soap *soap, const char *tag, int id, const enum ns2__SOAP_USCOREDeviceError *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SOAP_USCOREDeviceError), type) || soap_send(soap, soap_ns2__SOAP_USCOREDeviceError2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__SOAP_USCOREDeviceError(struct soap *soap, const char *s, enum ns2__SOAP_USCOREDeviceError *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__SOAP_USCOREDeviceError, s);
	if (map)
		*a = (enum ns2__SOAP_USCOREDeviceError)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__SOAP_USCOREDeviceError)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__SOAP_USCOREDeviceError * SOAP_FMAC4 soap_in_ns2__SOAP_USCOREDeviceError(struct soap *soap, const char *tag, enum ns2__SOAP_USCOREDeviceError *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__SOAP_USCOREDeviceError *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SOAP_USCOREDeviceError, sizeof(enum ns2__SOAP_USCOREDeviceError), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__SOAP_USCOREDeviceError(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__SOAP_USCOREDeviceError *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SOAP_USCOREDeviceError, SOAP_TYPE_ns2__SOAP_USCOREDeviceError, sizeof(enum ns2__SOAP_USCOREDeviceError), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SOAP_USCOREDeviceError(struct soap *soap, const enum ns2__SOAP_USCOREDeviceError *a, const char *tag, const char *type)
{
	if (soap_out_ns2__SOAP_USCOREDeviceError(soap, tag ? tag : "ns2:SOAP_DeviceError", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__SOAP_USCOREDeviceError * SOAP_FMAC4 soap_get_ns2__SOAP_USCOREDeviceError(struct soap *soap, enum ns2__SOAP_USCOREDeviceError *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SOAP_USCOREDeviceError(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SOAP_USCOREServerError(struct soap *soap, enum ns2__SOAP_USCOREServerError *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__SOAP_USCOREServerError
	*a = SOAP_DEFAULT_ns2__SOAP_USCOREServerError;
#else
	*a = (enum ns2__SOAP_USCOREServerError)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__SOAP_USCOREServerError[] =
{	{ (LONG64)ns2__SOAP_USCOREServerError__SOAP_USCORESERVER_USCOREOK, "SOAP_SERVER_OK" },
	{ (LONG64)ns2__SOAP_USCOREServerError__SOAP_USCOREERROR_USCOREUNKNOWN_USCORERESPONSE, "SOAP_ERROR_UNKNOWN_RESPONSE" },
	{ (LONG64)ns2__SOAP_USCOREServerError__SOAP_USCOREERROR_USCOREUNKNOWN_USCOREMESSAGE, "SOAP_ERROR_UNKNOWN_MESSAGE" },
	{ (LONG64)ns2__SOAP_USCOREServerError__SOAP_USCOREERROR_USCOREUNKNOWN_USCOREDEVICE, "SOAP_ERROR_UNKNOWN_DEVICE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__SOAP_USCOREServerError2s(struct soap *soap, enum ns2__SOAP_USCOREServerError n)
{	const char *s = soap_code_str(soap_codes_ns2__SOAP_USCOREServerError, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SOAP_USCOREServerError(struct soap *soap, const char *tag, int id, const enum ns2__SOAP_USCOREServerError *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SOAP_USCOREServerError), type) || soap_send(soap, soap_ns2__SOAP_USCOREServerError2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__SOAP_USCOREServerError(struct soap *soap, const char *s, enum ns2__SOAP_USCOREServerError *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__SOAP_USCOREServerError, s);
	if (map)
		*a = (enum ns2__SOAP_USCOREServerError)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__SOAP_USCOREServerError)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__SOAP_USCOREServerError * SOAP_FMAC4 soap_in_ns2__SOAP_USCOREServerError(struct soap *soap, const char *tag, enum ns2__SOAP_USCOREServerError *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__SOAP_USCOREServerError *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SOAP_USCOREServerError, sizeof(enum ns2__SOAP_USCOREServerError), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__SOAP_USCOREServerError(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__SOAP_USCOREServerError *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SOAP_USCOREServerError, SOAP_TYPE_ns2__SOAP_USCOREServerError, sizeof(enum ns2__SOAP_USCOREServerError), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SOAP_USCOREServerError(struct soap *soap, const enum ns2__SOAP_USCOREServerError *a, const char *tag, const char *type)
{
	if (soap_out_ns2__SOAP_USCOREServerError(soap, tag ? tag : "ns2:SOAP_ServerError", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__SOAP_USCOREServerError * SOAP_FMAC4 soap_get_ns2__SOAP_USCOREServerError(struct soap *soap, enum ns2__SOAP_USCOREServerError *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SOAP_USCOREServerError(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__OSD_USCOREState(struct soap *soap, enum ns2__OSD_USCOREState *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__OSD_USCOREState
	*a = SOAP_DEFAULT_ns2__OSD_USCOREState;
#else
	*a = (enum ns2__OSD_USCOREState)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__OSD_USCOREState[] =
{	{ (LONG64)ns2__OSD_USCOREState__OSD_USCORESTATE_USCOREOK, "OSD_STATE_OK" },
	{ (LONG64)ns2__OSD_USCOREState__OSD_USCORESTATE_USCOREERROR_USCORESENSOR_USCOREFAIL, "OSD_STATE_ERROR_SENSOR_FAIL" },
	{ (LONG64)ns2__OSD_USCOREState__OSD_USCORESTATE_USCOREWARNING_USCOREDARK, "OSD_STATE_WARNING_DARK" },
	{ (LONG64)ns2__OSD_USCOREState__OSD_USCORESTATE_USCOREERROR_USCOREDARK, "OSD_STATE_ERROR_DARK" },
	{ (LONG64)ns2__OSD_USCOREState__OSD_USCORESTATE_USCOREWARNING_USCOREBRIGHT, "OSD_STATE_WARNING_BRIGHT" },
	{ (LONG64)ns2__OSD_USCOREState__OSD_USCORESTATE_USCOREERROR_USCOREBRIGHT, "OSD_STATE_ERROR_BRIGHT" },
	{ (LONG64)ns2__OSD_USCOREState__OSD_USCORESTATE_USCORENOT_USCOREAVAIL, "OSD_STATE_NOT_AVAIL" },
	{ (LONG64)ns2__OSD_USCOREState__OSD_USCORESTATE_USCOREINVALID, "OSD_STATE_INVALID" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__OSD_USCOREState2s(struct soap *soap, enum ns2__OSD_USCOREState n)
{	const char *s = soap_code_str(soap_codes_ns2__OSD_USCOREState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OSD_USCOREState(struct soap *soap, const char *tag, int id, const enum ns2__OSD_USCOREState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OSD_USCOREState), type) || soap_send(soap, soap_ns2__OSD_USCOREState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__OSD_USCOREState(struct soap *soap, const char *s, enum ns2__OSD_USCOREState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__OSD_USCOREState, s);
	if (map)
		*a = (enum ns2__OSD_USCOREState)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 7)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__OSD_USCOREState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__OSD_USCOREState * SOAP_FMAC4 soap_in_ns2__OSD_USCOREState(struct soap *soap, const char *tag, enum ns2__OSD_USCOREState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__OSD_USCOREState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OSD_USCOREState, sizeof(enum ns2__OSD_USCOREState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__OSD_USCOREState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__OSD_USCOREState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OSD_USCOREState, SOAP_TYPE_ns2__OSD_USCOREState, sizeof(enum ns2__OSD_USCOREState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__OSD_USCOREState(struct soap *soap, const enum ns2__OSD_USCOREState *a, const char *tag, const char *type)
{
	if (soap_out_ns2__OSD_USCOREState(soap, tag ? tag : "ns2:OSD_State", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__OSD_USCOREState * SOAP_FMAC4 soap_get_ns2__OSD_USCOREState(struct soap *soap, enum ns2__OSD_USCOREState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OSD_USCOREState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TaskType(struct soap *soap, enum ns2__TaskType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__TaskType
	*a = SOAP_DEFAULT_ns2__TaskType;
#else
	*a = (enum ns2__TaskType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__TaskType[] =
{	{ (LONG64)ns2__TaskType__TASK_USCORESTARTUP, "TASK_STARTUP" },
	{ (LONG64)ns2__TaskType__TASK_USCOREUPDATE, "TASK_UPDATE" },
	{ (LONG64)ns2__TaskType__TASK_USCORECOUNT, "TASK_COUNT" },
	{ (LONG64)ns2__TaskType__TASK_USCOREFILL_USCORELEVEL, "TASK_FILL_LEVEL" },
	{ (LONG64)ns2__TaskType__TASK_USCOREDIGIT_USCOREINPUT, "TASK_DIGIT_INPUT" },
	{ (LONG64)ns2__TaskType__TASK_USCOREDIGIT_USCOREOUTPUT, "TASK_DIGIT_OUTPUT" },
	{ (LONG64)ns2__TaskType__TASK_USCORECAM_USCOREIMAGE, "TASK_CAM_IMAGE" },
	{ (LONG64)ns2__TaskType__TASK_USCOREPARAM, "TASK_PARAM" },
	{ (LONG64)ns2__TaskType__TASK_USCORESEND_USCOREPARAM, "TASK_SEND_PARAM" },
	{ (LONG64)ns2__TaskType__TASK_USCORELOG, "TASK_LOG" },
	{ (LONG64)ns2__TaskType__TASK_USCOREERR_USCORELOG, "TASK_ERR_LOG" },
	{ (LONG64)ns2__TaskType__TASK_USCOREVIDEO_USCORESTORE, "TASK_VIDEO_STORE" },
	{ (LONG64)ns2__TaskType__TASK_USCORESET_USCOREDATE_USCORETIME, "TASK_SET_DATE_TIME" },
	{ (LONG64)ns2__TaskType__TASK_USCORECURRENT_USCOREOBJECT_USCORELIST, "TASK_CURRENT_OBJECT_LIST" },
	{ (LONG64)ns2__TaskType__TASK_USCOREHISTORIC_USCOREOBJECT_USCORELIST, "TASK_HISTORIC_OBJECT_LIST" },
	{ (LONG64)ns2__TaskType__TASK_USCOREALIVE, "TASK_ALIVE" },
	{ (LONG64)ns2__TaskType__TASK_USCOREREBOOT_USCORENOW, "TASK_REBOOT_NOW" },
	{ (LONG64)ns2__TaskType__TASK_USCORECLEAR_USCOREZONE, "TASK_CLEAR_ZONE" },
	{ (LONG64)ns2__TaskType__TASK_USCORECOUNT_USCORECHANNELS, "TASK_COUNT_CHANNELS" },
	{ (LONG64)ns2__TaskType__TASK_USCOREZONE_USCORECHANNELS, "TASK_ZONE_CHANNELS" },
	{ (LONG64)ns2__TaskType__TASK_USCOREFEATURES_USCOREINFO, "TASK_FEATURES_INFO" },
	{ (LONG64)ns2__TaskType__TASK_USCOREDELETE_USCOREALL_USCORETASKS, "TASK_DELETE_ALL_TASKS" },
	{ (LONG64)ns2__TaskType__TASK_USCOREDELETE_USCOREALL_USCORENOTIFICATIONS, "TASK_DELETE_ALL_NOTIFICATIONS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__TaskType2s(struct soap *soap, enum ns2__TaskType n)
{	const char *s = soap_code_str(soap_codes_ns2__TaskType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskType(struct soap *soap, const char *tag, int id, const enum ns2__TaskType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskType), type) || soap_send(soap, soap_ns2__TaskType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__TaskType(struct soap *soap, const char *s, enum ns2__TaskType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__TaskType, s);
	if (map)
		*a = (enum ns2__TaskType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 22)
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__TaskType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__TaskType * SOAP_FMAC4 soap_in_ns2__TaskType(struct soap *soap, const char *tag, enum ns2__TaskType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__TaskType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskType, sizeof(enum ns2__TaskType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns2__TaskType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__TaskType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskType, SOAP_TYPE_ns2__TaskType, sizeof(enum ns2__TaskType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TaskType(struct soap *soap, const enum ns2__TaskType *a, const char *tag, const char *type)
{
	if (soap_out_ns2__TaskType(soap, tag ? tag : "ns2:TaskType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__TaskType * SOAP_FMAC4 soap_get_ns2__TaskType(struct soap *soap, enum ns2__TaskType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void __ns2__union_TaskContainer::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns2__union_TaskContainer::__union_TaskContainer = -1;
}

void __ns2__union_TaskContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns2__union_TaskContainer(soap, this->__ns2__union_TaskContainer::__union_TaskContainer, &this->__ns2__union_TaskContainer::union_TaskContainer);
#endif
}

int __ns2__union_TaskContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__union_TaskContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_TaskContainer(struct soap *soap, const char *tag, int id, const __ns2__union_TaskContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__ns2__union_TaskContainer(soap, a->__ns2__union_TaskContainer::__union_TaskContainer, &a->__ns2__union_TaskContainer::union_TaskContainer))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_TaskContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__union_TaskContainer(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__union_TaskContainer * SOAP_FMAC4 soap_in___ns2__union_TaskContainer(struct soap *soap, const char *tag, __ns2__union_TaskContainer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (__ns2__union_TaskContainer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__union_TaskContainer, sizeof(__ns2__union_TaskContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
		if (!soap_in__ns2__union_TaskContainer(soap, &a->__union_TaskContainer, &a->union_TaskContainer))
			return NULL;
	return a;
}

SOAP_FMAC1 __ns2__union_TaskContainer * SOAP_FMAC2 soap_instantiate___ns2__union_TaskContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__union_TaskContainer(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	__ns2__union_TaskContainer *p;
	size_t k = sizeof(__ns2__union_TaskContainer);
	if (n < 0)
	{	p = SOAP_NEW(__ns2__union_TaskContainer);
	}
	else
	{	p = SOAP_NEW_ARRAY(__ns2__union_TaskContainer, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated __ns2__union_TaskContainer location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns2__union_TaskContainer, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int __ns2__union_TaskContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out___ns2__union_TaskContainer(soap, tag ? tag : "-ns2:union-TaskContainer", -2, this, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_TaskContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__union_TaskContainer(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__union_TaskContainer * SOAP_FMAC4 soap_get___ns2__union_TaskContainer(struct soap *soap, __ns2__union_TaskContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_TaskContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ShortDuration(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ShortDuration(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ShortDuration(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__ShortDuration), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_ns2__ShortDuration(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__ShortDuration, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, "[0-9]+\\.[0-9]+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__ShortDuration, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns2__ShortDuration, SOAP_TYPE_ns2__ShortDuration, sizeof(std::wstring), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ShortDuration(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	if (soap_out_ns2__ShortDuration(soap, tag ? tag : "ns2:ShortDuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_ns2__ShortDuration(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ShortDuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ObjectClassName(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ObjectClassName(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ObjectClassName(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__ObjectClassName), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_ns2__ObjectClassName(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__ObjectClassName, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, "^[a-zA-Z]+$")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__ObjectClassName, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns2__ObjectClassName, SOAP_TYPE_ns2__ObjectClassName, sizeof(std::wstring), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ObjectClassName(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	if (soap_out_ns2__ObjectClassName(soap, tag ? tag : "ns2:ObjectClassName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_ns2__ObjectClassName(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ObjectClassName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MeasuringChannelName(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MeasuringChannelName(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MeasuringChannelName(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__MeasuringChannelName), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_ns2__MeasuringChannelName(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__MeasuringChannelName, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, "^[a-zA-Z0-9_\\-]+$")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__MeasuringChannelName, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns2__MeasuringChannelName, SOAP_TYPE_ns2__MeasuringChannelName, sizeof(std::wstring), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MeasuringChannelName(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	if (soap_out_ns2__MeasuringChannelName(soap, tag ? tag : "ns2:MeasuringChannelName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_ns2__MeasuringChannelName(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MeasuringChannelName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MAC_USCOREAddress(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MAC_USCOREAddress(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MAC_USCOREAddress(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__MAC_USCOREAddress), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_ns2__MAC_USCOREAddress(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__MAC_USCOREAddress, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, "[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__MAC_USCOREAddress, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns2__MAC_USCOREAddress, SOAP_TYPE_ns2__MAC_USCOREAddress, sizeof(std::wstring), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MAC_USCOREAddress(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	if (soap_out_ns2__MAC_USCOREAddress(soap, tag ? tag : "ns2:MAC_Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_ns2__MAC_USCOREAddress(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MAC_USCOREAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IP_USCOREAddress(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__IP_USCOREAddress(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IP_USCOREAddress(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns2__IP_USCOREAddress), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_ns2__IP_USCOREAddress(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__IP_USCOREAddress, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:([0-9]|[1-9][0-9]{1,4}))?$")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_ns2__IP_USCOREAddress, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_ns2__IP_USCOREAddress, SOAP_TYPE_ns2__IP_USCOREAddress, sizeof(std::wstring), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IP_USCOREAddress(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	if (soap_out_ns2__IP_USCOREAddress(soap, tag ? tag : "ns2:IP_Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_ns2__IP_USCOREAddress(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IP_USCOREAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ErrorContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ExtendedNotificationBase::soap_default(soap);
	soap_default_ns2__SOAP_USCOREDeviceError(soap, &this->ns2__ErrorContainer::error_USCOREreason);
	this->ns2__ErrorContainer::error_USCOREtext = NULL;
}

void ns2__ErrorContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__ExtendedNotificationBase::soap_serialize(soap);
#endif
}

int ns2__ErrorContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ErrorContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ErrorContainer(struct soap *soap, const char *tag, int id, const ns2__ErrorContainer *a, const char *type)
{
	soap_set_attr(soap, "error_reason", soap_ns2__SOAP_USCOREDeviceError2s(soap, ((ns2__ErrorContainer*)a)->error_USCOREreason), 1);
	if (((ns2__ErrorContainer*)a)->error_USCOREtext)
		soap_set_attr(soap, "error_text", soap_wstring2s(soap, ((ns2__ErrorContainer*)a)->error_USCOREtext), 2);
	soap_set_attr(soap, "ip_address", soap_ns2__IP_USCOREAddress2s(soap, ((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress), 2);
	soap_set_attr(soap, "firmware_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion), 2);
	soap_set_attr(soap, "customer_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion), 2);
	if (((ns2__ExtendedNotificationBase*)a)->version)
		soap_set_attr(soap, "version", soap_xsd__decimal2s(soap, *((ns2__ExtendedNotificationBase*)a)->version), 2);
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ErrorContainer), type ? type : "ns2:ErrorContainer"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ErrorContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ErrorContainer(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ErrorContainer * SOAP_FMAC4 soap_in_ns2__ErrorContainer(struct soap *soap, const char *tag, ns2__ErrorContainer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ErrorContainer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ErrorContainer, sizeof(ns2__ErrorContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ErrorContainer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ErrorContainer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__SOAP_USCOREDeviceError(soap, soap_attr_value(soap, "error_reason", 1), &((ns2__ErrorContainer*)a)->error_USCOREreason))
		return NULL;
	if (soap_s2wstring(soap, soap_attr_value(soap, "error_text", 0), &((ns2__ErrorContainer*)a)->error_USCOREtext))
		return NULL;
	if (soap_s2ns2__IP_USCOREAddress(soap, soap_attr_value(soap, "ip_address", 1), &((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "firmware_version", 1), &((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_version", 1), &((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion))
		return NULL;
	{	const char *t = soap_attr_value(soap, "version", 0);
		if (t)
		{
			if (!(((ns2__ExtendedNotificationBase*)a)->version = soap_new_xsd__decimal(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__decimal(soap, t, ((ns2__ExtendedNotificationBase*)a)->version))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ErrorContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ErrorContainer, SOAP_TYPE_ns2__ErrorContainer, sizeof(ns2__ErrorContainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ErrorContainer * SOAP_FMAC2 soap_instantiate_ns2__ErrorContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ErrorContainer(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ErrorContainer *p;
	size_t k = sizeof(ns2__ErrorContainer);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ErrorContainer);
		if (p)
			((ns2__ErrorContainer*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ErrorContainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ErrorContainer*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ErrorContainer location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ErrorContainer, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ErrorContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ErrorContainer(soap, tag ? tag : "ns2:ErrorContainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ErrorContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ErrorContainer(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ErrorContainer * SOAP_FMAC4 soap_get_ns2__ErrorContainer(struct soap *soap, ns2__ErrorContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ErrorContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AnswerContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskContainer::soap_default(soap);
	soap_default_unsignedInt(soap, &this->ns2__AnswerContainer::referenced_USCOREnotification_USCOREID);
	soap_default_ns2__SOAP_USCOREServerError(soap, &this->ns2__AnswerContainer::server_USCOREresponse_USCOREtype);
	this->ns2__AnswerContainer::version = NULL;
}

void ns2__AnswerContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskContainer::soap_serialize(soap);
#endif
}

int ns2__AnswerContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AnswerContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AnswerContainer(struct soap *soap, const char *tag, int id, const ns2__AnswerContainer *a, const char *type)
{
	soap_set_attr(soap, "referenced_notification_ID", soap_unsignedInt2s(soap, ((ns2__AnswerContainer*)a)->referenced_USCOREnotification_USCOREID), 1);
	soap_set_attr(soap, "server_response_type", soap_ns2__SOAP_USCOREServerError2s(soap, ((ns2__AnswerContainer*)a)->server_USCOREresponse_USCOREtype), 1);
	if (((ns2__AnswerContainer*)a)->version)
		soap_set_attr(soap, "version", soap_xsd__decimal2s(soap, *((ns2__AnswerContainer*)a)->version), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AnswerContainer), type ? type : "ns2:AnswerContainer"))
		return soap->error;
	soap_element_result(soap, "-size-TaskContainer");
	if (a->ns2__TaskContainer::__union_TaskContainer)
	{	int i;
		for (i = 0; i < (int)a->ns2__TaskContainer::__size_TaskContainer; i++)
			if (a->ns2__TaskContainer::__union_TaskContainer[i].soap_out(soap, "-union-TaskContainer", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__AnswerContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AnswerContainer(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AnswerContainer * SOAP_FMAC4 soap_in_ns2__AnswerContainer(struct soap *soap, const char *tag, ns2__AnswerContainer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AnswerContainer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AnswerContainer, sizeof(ns2__AnswerContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AnswerContainer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AnswerContainer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "referenced_notification_ID", 1), &((ns2__AnswerContainer*)a)->referenced_USCOREnotification_USCOREID))
		return NULL;
	if (soap_s2ns2__SOAP_USCOREServerError(soap, soap_attr_value(soap, "server_response_type", 1), &((ns2__AnswerContainer*)a)->server_USCOREresponse_USCOREtype))
		return NULL;
	{	const char *t = soap_attr_value(soap, "version", 0);
		if (t)
		{
			if (!(((ns2__AnswerContainer*)a)->version = soap_new_xsd__decimal(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__decimal(soap, t, ((ns2__AnswerContainer*)a)->version))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist___union_TaskContainer2 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns2__TaskContainer::__union_TaskContainer == NULL)
				{	if (soap_blist___union_TaskContainer2 == NULL)
						soap_blist___union_TaskContainer2 = soap_new_block(soap);
					a->ns2__TaskContainer::__union_TaskContainer = soap_block<__ns2__union_TaskContainer>::push(soap, soap_blist___union_TaskContainer2);
					if (a->ns2__TaskContainer::__union_TaskContainer == NULL)
						return NULL;
					a->ns2__TaskContainer::__union_TaskContainer->soap_default(soap);
				}
				if (soap_in___ns2__union_TaskContainer(soap, "-union-TaskContainer", a->ns2__TaskContainer::__union_TaskContainer, "-ns2:union-TaskContainer"))
				{	a->ns2__TaskContainer::__size_TaskContainer++;
					a->ns2__TaskContainer::__union_TaskContainer = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size-TaskContainer");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__TaskContainer::__union_TaskContainer)
			soap_block<__ns2__union_TaskContainer>::pop(soap, soap_blist___union_TaskContainer2);
		if (a->ns2__TaskContainer::__size_TaskContainer)
		{	a->ns2__TaskContainer::__union_TaskContainer = soap_new___ns2__union_TaskContainer(soap, a->ns2__TaskContainer::__size_TaskContainer);
			if (!a->ns2__TaskContainer::__union_TaskContainer)
				return NULL;
			soap_block<__ns2__union_TaskContainer>::save(soap, soap_blist___union_TaskContainer2, a->ns2__TaskContainer::__union_TaskContainer);
		}
		else
		{	a->ns2__TaskContainer::__union_TaskContainer = NULL;
			if (soap_blist___union_TaskContainer2)
				soap_block<__ns2__union_TaskContainer>::end(soap, soap_blist___union_TaskContainer2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AnswerContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AnswerContainer, SOAP_TYPE_ns2__AnswerContainer, sizeof(ns2__AnswerContainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AnswerContainer * SOAP_FMAC2 soap_instantiate_ns2__AnswerContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AnswerContainer(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AnswerContainer *p;
	size_t k = sizeof(ns2__AnswerContainer);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AnswerContainer);
		if (p)
			((ns2__AnswerContainer*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AnswerContainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AnswerContainer*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AnswerContainer location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AnswerContainer, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AnswerContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__AnswerContainer(soap, tag ? tag : "ns2:AnswerContainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AnswerContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AnswerContainer(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AnswerContainer * SOAP_FMAC4 soap_get_ns2__AnswerContainer(struct soap *soap, ns2__AnswerContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AnswerContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskContainer::__size_TaskContainer = 0;
	this->ns2__TaskContainer::__union_TaskContainer = NULL;
	/* transient soap skipped */
}

void ns2__TaskContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__TaskContainer::__union_TaskContainer)
	{	int i;
		for (i = 0; i < (int)this->ns2__TaskContainer::__size_TaskContainer; i++)
		{
			this->ns2__TaskContainer::__union_TaskContainer[i].soap_serialize(soap);
		}
	}
#endif
}

int ns2__TaskContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskContainer(struct soap *soap, const char *tag, int id, const ns2__TaskContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskContainer), type))
		return soap->error;
	soap_element_result(soap, "-size-TaskContainer");
	if (a->ns2__TaskContainer::__union_TaskContainer)
	{	int i;
		for (i = 0; i < (int)a->ns2__TaskContainer::__size_TaskContainer; i++)
			if (a->ns2__TaskContainer::__union_TaskContainer[i].soap_out(soap, "-union-TaskContainer", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskContainer(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskContainer * SOAP_FMAC4 soap_in_ns2__TaskContainer(struct soap *soap, const char *tag, ns2__TaskContainer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskContainer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskContainer, sizeof(ns2__TaskContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskContainer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskContainer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist___union_TaskContainer1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns2__TaskContainer::__union_TaskContainer == NULL)
				{	if (soap_blist___union_TaskContainer1 == NULL)
						soap_blist___union_TaskContainer1 = soap_new_block(soap);
					a->ns2__TaskContainer::__union_TaskContainer = soap_block<__ns2__union_TaskContainer>::push(soap, soap_blist___union_TaskContainer1);
					if (a->ns2__TaskContainer::__union_TaskContainer == NULL)
						return NULL;
					a->ns2__TaskContainer::__union_TaskContainer->soap_default(soap);
				}
				if (soap_in___ns2__union_TaskContainer(soap, "-union-TaskContainer", a->ns2__TaskContainer::__union_TaskContainer, "-ns2:union-TaskContainer"))
				{	a->ns2__TaskContainer::__size_TaskContainer++;
					a->ns2__TaskContainer::__union_TaskContainer = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size-TaskContainer");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__TaskContainer::__union_TaskContainer)
			soap_block<__ns2__union_TaskContainer>::pop(soap, soap_blist___union_TaskContainer1);
		if (a->ns2__TaskContainer::__size_TaskContainer)
		{	a->ns2__TaskContainer::__union_TaskContainer = soap_new___ns2__union_TaskContainer(soap, a->ns2__TaskContainer::__size_TaskContainer);
			if (!a->ns2__TaskContainer::__union_TaskContainer)
				return NULL;
			soap_block<__ns2__union_TaskContainer>::save(soap, soap_blist___union_TaskContainer1, a->ns2__TaskContainer::__union_TaskContainer);
		}
		else
		{	a->ns2__TaskContainer::__union_TaskContainer = NULL;
			if (soap_blist___union_TaskContainer1)
				soap_block<__ns2__union_TaskContainer>::end(soap, soap_blist___union_TaskContainer1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TaskContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskContainer, SOAP_TYPE_ns2__TaskContainer, sizeof(ns2__TaskContainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskContainer * SOAP_FMAC2 soap_instantiate_ns2__TaskContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskContainer(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:AnswerContainer"))
		return soap_instantiate_ns2__AnswerContainer(soap, n, NULL, NULL, size);
	ns2__TaskContainer *p;
	size_t k = sizeof(ns2__TaskContainer);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskContainer);
		if (p)
			((ns2__TaskContainer*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskContainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskContainer*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskContainer location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskContainer, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskContainer(soap, tag ? tag : "ns2:TaskContainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskContainer(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskContainer * SOAP_FMAC4 soap_get_ns2__TaskContainer(struct soap *soap, ns2__TaskContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskDeleteAllNotifications::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Task::soap_default(soap);
}

void ns2__TaskDeleteAllNotifications::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__Task::soap_serialize(soap);
#endif
}

int ns2__TaskDeleteAllNotifications::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskDeleteAllNotifications(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskDeleteAllNotifications(struct soap *soap, const char *tag, int id, const ns2__TaskDeleteAllNotifications *a, const char *type)
{
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskDeleteAllNotifications), type ? type : "ns2:TaskDeleteAllNotifications"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskDeleteAllNotifications::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskDeleteAllNotifications(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskDeleteAllNotifications * SOAP_FMAC4 soap_in_ns2__TaskDeleteAllNotifications(struct soap *soap, const char *tag, ns2__TaskDeleteAllNotifications *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskDeleteAllNotifications *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskDeleteAllNotifications, sizeof(ns2__TaskDeleteAllNotifications), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskDeleteAllNotifications)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskDeleteAllNotifications *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TaskDeleteAllNotifications *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskDeleteAllNotifications, SOAP_TYPE_ns2__TaskDeleteAllNotifications, sizeof(ns2__TaskDeleteAllNotifications), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskDeleteAllNotifications * SOAP_FMAC2 soap_instantiate_ns2__TaskDeleteAllNotifications(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskDeleteAllNotifications(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskDeleteAllNotifications *p;
	size_t k = sizeof(ns2__TaskDeleteAllNotifications);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskDeleteAllNotifications);
		if (p)
			((ns2__TaskDeleteAllNotifications*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskDeleteAllNotifications, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskDeleteAllNotifications*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskDeleteAllNotifications location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskDeleteAllNotifications, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskDeleteAllNotifications::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskDeleteAllNotifications(soap, tag ? tag : "ns2:TaskDeleteAllNotifications", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskDeleteAllNotifications::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskDeleteAllNotifications(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskDeleteAllNotifications * SOAP_FMAC4 soap_get_ns2__TaskDeleteAllNotifications(struct soap *soap, ns2__TaskDeleteAllNotifications *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskDeleteAllNotifications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskDeleteAllTasks::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Task::soap_default(soap);
}

void ns2__TaskDeleteAllTasks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__Task::soap_serialize(soap);
#endif
}

int ns2__TaskDeleteAllTasks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskDeleteAllTasks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskDeleteAllTasks(struct soap *soap, const char *tag, int id, const ns2__TaskDeleteAllTasks *a, const char *type)
{
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskDeleteAllTasks), type ? type : "ns2:TaskDeleteAllTasks"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskDeleteAllTasks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskDeleteAllTasks(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskDeleteAllTasks * SOAP_FMAC4 soap_in_ns2__TaskDeleteAllTasks(struct soap *soap, const char *tag, ns2__TaskDeleteAllTasks *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskDeleteAllTasks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskDeleteAllTasks, sizeof(ns2__TaskDeleteAllTasks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskDeleteAllTasks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskDeleteAllTasks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TaskDeleteAllTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskDeleteAllTasks, SOAP_TYPE_ns2__TaskDeleteAllTasks, sizeof(ns2__TaskDeleteAllTasks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskDeleteAllTasks * SOAP_FMAC2 soap_instantiate_ns2__TaskDeleteAllTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskDeleteAllTasks(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskDeleteAllTasks *p;
	size_t k = sizeof(ns2__TaskDeleteAllTasks);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskDeleteAllTasks);
		if (p)
			((ns2__TaskDeleteAllTasks*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskDeleteAllTasks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskDeleteAllTasks*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskDeleteAllTasks location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskDeleteAllTasks, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskDeleteAllTasks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskDeleteAllTasks(soap, tag ? tag : "ns2:TaskDeleteAllTasks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskDeleteAllTasks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskDeleteAllTasks(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskDeleteAllTasks * SOAP_FMAC4 soap_get_ns2__TaskDeleteAllTasks(struct soap *soap, ns2__TaskDeleteAllTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskDeleteAllTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeFeaturesInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggered::soap_default(soap);
}

void ns2__TaskSubscribeFeaturesInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggered::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeFeaturesInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeFeaturesInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeFeaturesInfo(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeFeaturesInfo *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo), type ? type : "ns2:TaskSubscribeFeaturesInfo"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeFeaturesInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeFeaturesInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeFeaturesInfo * SOAP_FMAC4 soap_in_ns2__TaskSubscribeFeaturesInfo(struct soap *soap, const char *tag, ns2__TaskSubscribeFeaturesInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeFeaturesInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo, sizeof(ns2__TaskSubscribeFeaturesInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeFeaturesInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeFeaturesInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo, SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo, sizeof(ns2__TaskSubscribeFeaturesInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeFeaturesInfo * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeFeaturesInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeFeaturesInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeFeaturesInfo *p;
	size_t k = sizeof(ns2__TaskSubscribeFeaturesInfo);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeFeaturesInfo);
		if (p)
			((ns2__TaskSubscribeFeaturesInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeFeaturesInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeFeaturesInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeFeaturesInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeFeaturesInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeFeaturesInfo(soap, tag ? tag : "ns2:TaskSubscribeFeaturesInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeFeaturesInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeFeaturesInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeFeaturesInfo * SOAP_FMAC4 soap_get_ns2__TaskSubscribeFeaturesInfo(struct soap *soap, ns2__TaskSubscribeFeaturesInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeFeaturesInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeObjectList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggered::soap_default(soap);
	soap_default_ns2__TransferType(soap, &this->ns2__TaskSubscribeObjectList::transfer_USCOREtype);
}

void ns2__TaskSubscribeObjectList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggered::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeObjectList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeObjectList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeObjectList(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeObjectList *a, const char *type)
{
	soap_set_attr(soap, "transfer_type", soap_ns2__TransferType2s(soap, ((ns2__TaskSubscribeObjectList*)a)->transfer_USCOREtype), 1);
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeObjectList), type ? type : "ns2:TaskSubscribeObjectList"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeObjectList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeObjectList(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeObjectList * SOAP_FMAC4 soap_in_ns2__TaskSubscribeObjectList(struct soap *soap, const char *tag, ns2__TaskSubscribeObjectList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeObjectList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeObjectList, sizeof(ns2__TaskSubscribeObjectList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeObjectList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeObjectList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__TransferType(soap, soap_attr_value(soap, "transfer_type", 1), &((ns2__TaskSubscribeObjectList*)a)->transfer_USCOREtype))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeObjectList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeObjectList, SOAP_TYPE_ns2__TaskSubscribeObjectList, sizeof(ns2__TaskSubscribeObjectList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeObjectList * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeObjectList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeObjectList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeObjectList *p;
	size_t k = sizeof(ns2__TaskSubscribeObjectList);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeObjectList);
		if (p)
			((ns2__TaskSubscribeObjectList*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeObjectList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeObjectList*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeObjectList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeObjectList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeObjectList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeObjectList(soap, tag ? tag : "ns2:TaskSubscribeObjectList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeObjectList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeObjectList(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeObjectList * SOAP_FMAC4 soap_get_ns2__TaskSubscribeObjectList(struct soap *soap, ns2__TaskSubscribeObjectList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeObjectList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeAlive::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggered::soap_default(soap);
}

void ns2__TaskSubscribeAlive::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggered::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeAlive::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeAlive(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeAlive(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeAlive *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeAlive), type ? type : "ns2:TaskSubscribeAlive"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeAlive::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeAlive(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeAlive * SOAP_FMAC4 soap_in_ns2__TaskSubscribeAlive(struct soap *soap, const char *tag, ns2__TaskSubscribeAlive *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeAlive *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeAlive, sizeof(ns2__TaskSubscribeAlive), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeAlive)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeAlive *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeAlive *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeAlive, SOAP_TYPE_ns2__TaskSubscribeAlive, sizeof(ns2__TaskSubscribeAlive), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeAlive * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeAlive(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeAlive(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeAlive *p;
	size_t k = sizeof(ns2__TaskSubscribeAlive);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeAlive);
		if (p)
			((ns2__TaskSubscribeAlive*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeAlive, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeAlive*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeAlive location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeAlive, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeAlive::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeAlive(soap, tag ? tag : "ns2:TaskSubscribeAlive", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeAlive::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeAlive(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeAlive * SOAP_FMAC4 soap_get_ns2__TaskSubscribeAlive(struct soap *soap, ns2__TaskSubscribeAlive *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeAlive(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeVideoStore::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggered::soap_default(soap);
}

void ns2__TaskSubscribeVideoStore::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggered::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeVideoStore::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeVideoStore(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeVideoStore(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeVideoStore *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeVideoStore), type ? type : "ns2:TaskSubscribeVideoStore"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeVideoStore::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeVideoStore(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeVideoStore * SOAP_FMAC4 soap_in_ns2__TaskSubscribeVideoStore(struct soap *soap, const char *tag, ns2__TaskSubscribeVideoStore *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeVideoStore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeVideoStore, sizeof(ns2__TaskSubscribeVideoStore), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeVideoStore)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeVideoStore *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeVideoStore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeVideoStore, SOAP_TYPE_ns2__TaskSubscribeVideoStore, sizeof(ns2__TaskSubscribeVideoStore), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeVideoStore * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeVideoStore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeVideoStore(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeVideoStore *p;
	size_t k = sizeof(ns2__TaskSubscribeVideoStore);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeVideoStore);
		if (p)
			((ns2__TaskSubscribeVideoStore*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeVideoStore, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeVideoStore*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeVideoStore location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeVideoStore, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeVideoStore::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeVideoStore(soap, tag ? tag : "ns2:TaskSubscribeVideoStore", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeVideoStore::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeVideoStore(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeVideoStore * SOAP_FMAC4 soap_get_ns2__TaskSubscribeVideoStore(struct soap *soap, ns2__TaskSubscribeVideoStore *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeVideoStore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeSendParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggered::soap_default(soap);
}

void ns2__TaskSubscribeSendParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggered::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeSendParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeSendParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeSendParameters(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeSendParameters *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeSendParameters), type ? type : "ns2:TaskSubscribeSendParameters"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeSendParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeSendParameters(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeSendParameters * SOAP_FMAC4 soap_in_ns2__TaskSubscribeSendParameters(struct soap *soap, const char *tag, ns2__TaskSubscribeSendParameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeSendParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeSendParameters, sizeof(ns2__TaskSubscribeSendParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeSendParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeSendParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeSendParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeSendParameters, SOAP_TYPE_ns2__TaskSubscribeSendParameters, sizeof(ns2__TaskSubscribeSendParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeSendParameters * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeSendParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeSendParameters(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeSendParameters *p;
	size_t k = sizeof(ns2__TaskSubscribeSendParameters);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeSendParameters);
		if (p)
			((ns2__TaskSubscribeSendParameters*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeSendParameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeSendParameters*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeSendParameters location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeSendParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeSendParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeSendParameters(soap, tag ? tag : "ns2:TaskSubscribeSendParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeSendParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeSendParameters(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeSendParameters * SOAP_FMAC4 soap_get_ns2__TaskSubscribeSendParameters(struct soap *soap, ns2__TaskSubscribeSendParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeSendParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeCameraImages::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggered::soap_default(soap);
}

void ns2__TaskSubscribeCameraImages::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggered::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeCameraImages::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeCameraImages(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeCameraImages(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeCameraImages *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeCameraImages), type ? type : "ns2:TaskSubscribeCameraImages"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeCameraImages::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeCameraImages(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeCameraImages * SOAP_FMAC4 soap_in_ns2__TaskSubscribeCameraImages(struct soap *soap, const char *tag, ns2__TaskSubscribeCameraImages *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeCameraImages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeCameraImages, sizeof(ns2__TaskSubscribeCameraImages), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeCameraImages)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeCameraImages *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeCameraImages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeCameraImages, SOAP_TYPE_ns2__TaskSubscribeCameraImages, sizeof(ns2__TaskSubscribeCameraImages), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeCameraImages * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeCameraImages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeCameraImages(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeCameraImages *p;
	size_t k = sizeof(ns2__TaskSubscribeCameraImages);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeCameraImages);
		if (p)
			((ns2__TaskSubscribeCameraImages*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeCameraImages, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeCameraImages*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeCameraImages location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeCameraImages, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeCameraImages::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeCameraImages(soap, tag ? tag : "ns2:TaskSubscribeCameraImages", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeCameraImages::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeCameraImages(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeCameraImages * SOAP_FMAC4 soap_get_ns2__TaskSubscribeCameraImages(struct soap *soap, ns2__TaskSubscribeCameraImages *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeCameraImages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeErrorLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggered::soap_default(soap);
}

void ns2__TaskSubscribeErrorLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggered::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeErrorLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeErrorLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeErrorLog(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeErrorLog *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeErrorLog), type ? type : "ns2:TaskSubscribeErrorLog"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeErrorLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeErrorLog(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeErrorLog * SOAP_FMAC4 soap_in_ns2__TaskSubscribeErrorLog(struct soap *soap, const char *tag, ns2__TaskSubscribeErrorLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeErrorLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeErrorLog, sizeof(ns2__TaskSubscribeErrorLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeErrorLog)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeErrorLog *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeErrorLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeErrorLog, SOAP_TYPE_ns2__TaskSubscribeErrorLog, sizeof(ns2__TaskSubscribeErrorLog), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeErrorLog * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeErrorLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeErrorLog(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeErrorLog *p;
	size_t k = sizeof(ns2__TaskSubscribeErrorLog);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeErrorLog);
		if (p)
			((ns2__TaskSubscribeErrorLog*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeErrorLog, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeErrorLog*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeErrorLog location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeErrorLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeErrorLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeErrorLog(soap, tag ? tag : "ns2:TaskSubscribeErrorLog", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeErrorLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeErrorLog(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeErrorLog * SOAP_FMAC4 soap_get_ns2__TaskSubscribeErrorLog(struct soap *soap, ns2__TaskSubscribeErrorLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeErrorLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeLogfiles::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggered::soap_default(soap);
}

void ns2__TaskSubscribeLogfiles::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggered::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeLogfiles::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeLogfiles(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeLogfiles(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeLogfiles *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeLogfiles), type ? type : "ns2:TaskSubscribeLogfiles"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeLogfiles::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeLogfiles(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeLogfiles * SOAP_FMAC4 soap_in_ns2__TaskSubscribeLogfiles(struct soap *soap, const char *tag, ns2__TaskSubscribeLogfiles *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeLogfiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeLogfiles, sizeof(ns2__TaskSubscribeLogfiles), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeLogfiles)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeLogfiles *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeLogfiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeLogfiles, SOAP_TYPE_ns2__TaskSubscribeLogfiles, sizeof(ns2__TaskSubscribeLogfiles), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeLogfiles * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeLogfiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeLogfiles(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeLogfiles *p;
	size_t k = sizeof(ns2__TaskSubscribeLogfiles);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeLogfiles);
		if (p)
			((ns2__TaskSubscribeLogfiles*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeLogfiles, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeLogfiles*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeLogfiles location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeLogfiles, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeLogfiles::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeLogfiles(soap, tag ? tag : "ns2:TaskSubscribeLogfiles", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeLogfiles::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeLogfiles(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeLogfiles * SOAP_FMAC4 soap_get_ns2__TaskSubscribeLogfiles(struct soap *soap, ns2__TaskSubscribeLogfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeLogfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeDigitalInput::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggeredSafe::soap_default(soap);
	this->ns2__TaskSubscribeDigitalInput::__sizedigital_USCOREinput_USCOREport = 0;
	this->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport = NULL;
}

void ns2__TaskSubscribeDigitalInput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport)
	{	int i;
		for (i = 0; i < (int)this->ns2__TaskSubscribeDigitalInput::__sizedigital_USCOREinput_USCOREport; i++)
		{
			soap_serialize_PointerTons2__DigitalInputControl(soap, this->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport + i);
		}
	}
	this->ns2__TaskSubscribeTriggeredSafe::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeDigitalInput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeDigitalInput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeDigitalInput(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeDigitalInput *a, const char *type)
{
	soap_set_attr(soap, "store_on_transmission_error", soap_bool2s(soap, ((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror), 1);
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeDigitalInput), type ? type : "ns2:TaskSubscribeDigitalInput"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	if (a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport)
	{	int i;
		for (i = 0; i < (int)a->ns2__TaskSubscribeDigitalInput::__sizedigital_USCOREinput_USCOREport; i++)
			if (soap_out_PointerTons2__DigitalInputControl(soap, "ns2:digital_input_port", -1, a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeDigitalInput::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeDigitalInput(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeDigitalInput * SOAP_FMAC4 soap_in_ns2__TaskSubscribeDigitalInput(struct soap *soap, const char *tag, ns2__TaskSubscribeDigitalInput *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeDigitalInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeDigitalInput, sizeof(ns2__TaskSubscribeDigitalInput), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeDigitalInput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeDigitalInput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "store_on_transmission_error", 0), &((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger3 = 1;
	struct soap_blist *soap_blist_digital_USCOREinput_USCOREport1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:digital_input_port", 1, NULL))
			{	if (a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport == NULL)
				{	if (soap_blist_digital_USCOREinput_USCOREport1 == NULL)
						soap_blist_digital_USCOREinput_USCOREport1 = soap_new_block(soap);
					a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport = (ns2__DigitalInputControl **)soap_push_block_max(soap, soap_blist_digital_USCOREinput_USCOREport1, sizeof(ns2__DigitalInputControl *));
					if (a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport == NULL)
						return NULL;
					*a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__DigitalInputControl(soap, "ns2:digital_input_port", a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport, "ns2:DigitalInputControl"))
				{	a->ns2__TaskSubscribeDigitalInput::__sizedigital_USCOREinput_USCOREport++;
					a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport)
			soap_pop_block(soap, soap_blist_digital_USCOREinput_USCOREport1);
		if (a->ns2__TaskSubscribeDigitalInput::__sizedigital_USCOREinput_USCOREport)
		{	a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport = (ns2__DigitalInputControl **)soap_save_block(soap, soap_blist_digital_USCOREinput_USCOREport1, NULL, 1);
		}
		else
		{	a->ns2__TaskSubscribeDigitalInput::digital_USCOREinput_USCOREport = NULL;
			if (soap_blist_digital_USCOREinput_USCOREport1)
				soap_end_block(soap, soap_blist_digital_USCOREinput_USCOREport1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger3 > 0 || a->ns2__TaskSubscribeDigitalInput::__sizedigital_USCOREinput_USCOREport < 1 || a->ns2__TaskSubscribeDigitalInput::__sizedigital_USCOREinput_USCOREport > 16))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeDigitalInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeDigitalInput, SOAP_TYPE_ns2__TaskSubscribeDigitalInput, sizeof(ns2__TaskSubscribeDigitalInput), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeDigitalInput * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeDigitalInput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeDigitalInput(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeDigitalInput *p;
	size_t k = sizeof(ns2__TaskSubscribeDigitalInput);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeDigitalInput);
		if (p)
			((ns2__TaskSubscribeDigitalInput*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeDigitalInput, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeDigitalInput*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeDigitalInput location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeDigitalInput, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeDigitalInput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeDigitalInput(soap, tag ? tag : "ns2:TaskSubscribeDigitalInput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeDigitalInput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeDigitalInput(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeDigitalInput * SOAP_FMAC4 soap_get_ns2__TaskSubscribeDigitalInput(struct soap *soap, ns2__TaskSubscribeDigitalInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeDigitalInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DigitalInputControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns2__DigitalInputControl::activity_USCOREstate);
	/* transient soap skipped */
}

void ns2__DigitalInputControl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__DigitalInputControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DigitalInputControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DigitalInputControl(struct soap *soap, const char *tag, int id, const ns2__DigitalInputControl *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__DigitalInputControl*)a)->activity_USCOREstate), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DigitalInputControl), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DigitalInputControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DigitalInputControl(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DigitalInputControl * SOAP_FMAC4 soap_in_ns2__DigitalInputControl(struct soap *soap, const char *tag, ns2__DigitalInputControl *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DigitalInputControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DigitalInputControl, sizeof(ns2__DigitalInputControl), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DigitalInputControl)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DigitalInputControl *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__DigitalInputControl*)a)->activity_USCOREstate))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DigitalInputControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DigitalInputControl, SOAP_TYPE_ns2__DigitalInputControl, sizeof(ns2__DigitalInputControl), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DigitalInputControl * SOAP_FMAC2 soap_instantiate_ns2__DigitalInputControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DigitalInputControl(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DigitalInputControl *p;
	size_t k = sizeof(ns2__DigitalInputControl);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DigitalInputControl);
		if (p)
			((ns2__DigitalInputControl*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DigitalInputControl, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DigitalInputControl*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DigitalInputControl location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DigitalInputControl, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DigitalInputControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__DigitalInputControl(soap, tag ? tag : "ns2:DigitalInputControl", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DigitalInputControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DigitalInputControl(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DigitalInputControl * SOAP_FMAC4 soap_get_ns2__DigitalInputControl(struct soap *soap, ns2__DigitalInputControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DigitalInputControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeClearZone::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggeredSafe::soap_default(soap);
	this->ns2__TaskSubscribeClearZone::clear_USCOREzone_USCOREid = NULL;
}

void ns2__TaskSubscribeClearZone::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__ClearZoneID(soap, &this->ns2__TaskSubscribeClearZone::clear_USCOREzone_USCOREid);
	this->ns2__TaskSubscribeTriggeredSafe::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeClearZone::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeClearZone(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeClearZone(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeClearZone *a, const char *type)
{
	soap_set_attr(soap, "store_on_transmission_error", soap_bool2s(soap, ((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror), 1);
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeClearZone), type ? type : "ns2:TaskSubscribeClearZone"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	if (!a->ns2__TaskSubscribeClearZone::clear_USCOREzone_USCOREid)
	{	if (soap_element_nil(soap, "ns2:clear_zone_id"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__ClearZoneID(soap, "ns2:clear_zone_id", -1, &a->ns2__TaskSubscribeClearZone::clear_USCOREzone_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeClearZone::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeClearZone(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeClearZone * SOAP_FMAC4 soap_in_ns2__TaskSubscribeClearZone(struct soap *soap, const char *tag, ns2__TaskSubscribeClearZone *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeClearZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeClearZone, sizeof(ns2__TaskSubscribeClearZone), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeClearZone)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeClearZone *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "store_on_transmission_error", 0), &((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger3 = 1;
	size_t soap_flag_clear_USCOREzone_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger3--;
					continue;
				}
			if (soap_flag_clear_USCOREzone_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ClearZoneID(soap, "ns2:clear_zone_id", &a->ns2__TaskSubscribeClearZone::clear_USCOREzone_USCOREid, "ns2:ClearZoneID"))
				{	soap_flag_clear_USCOREzone_USCOREid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger3 > 0 || soap_flag_clear_USCOREzone_USCOREid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeClearZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeClearZone, SOAP_TYPE_ns2__TaskSubscribeClearZone, sizeof(ns2__TaskSubscribeClearZone), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeClearZone * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeClearZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeClearZone(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeClearZone *p;
	size_t k = sizeof(ns2__TaskSubscribeClearZone);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeClearZone);
		if (p)
			((ns2__TaskSubscribeClearZone*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeClearZone, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeClearZone*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeClearZone location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeClearZone, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeClearZone::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeClearZone(soap, tag ? tag : "ns2:TaskSubscribeClearZone", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeClearZone::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeClearZone(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeClearZone * SOAP_FMAC4 soap_get_ns2__TaskSubscribeClearZone(struct soap *soap, ns2__TaskSubscribeClearZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeClearZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeFill::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggeredSafe::soap_default(soap);
	this->ns2__TaskSubscribeFill::fill_USCOREregion_USCOREid = NULL;
}

void ns2__TaskSubscribeFill::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__FillRegionID(soap, &this->ns2__TaskSubscribeFill::fill_USCOREregion_USCOREid);
	this->ns2__TaskSubscribeTriggeredSafe::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeFill::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeFill(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeFill(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeFill *a, const char *type)
{
	soap_set_attr(soap, "store_on_transmission_error", soap_bool2s(soap, ((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror), 1);
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeFill), type ? type : "ns2:TaskSubscribeFill"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	if (!a->ns2__TaskSubscribeFill::fill_USCOREregion_USCOREid)
	{	if (soap_element_nil(soap, "ns2:fill_region_id"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__FillRegionID(soap, "ns2:fill_region_id", -1, &a->ns2__TaskSubscribeFill::fill_USCOREregion_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeFill::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeFill(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeFill * SOAP_FMAC4 soap_in_ns2__TaskSubscribeFill(struct soap *soap, const char *tag, ns2__TaskSubscribeFill *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeFill *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeFill, sizeof(ns2__TaskSubscribeFill), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeFill)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeFill *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "store_on_transmission_error", 0), &((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger3 = 1;
	size_t soap_flag_fill_USCOREregion_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger3--;
					continue;
				}
			if (soap_flag_fill_USCOREregion_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FillRegionID(soap, "ns2:fill_region_id", &a->ns2__TaskSubscribeFill::fill_USCOREregion_USCOREid, "ns2:FillRegionID"))
				{	soap_flag_fill_USCOREregion_USCOREid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger3 > 0 || soap_flag_fill_USCOREregion_USCOREid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeFill *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeFill, SOAP_TYPE_ns2__TaskSubscribeFill, sizeof(ns2__TaskSubscribeFill), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeFill * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeFill(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeFill(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeFill *p;
	size_t k = sizeof(ns2__TaskSubscribeFill);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeFill);
		if (p)
			((ns2__TaskSubscribeFill*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeFill, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeFill*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeFill location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeFill, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeFill::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeFill(soap, tag ? tag : "ns2:TaskSubscribeFill", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeFill::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeFill(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeFill * SOAP_FMAC4 soap_get_ns2__TaskSubscribeFill(struct soap *soap, ns2__TaskSubscribeFill *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeFill(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeZoneChannels::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggeredSafe::soap_default(soap);
}

void ns2__TaskSubscribeZoneChannels::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggeredSafe::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeZoneChannels::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeZoneChannels(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeZoneChannels(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeZoneChannels *a, const char *type)
{
	soap_set_attr(soap, "store_on_transmission_error", soap_bool2s(soap, ((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror), 1);
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeZoneChannels), type ? type : "ns2:TaskSubscribeZoneChannels"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeZoneChannels::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeZoneChannels(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeZoneChannels * SOAP_FMAC4 soap_in_ns2__TaskSubscribeZoneChannels(struct soap *soap, const char *tag, ns2__TaskSubscribeZoneChannels *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeZoneChannels *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeZoneChannels, sizeof(ns2__TaskSubscribeZoneChannels), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeZoneChannels)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeZoneChannels *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "store_on_transmission_error", 0), &((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger3 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger3 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeZoneChannels *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeZoneChannels, SOAP_TYPE_ns2__TaskSubscribeZoneChannels, sizeof(ns2__TaskSubscribeZoneChannels), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeZoneChannels * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeZoneChannels(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeZoneChannels(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeZoneChannels *p;
	size_t k = sizeof(ns2__TaskSubscribeZoneChannels);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeZoneChannels);
		if (p)
			((ns2__TaskSubscribeZoneChannels*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeZoneChannels, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeZoneChannels*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeZoneChannels location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeZoneChannels, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeZoneChannels::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeZoneChannels(soap, tag ? tag : "ns2:TaskSubscribeZoneChannels", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeZoneChannels::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeZoneChannels(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeZoneChannels * SOAP_FMAC4 soap_get_ns2__TaskSubscribeZoneChannels(struct soap *soap, ns2__TaskSubscribeZoneChannels *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeZoneChannels(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeCountChannels::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggeredSafe::soap_default(soap);
}

void ns2__TaskSubscribeCountChannels::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggeredSafe::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeCountChannels::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeCountChannels(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeCountChannels(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeCountChannels *a, const char *type)
{
	soap_set_attr(soap, "store_on_transmission_error", soap_bool2s(soap, ((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror), 1);
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeCountChannels), type ? type : "ns2:TaskSubscribeCountChannels"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeCountChannels::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeCountChannels(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeCountChannels * SOAP_FMAC4 soap_in_ns2__TaskSubscribeCountChannels(struct soap *soap, const char *tag, ns2__TaskSubscribeCountChannels *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeCountChannels *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeCountChannels, sizeof(ns2__TaskSubscribeCountChannels), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeCountChannels)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeCountChannels *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "store_on_transmission_error", 0), &((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger3 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger3 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeCountChannels *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeCountChannels, SOAP_TYPE_ns2__TaskSubscribeCountChannels, sizeof(ns2__TaskSubscribeCountChannels), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeCountChannels * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeCountChannels(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeCountChannels(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeCountChannels *p;
	size_t k = sizeof(ns2__TaskSubscribeCountChannels);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeCountChannels);
		if (p)
			((ns2__TaskSubscribeCountChannels*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeCountChannels, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeCountChannels*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeCountChannels location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeCountChannels, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeCountChannels::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeCountChannels(soap, tag ? tag : "ns2:TaskSubscribeCountChannels", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeCountChannels::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeCountChannels(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeCountChannels * SOAP_FMAC4 soap_get_ns2__TaskSubscribeCountChannels(struct soap *soap, ns2__TaskSubscribeCountChannels *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeCountChannels(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeCounting::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggeredSafe::soap_default(soap);
	this->ns2__TaskSubscribeCounting::counting_USCOREgate_USCOREid = NULL;
}

void ns2__TaskSubscribeCounting::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__CountingGateID(soap, &this->ns2__TaskSubscribeCounting::counting_USCOREgate_USCOREid);
	this->ns2__TaskSubscribeTriggeredSafe::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeCounting::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeCounting(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeCounting(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeCounting *a, const char *type)
{
	soap_set_attr(soap, "store_on_transmission_error", soap_bool2s(soap, ((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror), 1);
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeCounting), type ? type : "ns2:TaskSubscribeCounting"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	if (!a->ns2__TaskSubscribeCounting::counting_USCOREgate_USCOREid)
	{	if (soap_element_nil(soap, "ns2:counting_gate_id"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__CountingGateID(soap, "ns2:counting_gate_id", -1, &a->ns2__TaskSubscribeCounting::counting_USCOREgate_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeCounting::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeCounting(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeCounting * SOAP_FMAC4 soap_in_ns2__TaskSubscribeCounting(struct soap *soap, const char *tag, ns2__TaskSubscribeCounting *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeCounting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeCounting, sizeof(ns2__TaskSubscribeCounting), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeCounting)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeCounting *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "store_on_transmission_error", 0), &((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger3 = 1;
	size_t soap_flag_counting_USCOREgate_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger3--;
					continue;
				}
			if (soap_flag_counting_USCOREgate_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CountingGateID(soap, "ns2:counting_gate_id", &a->ns2__TaskSubscribeCounting::counting_USCOREgate_USCOREid, "ns2:CountingGateID"))
				{	soap_flag_counting_USCOREgate_USCOREid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger3 > 0 || soap_flag_counting_USCOREgate_USCOREid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeCounting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeCounting, SOAP_TYPE_ns2__TaskSubscribeCounting, sizeof(ns2__TaskSubscribeCounting), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeCounting * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeCounting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeCounting(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSubscribeCounting *p;
	size_t k = sizeof(ns2__TaskSubscribeCounting);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeCounting);
		if (p)
			((ns2__TaskSubscribeCounting*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeCounting, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeCounting*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeCounting location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeCounting, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeCounting::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeCounting(soap, tag ? tag : "ns2:TaskSubscribeCounting", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeCounting::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeCounting(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeCounting * SOAP_FMAC4 soap_get_ns2__TaskSubscribeCounting(struct soap *soap, ns2__TaskSubscribeCounting *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeCounting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeTriggeredSafe::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskSubscribeTriggered::soap_default(soap);
	this->ns2__TaskSubscribeTriggeredSafe::store_USCOREon_USCOREtransmission_USCOREerror = (bool)0;
}

void ns2__TaskSubscribeTriggeredSafe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__TaskSubscribeTriggered::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeTriggeredSafe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeTriggeredSafe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeTriggeredSafe(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeTriggeredSafe *a, const char *type)
{
	soap_set_attr(soap, "store_on_transmission_error", soap_bool2s(soap, ((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror), 1);
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe), type ? type : "ns2:TaskSubscribeTriggeredSafe"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeTriggeredSafe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeTriggeredSafe(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeTriggeredSafe * SOAP_FMAC4 soap_in_ns2__TaskSubscribeTriggeredSafe(struct soap *soap, const char *tag, ns2__TaskSubscribeTriggeredSafe *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeTriggeredSafe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe, sizeof(ns2__TaskSubscribeTriggeredSafe), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeTriggeredSafe *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "store_on_transmission_error", 0), &((ns2__TaskSubscribeTriggeredSafe*)a)->store_USCOREon_USCOREtransmission_USCOREerror))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeTriggeredSafe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe, SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe, sizeof(ns2__TaskSubscribeTriggeredSafe), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeTriggeredSafe * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeTriggeredSafe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeTriggeredSafe(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCounting"))
		return soap_instantiate_ns2__TaskSubscribeCounting(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCountChannels"))
		return soap_instantiate_ns2__TaskSubscribeCountChannels(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeZoneChannels"))
		return soap_instantiate_ns2__TaskSubscribeZoneChannels(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeFill"))
		return soap_instantiate_ns2__TaskSubscribeFill(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeClearZone"))
		return soap_instantiate_ns2__TaskSubscribeClearZone(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeDigitalInput"))
		return soap_instantiate_ns2__TaskSubscribeDigitalInput(soap, n, NULL, NULL, size);
	ns2__TaskSubscribeTriggeredSafe *p;
	size_t k = sizeof(ns2__TaskSubscribeTriggeredSafe);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeTriggeredSafe);
		if (p)
			((ns2__TaskSubscribeTriggeredSafe*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeTriggeredSafe, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeTriggeredSafe*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeTriggeredSafe location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeTriggeredSafe, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeTriggeredSafe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeTriggeredSafe(soap, tag ? tag : "ns2:TaskSubscribeTriggeredSafe", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeTriggeredSafe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeTriggeredSafe(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeTriggeredSafe * SOAP_FMAC4 soap_get_ns2__TaskSubscribeTriggeredSafe(struct soap *soap, ns2__TaskSubscribeTriggeredSafe *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeTriggeredSafe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSubscribeTriggered::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskWithActivity::soap_default(soap);
	this->ns2__TaskSubscribeTriggered::trigger = NULL;
}

void ns2__TaskSubscribeTriggered::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Trigger(soap, &this->ns2__TaskSubscribeTriggered::trigger);
	this->ns2__TaskWithActivity::soap_serialize(soap);
#endif
}

int ns2__TaskSubscribeTriggered::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSubscribeTriggered(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSubscribeTriggered(struct soap *soap, const char *tag, int id, const ns2__TaskSubscribeTriggered *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSubscribeTriggered), type ? type : "ns2:TaskSubscribeTriggered"))
		return soap->error;
	if (!a->ns2__TaskSubscribeTriggered::trigger)
	{	if (soap_element_nil(soap, "ns2:trigger"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Trigger(soap, "ns2:trigger", -1, &a->ns2__TaskSubscribeTriggered::trigger, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSubscribeTriggered::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSubscribeTriggered(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSubscribeTriggered * SOAP_FMAC4 soap_in_ns2__TaskSubscribeTriggered(struct soap *soap, const char *tag, ns2__TaskSubscribeTriggered *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSubscribeTriggered *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSubscribeTriggered, sizeof(ns2__TaskSubscribeTriggered), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSubscribeTriggered)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSubscribeTriggered *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	size_t soap_flag_trigger1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trigger1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Trigger(soap, "ns2:trigger", &a->ns2__TaskSubscribeTriggered::trigger, "ns2:Trigger"))
				{	soap_flag_trigger1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_trigger1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSubscribeTriggered *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSubscribeTriggered, SOAP_TYPE_ns2__TaskSubscribeTriggered, sizeof(ns2__TaskSubscribeTriggered), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSubscribeTriggered * SOAP_FMAC2 soap_instantiate_ns2__TaskSubscribeTriggered(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSubscribeTriggered(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeTriggeredSafe"))
		return soap_instantiate_ns2__TaskSubscribeTriggeredSafe(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeLogfiles"))
		return soap_instantiate_ns2__TaskSubscribeLogfiles(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeErrorLog"))
		return soap_instantiate_ns2__TaskSubscribeErrorLog(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCameraImages"))
		return soap_instantiate_ns2__TaskSubscribeCameraImages(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeSendParameters"))
		return soap_instantiate_ns2__TaskSubscribeSendParameters(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeVideoStore"))
		return soap_instantiate_ns2__TaskSubscribeVideoStore(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeAlive"))
		return soap_instantiate_ns2__TaskSubscribeAlive(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeObjectList"))
		return soap_instantiate_ns2__TaskSubscribeObjectList(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeFeaturesInfo"))
		return soap_instantiate_ns2__TaskSubscribeFeaturesInfo(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCounting"))
		return soap_instantiate_ns2__TaskSubscribeCounting(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCountChannels"))
		return soap_instantiate_ns2__TaskSubscribeCountChannels(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeZoneChannels"))
		return soap_instantiate_ns2__TaskSubscribeZoneChannels(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeFill"))
		return soap_instantiate_ns2__TaskSubscribeFill(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeClearZone"))
		return soap_instantiate_ns2__TaskSubscribeClearZone(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeDigitalInput"))
		return soap_instantiate_ns2__TaskSubscribeDigitalInput(soap, n, NULL, NULL, size);
	ns2__TaskSubscribeTriggered *p;
	size_t k = sizeof(ns2__TaskSubscribeTriggered);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSubscribeTriggered);
		if (p)
			((ns2__TaskSubscribeTriggered*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSubscribeTriggered, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSubscribeTriggered*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSubscribeTriggered location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSubscribeTriggered, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSubscribeTriggered::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSubscribeTriggered(soap, tag ? tag : "ns2:TaskSubscribeTriggered", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSubscribeTriggered::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSubscribeTriggered(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSubscribeTriggered * SOAP_FMAC4 soap_get_ns2__TaskSubscribeTriggered(struct soap *soap, ns2__TaskSubscribeTriggered *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSubscribeTriggered(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSetDateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Task::soap_default(soap);
	soap_default_dateTime(soap, &this->ns2__TaskSetDateTime::time_USCOREto_USCOREset);
}

void ns2__TaskSetDateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__Task::soap_serialize(soap);
#endif
}

int ns2__TaskSetDateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSetDateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSetDateTime(struct soap *soap, const char *tag, int id, const ns2__TaskSetDateTime *a, const char *type)
{
	soap_set_attr(soap, "time_to_set", soap_dateTime2s(soap, ((ns2__TaskSetDateTime*)a)->time_USCOREto_USCOREset), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSetDateTime), type ? type : "ns2:TaskSetDateTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSetDateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSetDateTime(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSetDateTime * SOAP_FMAC4 soap_in_ns2__TaskSetDateTime(struct soap *soap, const char *tag, ns2__TaskSetDateTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSetDateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSetDateTime, sizeof(ns2__TaskSetDateTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSetDateTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSetDateTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "time_to_set", 1), &((ns2__TaskSetDateTime*)a)->time_USCOREto_USCOREset))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TaskSetDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSetDateTime, SOAP_TYPE_ns2__TaskSetDateTime, sizeof(ns2__TaskSetDateTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSetDateTime * SOAP_FMAC2 soap_instantiate_ns2__TaskSetDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSetDateTime(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSetDateTime *p;
	size_t k = sizeof(ns2__TaskSetDateTime);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSetDateTime);
		if (p)
			((ns2__TaskSetDateTime*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSetDateTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSetDateTime*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSetDateTime location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSetDateTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSetDateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSetDateTime(soap, tag ? tag : "ns2:TaskSetDateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSetDateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSetDateTime(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSetDateTime * SOAP_FMAC4 soap_get_ns2__TaskSetDateTime(struct soap *soap, ns2__TaskSetDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSetDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskSetDigitalOutput::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaskWithActivity::soap_default(soap);
	this->ns2__TaskSetDigitalOutput::__sizedigital_USCOREoutput_USCOREport = 0;
	this->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport = NULL;
}

void ns2__TaskSetDigitalOutput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport)
	{	int i;
		for (i = 0; i < (int)this->ns2__TaskSetDigitalOutput::__sizedigital_USCOREoutput_USCOREport; i++)
		{
			soap_serialize_PointerTons2__DigitalOutputElement(soap, this->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport + i);
		}
	}
	this->ns2__TaskWithActivity::soap_serialize(soap);
#endif
}

int ns2__TaskSetDigitalOutput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskSetDigitalOutput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskSetDigitalOutput(struct soap *soap, const char *tag, int id, const ns2__TaskSetDigitalOutput *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskSetDigitalOutput), type ? type : "ns2:TaskSetDigitalOutput"))
		return soap->error;
	if (a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport)
	{	int i;
		for (i = 0; i < (int)a->ns2__TaskSetDigitalOutput::__sizedigital_USCOREoutput_USCOREport; i++)
			if (soap_out_PointerTons2__DigitalOutputElement(soap, "ns2:digital_output_port", -1, a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskSetDigitalOutput::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskSetDigitalOutput(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskSetDigitalOutput * SOAP_FMAC4 soap_in_ns2__TaskSetDigitalOutput(struct soap *soap, const char *tag, ns2__TaskSetDigitalOutput *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskSetDigitalOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskSetDigitalOutput, sizeof(ns2__TaskSetDigitalOutput), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskSetDigitalOutput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskSetDigitalOutput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	struct soap_blist *soap_blist_digital_USCOREoutput_USCOREport1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:digital_output_port", 1, NULL))
			{	if (a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport == NULL)
				{	if (soap_blist_digital_USCOREoutput_USCOREport1 == NULL)
						soap_blist_digital_USCOREoutput_USCOREport1 = soap_new_block(soap);
					a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport = (ns2__DigitalOutputElement **)soap_push_block_max(soap, soap_blist_digital_USCOREoutput_USCOREport1, sizeof(ns2__DigitalOutputElement *));
					if (a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport == NULL)
						return NULL;
					*a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__DigitalOutputElement(soap, "ns2:digital_output_port", a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport, "ns2:DigitalOutputElement"))
				{	a->ns2__TaskSetDigitalOutput::__sizedigital_USCOREoutput_USCOREport++;
					a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport)
			soap_pop_block(soap, soap_blist_digital_USCOREoutput_USCOREport1);
		if (a->ns2__TaskSetDigitalOutput::__sizedigital_USCOREoutput_USCOREport)
		{	a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport = (ns2__DigitalOutputElement **)soap_save_block(soap, soap_blist_digital_USCOREoutput_USCOREport1, NULL, 1);
		}
		else
		{	a->ns2__TaskSetDigitalOutput::digital_USCOREoutput_USCOREport = NULL;
			if (soap_blist_digital_USCOREoutput_USCOREport1)
				soap_end_block(soap, soap_blist_digital_USCOREoutput_USCOREport1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__TaskSetDigitalOutput::__sizedigital_USCOREoutput_USCOREport < 1 || a->ns2__TaskSetDigitalOutput::__sizedigital_USCOREoutput_USCOREport > 16))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaskSetDigitalOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskSetDigitalOutput, SOAP_TYPE_ns2__TaskSetDigitalOutput, sizeof(ns2__TaskSetDigitalOutput), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskSetDigitalOutput * SOAP_FMAC2 soap_instantiate_ns2__TaskSetDigitalOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskSetDigitalOutput(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskSetDigitalOutput *p;
	size_t k = sizeof(ns2__TaskSetDigitalOutput);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskSetDigitalOutput);
		if (p)
			((ns2__TaskSetDigitalOutput*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskSetDigitalOutput, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskSetDigitalOutput*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskSetDigitalOutput location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskSetDigitalOutput, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskSetDigitalOutput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskSetDigitalOutput(soap, tag ? tag : "ns2:TaskSetDigitalOutput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskSetDigitalOutput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskSetDigitalOutput(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskSetDigitalOutput * SOAP_FMAC4 soap_get_ns2__TaskSetDigitalOutput(struct soap *soap, ns2__TaskSetDigitalOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskSetDigitalOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskWithActivity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Task::soap_default(soap);
	soap_default_bool(soap, &this->ns2__TaskWithActivity::activity_USCOREstate);
	this->ns2__TaskWithActivity::store_USCOREtask = NULL;
}

void ns2__TaskWithActivity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__Task::soap_serialize(soap);
#endif
}

int ns2__TaskWithActivity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskWithActivity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskWithActivity(struct soap *soap, const char *tag, int id, const ns2__TaskWithActivity *a, const char *type)
{
	soap_set_attr(soap, "activity_state", soap_bool2s(soap, ((ns2__TaskWithActivity*)a)->activity_USCOREstate), 1);
	if (((ns2__TaskWithActivity*)a)->store_USCOREtask)
		soap_set_attr(soap, "store_task", soap_bool2s(soap, *((ns2__TaskWithActivity*)a)->store_USCOREtask), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskWithActivity), type ? type : "ns2:TaskWithActivity"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskWithActivity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskWithActivity(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskWithActivity * SOAP_FMAC4 soap_in_ns2__TaskWithActivity(struct soap *soap, const char *tag, ns2__TaskWithActivity *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskWithActivity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskWithActivity, sizeof(ns2__TaskWithActivity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskWithActivity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskWithActivity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "activity_state", 1), &((ns2__TaskWithActivity*)a)->activity_USCOREstate))
		return NULL;
	{	const char *t = soap_attr_value(soap, "store_task", 0);
		if (t)
		{
			if (!(((ns2__TaskWithActivity*)a)->store_USCOREtask = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((ns2__TaskWithActivity*)a)->store_USCOREtask))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TaskWithActivity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskWithActivity, SOAP_TYPE_ns2__TaskWithActivity, sizeof(ns2__TaskWithActivity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskWithActivity * SOAP_FMAC2 soap_instantiate_ns2__TaskWithActivity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskWithActivity(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSetDigitalOutput"))
		return soap_instantiate_ns2__TaskSetDigitalOutput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeTriggered"))
		return soap_instantiate_ns2__TaskSubscribeTriggered(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeTriggeredSafe"))
		return soap_instantiate_ns2__TaskSubscribeTriggeredSafe(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeLogfiles"))
		return soap_instantiate_ns2__TaskSubscribeLogfiles(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeErrorLog"))
		return soap_instantiate_ns2__TaskSubscribeErrorLog(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCameraImages"))
		return soap_instantiate_ns2__TaskSubscribeCameraImages(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeSendParameters"))
		return soap_instantiate_ns2__TaskSubscribeSendParameters(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeVideoStore"))
		return soap_instantiate_ns2__TaskSubscribeVideoStore(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeAlive"))
		return soap_instantiate_ns2__TaskSubscribeAlive(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeObjectList"))
		return soap_instantiate_ns2__TaskSubscribeObjectList(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeFeaturesInfo"))
		return soap_instantiate_ns2__TaskSubscribeFeaturesInfo(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCounting"))
		return soap_instantiate_ns2__TaskSubscribeCounting(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCountChannels"))
		return soap_instantiate_ns2__TaskSubscribeCountChannels(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeZoneChannels"))
		return soap_instantiate_ns2__TaskSubscribeZoneChannels(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeFill"))
		return soap_instantiate_ns2__TaskSubscribeFill(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeClearZone"))
		return soap_instantiate_ns2__TaskSubscribeClearZone(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeDigitalInput"))
		return soap_instantiate_ns2__TaskSubscribeDigitalInput(soap, n, NULL, NULL, size);
	ns2__TaskWithActivity *p;
	size_t k = sizeof(ns2__TaskWithActivity);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskWithActivity);
		if (p)
			((ns2__TaskWithActivity*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskWithActivity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskWithActivity*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskWithActivity location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskWithActivity, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskWithActivity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskWithActivity(soap, tag ? tag : "ns2:TaskWithActivity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskWithActivity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskWithActivity(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskWithActivity * SOAP_FMAC4 soap_get_ns2__TaskWithActivity(struct soap *soap, ns2__TaskWithActivity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskWithActivity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskRequestParameters::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Task::soap_default(soap);
	soap_default_std__wstring(soap, &this->ns2__TaskRequestParameters::packet_USCOREurl);
}

void ns2__TaskRequestParameters::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__Task::soap_serialize(soap);
#endif
}

int ns2__TaskRequestParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskRequestParameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskRequestParameters(struct soap *soap, const char *tag, int id, const ns2__TaskRequestParameters *a, const char *type)
{
	soap_set_attr(soap, "packet_url", soap_std__wstring2s(soap, ((ns2__TaskRequestParameters*)a)->packet_USCOREurl), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskRequestParameters), type ? type : "ns2:TaskRequestParameters"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskRequestParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskRequestParameters(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskRequestParameters * SOAP_FMAC4 soap_in_ns2__TaskRequestParameters(struct soap *soap, const char *tag, ns2__TaskRequestParameters *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskRequestParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskRequestParameters, sizeof(ns2__TaskRequestParameters), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskRequestParameters)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskRequestParameters *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "packet_url", 1), &((ns2__TaskRequestParameters*)a)->packet_USCOREurl))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TaskRequestParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskRequestParameters, SOAP_TYPE_ns2__TaskRequestParameters, sizeof(ns2__TaskRequestParameters), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskRequestParameters * SOAP_FMAC2 soap_instantiate_ns2__TaskRequestParameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskRequestParameters(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskRequestParameters *p;
	size_t k = sizeof(ns2__TaskRequestParameters);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskRequestParameters);
		if (p)
			((ns2__TaskRequestParameters*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskRequestParameters, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskRequestParameters*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskRequestParameters location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskRequestParameters, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskRequestParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskRequestParameters(soap, tag ? tag : "ns2:TaskRequestParameters", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskRequestParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskRequestParameters(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskRequestParameters * SOAP_FMAC4 soap_get_ns2__TaskRequestParameters(struct soap *soap, ns2__TaskRequestParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskRequestParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskRequestUpdate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Task::soap_default(soap);
	soap_default_ns2__UpdateType(soap, &this->ns2__TaskRequestUpdate::update_USCOREtype);
	soap_default_std__wstring(soap, &this->ns2__TaskRequestUpdate::packet_USCOREurl);
	soap_default_unsignedInt(soap, &this->ns2__TaskRequestUpdate::validity);
}

void ns2__TaskRequestUpdate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__Task::soap_serialize(soap);
#endif
}

int ns2__TaskRequestUpdate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskRequestUpdate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskRequestUpdate(struct soap *soap, const char *tag, int id, const ns2__TaskRequestUpdate *a, const char *type)
{
	soap_set_attr(soap, "update_type", soap_ns2__UpdateType2s(soap, ((ns2__TaskRequestUpdate*)a)->update_USCOREtype), 1);
	soap_set_attr(soap, "packet_url", soap_std__wstring2s(soap, ((ns2__TaskRequestUpdate*)a)->packet_USCOREurl), 2);
	soap_set_attr(soap, "validity", soap_unsignedInt2s(soap, ((ns2__TaskRequestUpdate*)a)->validity), 1);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskRequestUpdate), type ? type : "ns2:TaskRequestUpdate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskRequestUpdate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskRequestUpdate(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskRequestUpdate * SOAP_FMAC4 soap_in_ns2__TaskRequestUpdate(struct soap *soap, const char *tag, ns2__TaskRequestUpdate *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskRequestUpdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskRequestUpdate, sizeof(ns2__TaskRequestUpdate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskRequestUpdate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskRequestUpdate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__UpdateType(soap, soap_attr_value(soap, "update_type", 1), &((ns2__TaskRequestUpdate*)a)->update_USCOREtype))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "packet_url", 1), &((ns2__TaskRequestUpdate*)a)->packet_USCOREurl))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "validity", 1), &((ns2__TaskRequestUpdate*)a)->validity))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TaskRequestUpdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskRequestUpdate, SOAP_TYPE_ns2__TaskRequestUpdate, sizeof(ns2__TaskRequestUpdate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskRequestUpdate * SOAP_FMAC2 soap_instantiate_ns2__TaskRequestUpdate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskRequestUpdate(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskRequestUpdate *p;
	size_t k = sizeof(ns2__TaskRequestUpdate);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskRequestUpdate);
		if (p)
			((ns2__TaskRequestUpdate*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskRequestUpdate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskRequestUpdate*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskRequestUpdate location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskRequestUpdate, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskRequestUpdate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskRequestUpdate(soap, tag ? tag : "ns2:TaskRequestUpdate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskRequestUpdate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskRequestUpdate(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskRequestUpdate * SOAP_FMAC4 soap_get_ns2__TaskRequestUpdate(struct soap *soap, ns2__TaskRequestUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskRequestUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaskRebootNow::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Task::soap_default(soap);
}

void ns2__TaskRebootNow::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__Task::soap_serialize(soap);
#endif
}

int ns2__TaskRebootNow::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaskRebootNow(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaskRebootNow(struct soap *soap, const char *tag, int id, const ns2__TaskRebootNow *a, const char *type)
{
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaskRebootNow), type ? type : "ns2:TaskRebootNow"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaskRebootNow::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaskRebootNow(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaskRebootNow * SOAP_FMAC4 soap_in_ns2__TaskRebootNow(struct soap *soap, const char *tag, ns2__TaskRebootNow *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaskRebootNow *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaskRebootNow, sizeof(ns2__TaskRebootNow), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaskRebootNow)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaskRebootNow *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TaskRebootNow *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaskRebootNow, SOAP_TYPE_ns2__TaskRebootNow, sizeof(ns2__TaskRebootNow), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaskRebootNow * SOAP_FMAC2 soap_instantiate_ns2__TaskRebootNow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaskRebootNow(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaskRebootNow *p;
	size_t k = sizeof(ns2__TaskRebootNow);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaskRebootNow);
		if (p)
			((ns2__TaskRebootNow*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaskRebootNow, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaskRebootNow*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaskRebootNow location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaskRebootNow, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaskRebootNow::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TaskRebootNow(soap, tag ? tag : "ns2:TaskRebootNow", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaskRebootNow::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaskRebootNow(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaskRebootNow * SOAP_FMAC4 soap_get_ns2__TaskRebootNow(struct soap *soap, ns2__TaskRebootNow *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaskRebootNow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Task::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__TaskType(soap, &this->ns2__Task::task_USCOREtype);
	soap_default_unsignedInt(soap, &this->ns2__Task::serverTask_USCOREID);
	/* transient soap skipped */
}

void ns2__Task::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__Task::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Task(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Task(struct soap *soap, const char *tag, int id, const ns2__Task *a, const char *type)
{
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__Task*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__Task*)a)->serverTask_USCOREID), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Task), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Task::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Task(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Task * SOAP_FMAC4 soap_in_ns2__Task(struct soap *soap, const char *tag, ns2__Task *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Task *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Task, sizeof(ns2__Task), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Task)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Task *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__Task*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__Task*)a)->serverTask_USCOREID))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Task *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Task, SOAP_TYPE_ns2__Task, sizeof(ns2__Task), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Task * SOAP_FMAC2 soap_instantiate_ns2__Task(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Task(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskRebootNow"))
		return soap_instantiate_ns2__TaskRebootNow(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskRequestUpdate"))
		return soap_instantiate_ns2__TaskRequestUpdate(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskRequestParameters"))
		return soap_instantiate_ns2__TaskRequestParameters(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskWithActivity"))
		return soap_instantiate_ns2__TaskWithActivity(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSetDateTime"))
		return soap_instantiate_ns2__TaskSetDateTime(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskDeleteAllTasks"))
		return soap_instantiate_ns2__TaskDeleteAllTasks(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskDeleteAllNotifications"))
		return soap_instantiate_ns2__TaskDeleteAllNotifications(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSetDigitalOutput"))
		return soap_instantiate_ns2__TaskSetDigitalOutput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeTriggered"))
		return soap_instantiate_ns2__TaskSubscribeTriggered(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeTriggeredSafe"))
		return soap_instantiate_ns2__TaskSubscribeTriggeredSafe(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeLogfiles"))
		return soap_instantiate_ns2__TaskSubscribeLogfiles(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeErrorLog"))
		return soap_instantiate_ns2__TaskSubscribeErrorLog(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCameraImages"))
		return soap_instantiate_ns2__TaskSubscribeCameraImages(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeSendParameters"))
		return soap_instantiate_ns2__TaskSubscribeSendParameters(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeVideoStore"))
		return soap_instantiate_ns2__TaskSubscribeVideoStore(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeAlive"))
		return soap_instantiate_ns2__TaskSubscribeAlive(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeObjectList"))
		return soap_instantiate_ns2__TaskSubscribeObjectList(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeFeaturesInfo"))
		return soap_instantiate_ns2__TaskSubscribeFeaturesInfo(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCounting"))
		return soap_instantiate_ns2__TaskSubscribeCounting(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeCountChannels"))
		return soap_instantiate_ns2__TaskSubscribeCountChannels(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeZoneChannels"))
		return soap_instantiate_ns2__TaskSubscribeZoneChannels(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeFill"))
		return soap_instantiate_ns2__TaskSubscribeFill(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeClearZone"))
		return soap_instantiate_ns2__TaskSubscribeClearZone(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:TaskSubscribeDigitalInput"))
		return soap_instantiate_ns2__TaskSubscribeDigitalInput(soap, n, NULL, NULL, size);
	ns2__Task *p;
	size_t k = sizeof(ns2__Task);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Task);
		if (p)
			((ns2__Task*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Task, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Task*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Task location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Task, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Task::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__Task(soap, tag ? tag : "ns2:Task", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Task::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Task(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Task * SOAP_FMAC4 soap_get_ns2__Task(struct soap *soap, ns2__Task *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Task(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__NotificationContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationContainer::__union_NotificationContainer = -1;
	/* transient soap skipped */
}

void ns2__NotificationContainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns2__union_NotificationContainer(soap, this->ns2__NotificationContainer::__union_NotificationContainer, &this->ns2__NotificationContainer::union_NotificationContainer);
#endif
}

int ns2__NotificationContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NotificationContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NotificationContainer(struct soap *soap, const char *tag, int id, const ns2__NotificationContainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NotificationContainer), type))
		return soap->error;
	if (soap_out__ns2__union_NotificationContainer(soap, a->ns2__NotificationContainer::__union_NotificationContainer, &a->ns2__NotificationContainer::union_NotificationContainer))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__NotificationContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NotificationContainer(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NotificationContainer * SOAP_FMAC4 soap_in_ns2__NotificationContainer(struct soap *soap, const char *tag, ns2__NotificationContainer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NotificationContainer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NotificationContainer, sizeof(ns2__NotificationContainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__ns2__union_NotificationContainer(soap, &a->__union_NotificationContainer, &a->union_NotificationContainer))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns2__NotificationContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NotificationContainer, SOAP_TYPE_ns2__NotificationContainer, sizeof(ns2__NotificationContainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__NotificationContainer * SOAP_FMAC2 soap_instantiate_ns2__NotificationContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NotificationContainer(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__NotificationContainer *p;
	size_t k = sizeof(ns2__NotificationContainer);
	if (n < 0)
	{	p = SOAP_NEW(ns2__NotificationContainer);
		if (p)
			((ns2__NotificationContainer*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__NotificationContainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__NotificationContainer*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__NotificationContainer location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__NotificationContainer, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__NotificationContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__NotificationContainer(soap, tag ? tag : "ns2:NotificationContainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NotificationContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NotificationContainer(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NotificationContainer * SOAP_FMAC4 soap_get_ns2__NotificationContainer(struct soap *soap, ns2__NotificationContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NotificationContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__HistoricObjectListNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HistoricObjectListNotificationBase::soap_default(soap);
	soap_default_unsignedInt(soap, &this->ns2__HistoricObjectListNotification::lost_USCOREcount);
}

void ns2__HistoricObjectListNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__HistoricObjectListNotificationBase::soap_serialize(soap);
#endif
}

int ns2__HistoricObjectListNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HistoricObjectListNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HistoricObjectListNotification(struct soap *soap, const char *tag, int id, const ns2__HistoricObjectListNotification *a, const char *type)
{
	soap_set_attr(soap, "lost_count", soap_unsignedInt2s(soap, ((ns2__HistoricObjectListNotification*)a)->lost_USCOREcount), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HistoricObjectListNotification), type ? type : "ns2:HistoricObjectListNotification"))
		return soap->error;
	if (a->ns2__HistoricObjectListNotificationBase::obj)
	{	int i;
		for (i = 0; i < (int)a->ns2__HistoricObjectListNotificationBase::__sizeobj; i++)
			if (soap_out_PointerTons2__HistoricObject(soap, "ns2:obj", -1, a->ns2__HistoricObjectListNotificationBase::obj + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__BinaryData(soap, "ns2:binary_data", -1, &a->ns2__HistoricObjectListNotificationBase::binary_USCOREdata, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__HistoricObjectListNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HistoricObjectListNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HistoricObjectListNotification * SOAP_FMAC4 soap_in_ns2__HistoricObjectListNotification(struct soap *soap, const char *tag, ns2__HistoricObjectListNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HistoricObjectListNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HistoricObjectListNotification, sizeof(ns2__HistoricObjectListNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__HistoricObjectListNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__HistoricObjectListNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "lost_count", 1), &((ns2__HistoricObjectListNotification*)a)->lost_USCOREcount))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	struct soap_blist *soap_blist_obj2 = NULL;
	size_t soap_flag_binary_USCOREdata2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:obj", 1, NULL))
			{	if (a->ns2__HistoricObjectListNotificationBase::obj == NULL)
				{	if (soap_blist_obj2 == NULL)
						soap_blist_obj2 = soap_new_block(soap);
					a->ns2__HistoricObjectListNotificationBase::obj = (ns2__HistoricObject **)soap_push_block_max(soap, soap_blist_obj2, sizeof(ns2__HistoricObject *));
					if (a->ns2__HistoricObjectListNotificationBase::obj == NULL)
						return NULL;
					*a->ns2__HistoricObjectListNotificationBase::obj = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__HistoricObject(soap, "ns2:obj", a->ns2__HistoricObjectListNotificationBase::obj, "ns2:HistoricObject"))
				{	a->ns2__HistoricObjectListNotificationBase::__sizeobj++;
					a->ns2__HistoricObjectListNotificationBase::obj = NULL;
					continue;
				}
			}
			if (soap_flag_binary_USCOREdata2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinaryData(soap, "ns2:binary_data", &a->ns2__HistoricObjectListNotificationBase::binary_USCOREdata, "ns2:BinaryData"))
				{	soap_flag_binary_USCOREdata2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__HistoricObjectListNotificationBase::obj)
			soap_pop_block(soap, soap_blist_obj2);
		if (a->ns2__HistoricObjectListNotificationBase::__sizeobj)
		{	a->ns2__HistoricObjectListNotificationBase::obj = (ns2__HistoricObject **)soap_save_block(soap, soap_blist_obj2, NULL, 1);
		}
		else
		{	a->ns2__HistoricObjectListNotificationBase::obj = NULL;
			if (soap_blist_obj2)
				soap_end_block(soap, soap_blist_obj2);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HistoricObjectListNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HistoricObjectListNotification, SOAP_TYPE_ns2__HistoricObjectListNotification, sizeof(ns2__HistoricObjectListNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__HistoricObjectListNotification * SOAP_FMAC2 soap_instantiate_ns2__HistoricObjectListNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HistoricObjectListNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__HistoricObjectListNotification *p;
	size_t k = sizeof(ns2__HistoricObjectListNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__HistoricObjectListNotification);
		if (p)
			((ns2__HistoricObjectListNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__HistoricObjectListNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__HistoricObjectListNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__HistoricObjectListNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__HistoricObjectListNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__HistoricObjectListNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__HistoricObjectListNotification(soap, tag ? tag : "ns2:HistoricObjectListNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HistoricObjectListNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HistoricObjectListNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HistoricObjectListNotification * SOAP_FMAC4 soap_get_ns2__HistoricObjectListNotification(struct soap *soap, ns2__HistoricObjectListNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HistoricObjectListNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__HistoricObjectListNotificationBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationBase::soap_default(soap);
	this->ns2__HistoricObjectListNotificationBase::__sizeobj = 0;
	this->ns2__HistoricObjectListNotificationBase::obj = NULL;
	this->ns2__HistoricObjectListNotificationBase::binary_USCOREdata = NULL;
}

void ns2__HistoricObjectListNotificationBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__HistoricObjectListNotificationBase::obj)
	{	int i;
		for (i = 0; i < (int)this->ns2__HistoricObjectListNotificationBase::__sizeobj; i++)
		{
			soap_serialize_PointerTons2__HistoricObject(soap, this->ns2__HistoricObjectListNotificationBase::obj + i);
		}
	}
	soap_serialize_PointerTons2__BinaryData(soap, &this->ns2__HistoricObjectListNotificationBase::binary_USCOREdata);
	this->ns2__NotificationBase::soap_serialize(soap);
#endif
}

int ns2__HistoricObjectListNotificationBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HistoricObjectListNotificationBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HistoricObjectListNotificationBase(struct soap *soap, const char *tag, int id, const ns2__HistoricObjectListNotificationBase *a, const char *type)
{
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HistoricObjectListNotificationBase), type ? type : "ns2:HistoricObjectListNotificationBase"))
		return soap->error;
	if (a->ns2__HistoricObjectListNotificationBase::obj)
	{	int i;
		for (i = 0; i < (int)a->ns2__HistoricObjectListNotificationBase::__sizeobj; i++)
			if (soap_out_PointerTons2__HistoricObject(soap, "ns2:obj", -1, a->ns2__HistoricObjectListNotificationBase::obj + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__BinaryData(soap, "ns2:binary_data", -1, &a->ns2__HistoricObjectListNotificationBase::binary_USCOREdata, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__HistoricObjectListNotificationBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HistoricObjectListNotificationBase(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HistoricObjectListNotificationBase * SOAP_FMAC4 soap_in_ns2__HistoricObjectListNotificationBase(struct soap *soap, const char *tag, ns2__HistoricObjectListNotificationBase *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HistoricObjectListNotificationBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HistoricObjectListNotificationBase, sizeof(ns2__HistoricObjectListNotificationBase), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__HistoricObjectListNotificationBase)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__HistoricObjectListNotificationBase *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	struct soap_blist *soap_blist_obj1 = NULL;
	size_t soap_flag_binary_USCOREdata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:obj", 1, NULL))
			{	if (a->ns2__HistoricObjectListNotificationBase::obj == NULL)
				{	if (soap_blist_obj1 == NULL)
						soap_blist_obj1 = soap_new_block(soap);
					a->ns2__HistoricObjectListNotificationBase::obj = (ns2__HistoricObject **)soap_push_block_max(soap, soap_blist_obj1, sizeof(ns2__HistoricObject *));
					if (a->ns2__HistoricObjectListNotificationBase::obj == NULL)
						return NULL;
					*a->ns2__HistoricObjectListNotificationBase::obj = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__HistoricObject(soap, "ns2:obj", a->ns2__HistoricObjectListNotificationBase::obj, "ns2:HistoricObject"))
				{	a->ns2__HistoricObjectListNotificationBase::__sizeobj++;
					a->ns2__HistoricObjectListNotificationBase::obj = NULL;
					continue;
				}
			}
			if (soap_flag_binary_USCOREdata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinaryData(soap, "ns2:binary_data", &a->ns2__HistoricObjectListNotificationBase::binary_USCOREdata, "ns2:BinaryData"))
				{	soap_flag_binary_USCOREdata1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__HistoricObjectListNotificationBase::obj)
			soap_pop_block(soap, soap_blist_obj1);
		if (a->ns2__HistoricObjectListNotificationBase::__sizeobj)
		{	a->ns2__HistoricObjectListNotificationBase::obj = (ns2__HistoricObject **)soap_save_block(soap, soap_blist_obj1, NULL, 1);
		}
		else
		{	a->ns2__HistoricObjectListNotificationBase::obj = NULL;
			if (soap_blist_obj1)
				soap_end_block(soap, soap_blist_obj1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HistoricObjectListNotificationBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HistoricObjectListNotificationBase, SOAP_TYPE_ns2__HistoricObjectListNotificationBase, sizeof(ns2__HistoricObjectListNotificationBase), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__HistoricObjectListNotificationBase * SOAP_FMAC2 soap_instantiate_ns2__HistoricObjectListNotificationBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HistoricObjectListNotificationBase(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:HistoricObjectListNotification"))
		return soap_instantiate_ns2__HistoricObjectListNotification(soap, n, NULL, NULL, size);
	ns2__HistoricObjectListNotificationBase *p;
	size_t k = sizeof(ns2__HistoricObjectListNotificationBase);
	if (n < 0)
	{	p = SOAP_NEW(ns2__HistoricObjectListNotificationBase);
		if (p)
			((ns2__HistoricObjectListNotificationBase*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__HistoricObjectListNotificationBase, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__HistoricObjectListNotificationBase*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__HistoricObjectListNotificationBase location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__HistoricObjectListNotificationBase, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__HistoricObjectListNotificationBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__HistoricObjectListNotificationBase(soap, tag ? tag : "ns2:HistoricObjectListNotificationBase", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HistoricObjectListNotificationBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HistoricObjectListNotificationBase(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HistoricObjectListNotificationBase * SOAP_FMAC4 soap_get_ns2__HistoricObjectListNotificationBase(struct soap *soap, ns2__HistoricObjectListNotificationBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HistoricObjectListNotificationBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CurrentObjectListNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationWithOSDState::soap_default(soap);
	this->ns2__CurrentObjectListNotification::__sizeobj = 0;
	this->ns2__CurrentObjectListNotification::obj = NULL;
	this->ns2__CurrentObjectListNotification::binary_USCOREdata = NULL;
}

void ns2__CurrentObjectListNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__CurrentObjectListNotification::obj)
	{	int i;
		for (i = 0; i < (int)this->ns2__CurrentObjectListNotification::__sizeobj; i++)
		{
			soap_serialize_PointerTons2__CurrentObject(soap, this->ns2__CurrentObjectListNotification::obj + i);
		}
	}
	soap_serialize_PointerTons2__BinaryData(soap, &this->ns2__CurrentObjectListNotification::binary_USCOREdata);
	this->ns2__NotificationWithOSDState::soap_serialize(soap);
#endif
}

int ns2__CurrentObjectListNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CurrentObjectListNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CurrentObjectListNotification(struct soap *soap, const char *tag, int id, const ns2__CurrentObjectListNotification *a, const char *type)
{
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CurrentObjectListNotification), type ? type : "ns2:CurrentObjectListNotification"))
		return soap->error;
	if (a->ns2__CurrentObjectListNotification::obj)
	{	int i;
		for (i = 0; i < (int)a->ns2__CurrentObjectListNotification::__sizeobj; i++)
			if (soap_out_PointerTons2__CurrentObject(soap, "ns2:obj", -1, a->ns2__CurrentObjectListNotification::obj + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons2__BinaryData(soap, "ns2:binary_data", -1, &a->ns2__CurrentObjectListNotification::binary_USCOREdata, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CurrentObjectListNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CurrentObjectListNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CurrentObjectListNotification * SOAP_FMAC4 soap_in_ns2__CurrentObjectListNotification(struct soap *soap, const char *tag, ns2__CurrentObjectListNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CurrentObjectListNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CurrentObjectListNotification, sizeof(ns2__CurrentObjectListNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CurrentObjectListNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CurrentObjectListNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	struct soap_blist *soap_blist_obj1 = NULL;
	size_t soap_flag_binary_USCOREdata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:obj", 1, NULL))
			{	if (a->ns2__CurrentObjectListNotification::obj == NULL)
				{	if (soap_blist_obj1 == NULL)
						soap_blist_obj1 = soap_new_block(soap);
					a->ns2__CurrentObjectListNotification::obj = (ns2__CurrentObject **)soap_push_block_max(soap, soap_blist_obj1, sizeof(ns2__CurrentObject *));
					if (a->ns2__CurrentObjectListNotification::obj == NULL)
						return NULL;
					*a->ns2__CurrentObjectListNotification::obj = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__CurrentObject(soap, "ns2:obj", a->ns2__CurrentObjectListNotification::obj, "ns2:CurrentObject"))
				{	a->ns2__CurrentObjectListNotification::__sizeobj++;
					a->ns2__CurrentObjectListNotification::obj = NULL;
					continue;
				}
			}
			if (soap_flag_binary_USCOREdata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinaryData(soap, "ns2:binary_data", &a->ns2__CurrentObjectListNotification::binary_USCOREdata, "ns2:BinaryData"))
				{	soap_flag_binary_USCOREdata1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__CurrentObjectListNotification::obj)
			soap_pop_block(soap, soap_blist_obj1);
		if (a->ns2__CurrentObjectListNotification::__sizeobj)
		{	a->ns2__CurrentObjectListNotification::obj = (ns2__CurrentObject **)soap_save_block(soap, soap_blist_obj1, NULL, 1);
		}
		else
		{	a->ns2__CurrentObjectListNotification::obj = NULL;
			if (soap_blist_obj1)
				soap_end_block(soap, soap_blist_obj1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CurrentObjectListNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CurrentObjectListNotification, SOAP_TYPE_ns2__CurrentObjectListNotification, sizeof(ns2__CurrentObjectListNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CurrentObjectListNotification * SOAP_FMAC2 soap_instantiate_ns2__CurrentObjectListNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CurrentObjectListNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CurrentObjectListNotification *p;
	size_t k = sizeof(ns2__CurrentObjectListNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CurrentObjectListNotification);
		if (p)
			((ns2__CurrentObjectListNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CurrentObjectListNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CurrentObjectListNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CurrentObjectListNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CurrentObjectListNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CurrentObjectListNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CurrentObjectListNotification(soap, tag ? tag : "ns2:CurrentObjectListNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CurrentObjectListNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CurrentObjectListNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CurrentObjectListNotification * SOAP_FMAC4 soap_get_ns2__CurrentObjectListNotification(struct soap *soap, ns2__CurrentObjectListNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CurrentObjectListNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__HistoricObject::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Object::soap_default(soap);
	this->ns2__HistoricObject::exit = NULL;
	soap_default_dateTime(soap, &this->ns2__HistoricObject::exit_USCOREtime);
	soap_default_unsignedInt(soap, &this->ns2__HistoricObject::height);
}

void ns2__HistoricObject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Coordinate_USCORE3D(soap, &this->ns2__HistoricObject::exit);
	this->ns2__Object::soap_serialize(soap);
#endif
}

int ns2__HistoricObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HistoricObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HistoricObject(struct soap *soap, const char *tag, int id, const ns2__HistoricObject *a, const char *type)
{
	soap_set_attr(soap, "exit_time", soap_dateTime2s(soap, ((ns2__HistoricObject*)a)->exit_USCOREtime), 1);
	soap_set_attr(soap, "height", soap_unsignedInt2s(soap, ((ns2__HistoricObject*)a)->height), 1);
	soap_set_attr(soap, "id", soap_unsignedInt2s(soap, ((ns2__Object*)a)->id), 1);
	if (((ns2__Object*)a)->objClass)
		soap_set_attr(soap, "objClass", soap_ns2__ObjectClassName2s(soap, *((ns2__Object*)a)->objClass), 2);
	soap_set_attr(soap, "zone", soap_std__wstring2s(soap, ((ns2__Object*)a)->zone), 2);
	soap_set_attr(soap, "dwell", soap_ns2__ShortDuration2s(soap, ((ns2__Object*)a)->dwell), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HistoricObject), type ? type : "ns2:HistoricObject"))
		return soap->error;
	if (!a->ns2__Object::entry)
	{	if (soap_element_nil(soap, "ns2:entry"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Coordinate_USCORE3D(soap, "ns2:entry", -1, &a->ns2__Object::entry, ""))
		return soap->error;
	if (!a->ns2__HistoricObject::exit)
	{	if (soap_element_nil(soap, "ns2:exit"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Coordinate_USCORE3D(soap, "ns2:exit", -1, &a->ns2__HistoricObject::exit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__HistoricObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HistoricObject(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HistoricObject * SOAP_FMAC4 soap_in_ns2__HistoricObject(struct soap *soap, const char *tag, ns2__HistoricObject *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HistoricObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HistoricObject, sizeof(ns2__HistoricObject), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__HistoricObject)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__HistoricObject *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "exit_time", 1), &((ns2__HistoricObject*)a)->exit_USCOREtime))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "height", 1), &((ns2__HistoricObject*)a)->height))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "id", 1), &((ns2__Object*)a)->id))
		return NULL;
	{	const char *t = soap_attr_value(soap, "objClass", 0);
		if (t)
		{
			if (!(((ns2__Object*)a)->objClass = soap_new_ns2__ObjectClassName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__ObjectClassName(soap, t, ((ns2__Object*)a)->objClass))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "zone", 0), &((ns2__Object*)a)->zone))
		return NULL;
	if (soap_s2ns2__ShortDuration(soap, soap_attr_value(soap, "dwell", 1), &((ns2__Object*)a)->dwell))
		return NULL;
	size_t soap_flag_entry2 = 1;
	size_t soap_flag_exit1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Coordinate_USCORE3D(soap, "ns2:entry", &a->ns2__Object::entry, "ns2:Coordinate_3D"))
				{	soap_flag_entry2--;
					continue;
				}
			if (soap_flag_exit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Coordinate_USCORE3D(soap, "ns2:exit", &a->ns2__HistoricObject::exit, "ns2:Coordinate_3D"))
				{	soap_flag_exit1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry2 > 0 || soap_flag_exit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__HistoricObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HistoricObject, SOAP_TYPE_ns2__HistoricObject, sizeof(ns2__HistoricObject), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__HistoricObject * SOAP_FMAC2 soap_instantiate_ns2__HistoricObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HistoricObject(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__HistoricObject *p;
	size_t k = sizeof(ns2__HistoricObject);
	if (n < 0)
	{	p = SOAP_NEW(ns2__HistoricObject);
		if (p)
			((ns2__HistoricObject*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__HistoricObject, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__HistoricObject*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__HistoricObject location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__HistoricObject, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__HistoricObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__HistoricObject(soap, tag ? tag : "ns2:HistoricObject", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HistoricObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HistoricObject(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HistoricObject * SOAP_FMAC4 soap_get_ns2__HistoricObject(struct soap *soap, ns2__HistoricObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HistoricObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CurrentObject::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Object::soap_default(soap);
	this->ns2__CurrentObject::pos = NULL;
	this->ns2__CurrentObject::mov = NULL;
}

void ns2__CurrentObject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Coordinate_USCORE3D(soap, &this->ns2__CurrentObject::pos);
	soap_serialize_PointerTons2__Coordinate_USCORE2D(soap, &this->ns2__CurrentObject::mov);
	this->ns2__Object::soap_serialize(soap);
#endif
}

int ns2__CurrentObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CurrentObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CurrentObject(struct soap *soap, const char *tag, int id, const ns2__CurrentObject *a, const char *type)
{
	soap_set_attr(soap, "id", soap_unsignedInt2s(soap, ((ns2__Object*)a)->id), 1);
	if (((ns2__Object*)a)->objClass)
		soap_set_attr(soap, "objClass", soap_ns2__ObjectClassName2s(soap, *((ns2__Object*)a)->objClass), 2);
	soap_set_attr(soap, "zone", soap_std__wstring2s(soap, ((ns2__Object*)a)->zone), 2);
	soap_set_attr(soap, "dwell", soap_ns2__ShortDuration2s(soap, ((ns2__Object*)a)->dwell), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CurrentObject), type ? type : "ns2:CurrentObject"))
		return soap->error;
	if (!a->ns2__Object::entry)
	{	if (soap_element_nil(soap, "ns2:entry"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Coordinate_USCORE3D(soap, "ns2:entry", -1, &a->ns2__Object::entry, ""))
		return soap->error;
	if (!a->ns2__CurrentObject::pos)
	{	if (soap_element_nil(soap, "ns2:pos"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Coordinate_USCORE3D(soap, "ns2:pos", -1, &a->ns2__CurrentObject::pos, ""))
		return soap->error;
	if (!a->ns2__CurrentObject::mov)
	{	if (soap_element_nil(soap, "ns2:mov"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Coordinate_USCORE2D(soap, "ns2:mov", -1, &a->ns2__CurrentObject::mov, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CurrentObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CurrentObject(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CurrentObject * SOAP_FMAC4 soap_in_ns2__CurrentObject(struct soap *soap, const char *tag, ns2__CurrentObject *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CurrentObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CurrentObject, sizeof(ns2__CurrentObject), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CurrentObject)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CurrentObject *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "id", 1), &((ns2__Object*)a)->id))
		return NULL;
	{	const char *t = soap_attr_value(soap, "objClass", 0);
		if (t)
		{
			if (!(((ns2__Object*)a)->objClass = soap_new_ns2__ObjectClassName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__ObjectClassName(soap, t, ((ns2__Object*)a)->objClass))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "zone", 0), &((ns2__Object*)a)->zone))
		return NULL;
	if (soap_s2ns2__ShortDuration(soap, soap_attr_value(soap, "dwell", 1), &((ns2__Object*)a)->dwell))
		return NULL;
	size_t soap_flag_entry2 = 1;
	size_t soap_flag_pos1 = 1;
	size_t soap_flag_mov1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Coordinate_USCORE3D(soap, "ns2:entry", &a->ns2__Object::entry, "ns2:Coordinate_3D"))
				{	soap_flag_entry2--;
					continue;
				}
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Coordinate_USCORE3D(soap, "ns2:pos", &a->ns2__CurrentObject::pos, "ns2:Coordinate_3D"))
				{	soap_flag_pos1--;
					continue;
				}
			if (soap_flag_mov1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Coordinate_USCORE2D(soap, "ns2:mov", &a->ns2__CurrentObject::mov, "ns2:Coordinate_2D"))
				{	soap_flag_mov1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry2 > 0 || soap_flag_pos1 > 0 || soap_flag_mov1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CurrentObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CurrentObject, SOAP_TYPE_ns2__CurrentObject, sizeof(ns2__CurrentObject), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CurrentObject * SOAP_FMAC2 soap_instantiate_ns2__CurrentObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CurrentObject(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CurrentObject *p;
	size_t k = sizeof(ns2__CurrentObject);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CurrentObject);
		if (p)
			((ns2__CurrentObject*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CurrentObject, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CurrentObject*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CurrentObject location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CurrentObject, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CurrentObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CurrentObject(soap, tag ? tag : "ns2:CurrentObject", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CurrentObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CurrentObject(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CurrentObject * SOAP_FMAC4 soap_get_ns2__CurrentObject(struct soap *soap, ns2__CurrentObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CurrentObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Object::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Object::entry = NULL;
	soap_default_unsignedInt(soap, &this->ns2__Object::id);
	this->ns2__Object::objClass = NULL;
	this->ns2__Object::zone = L"0";
	soap_default_ns2__ShortDuration(soap, &this->ns2__Object::dwell);
	/* transient soap skipped */
}

void ns2__Object::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Coordinate_USCORE3D(soap, &this->ns2__Object::entry);
#endif
}

int ns2__Object::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Object(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Object(struct soap *soap, const char *tag, int id, const ns2__Object *a, const char *type)
{
	soap_set_attr(soap, "id", soap_unsignedInt2s(soap, ((ns2__Object*)a)->id), 1);
	if (((ns2__Object*)a)->objClass)
		soap_set_attr(soap, "objClass", soap_ns2__ObjectClassName2s(soap, *((ns2__Object*)a)->objClass), 2);
	soap_set_attr(soap, "zone", soap_std__wstring2s(soap, ((ns2__Object*)a)->zone), 2);
	soap_set_attr(soap, "dwell", soap_ns2__ShortDuration2s(soap, ((ns2__Object*)a)->dwell), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Object), type))
		return soap->error;
	if (!a->ns2__Object::entry)
	{	if (soap_element_nil(soap, "ns2:entry"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__Coordinate_USCORE3D(soap, "ns2:entry", -1, &a->ns2__Object::entry, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Object::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Object(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Object * SOAP_FMAC4 soap_in_ns2__Object(struct soap *soap, const char *tag, ns2__Object *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Object *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Object, sizeof(ns2__Object), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Object)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Object *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "id", 1), &((ns2__Object*)a)->id))
		return NULL;
	{	const char *t = soap_attr_value(soap, "objClass", 0);
		if (t)
		{
			if (!(((ns2__Object*)a)->objClass = soap_new_ns2__ObjectClassName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__ObjectClassName(soap, t, ((ns2__Object*)a)->objClass))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "zone", 0), &((ns2__Object*)a)->zone))
		return NULL;
	if (soap_s2ns2__ShortDuration(soap, soap_attr_value(soap, "dwell", 1), &((ns2__Object*)a)->dwell))
		return NULL;
	size_t soap_flag_entry1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Coordinate_USCORE3D(soap, "ns2:entry", &a->ns2__Object::entry, "ns2:Coordinate_3D"))
				{	soap_flag_entry1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__Object *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Object, SOAP_TYPE_ns2__Object, sizeof(ns2__Object), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Object * SOAP_FMAC2 soap_instantiate_ns2__Object(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Object(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:CurrentObject"))
		return soap_instantiate_ns2__CurrentObject(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:HistoricObject"))
		return soap_instantiate_ns2__HistoricObject(soap, n, NULL, NULL, size);
	ns2__Object *p;
	size_t k = sizeof(ns2__Object);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Object);
		if (p)
			((ns2__Object*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Object, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Object*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Object location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Object, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Object::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__Object(soap, tag ? tag : "ns2:Object", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Object::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Object(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Object * SOAP_FMAC4 soap_get_ns2__Object(struct soap *soap, ns2__Object *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Coordinate_USCORE3D::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Coordinate_USCORE2D::soap_default(soap);
	soap_default_int(soap, &this->ns2__Coordinate_USCORE3D::z);
}

void ns2__Coordinate_USCORE3D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__Coordinate_USCORE2D::soap_serialize(soap);
#endif
}

int ns2__Coordinate_USCORE3D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Coordinate_USCORE3D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Coordinate_USCORE3D(struct soap *soap, const char *tag, int id, const ns2__Coordinate_USCORE3D *a, const char *type)
{
	soap_set_attr(soap, "z", soap_int2s(soap, ((ns2__Coordinate_USCORE3D*)a)->z), 1);
	soap_set_attr(soap, "x", soap_int2s(soap, ((ns2__Coordinate_USCORE2D*)a)->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, ((ns2__Coordinate_USCORE2D*)a)->y), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Coordinate_USCORE3D), type ? type : "ns2:Coordinate_3D"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Coordinate_USCORE3D::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Coordinate_USCORE3D(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Coordinate_USCORE3D * SOAP_FMAC4 soap_in_ns2__Coordinate_USCORE3D(struct soap *soap, const char *tag, ns2__Coordinate_USCORE3D *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Coordinate_USCORE3D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Coordinate_USCORE3D, sizeof(ns2__Coordinate_USCORE3D), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Coordinate_USCORE3D)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Coordinate_USCORE3D *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "z", 1), &((ns2__Coordinate_USCORE3D*)a)->z))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "x", 1), &((ns2__Coordinate_USCORE2D*)a)->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 1), &((ns2__Coordinate_USCORE2D*)a)->y))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Coordinate_USCORE3D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Coordinate_USCORE3D, SOAP_TYPE_ns2__Coordinate_USCORE3D, sizeof(ns2__Coordinate_USCORE3D), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Coordinate_USCORE3D * SOAP_FMAC2 soap_instantiate_ns2__Coordinate_USCORE3D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Coordinate_USCORE3D(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Coordinate_USCORE3D *p;
	size_t k = sizeof(ns2__Coordinate_USCORE3D);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Coordinate_USCORE3D);
		if (p)
			((ns2__Coordinate_USCORE3D*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Coordinate_USCORE3D, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Coordinate_USCORE3D*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Coordinate_USCORE3D location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Coordinate_USCORE3D, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Coordinate_USCORE3D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__Coordinate_USCORE3D(soap, tag ? tag : "ns2:Coordinate_3D", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Coordinate_USCORE3D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Coordinate_USCORE3D(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Coordinate_USCORE3D * SOAP_FMAC4 soap_get_ns2__Coordinate_USCORE3D(struct soap *soap, ns2__Coordinate_USCORE3D *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Coordinate_USCORE3D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Coordinate_USCORE2D::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__Coordinate_USCORE2D::x);
	soap_default_int(soap, &this->ns2__Coordinate_USCORE2D::y);
	/* transient soap skipped */
}

void ns2__Coordinate_USCORE2D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__Coordinate_USCORE2D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Coordinate_USCORE2D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Coordinate_USCORE2D(struct soap *soap, const char *tag, int id, const ns2__Coordinate_USCORE2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_int2s(soap, ((ns2__Coordinate_USCORE2D*)a)->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, ((ns2__Coordinate_USCORE2D*)a)->y), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Coordinate_USCORE2D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Coordinate_USCORE2D::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Coordinate_USCORE2D(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Coordinate_USCORE2D * SOAP_FMAC4 soap_in_ns2__Coordinate_USCORE2D(struct soap *soap, const char *tag, ns2__Coordinate_USCORE2D *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Coordinate_USCORE2D *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Coordinate_USCORE2D, sizeof(ns2__Coordinate_USCORE2D), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Coordinate_USCORE2D)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Coordinate_USCORE2D *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "x", 1), &((ns2__Coordinate_USCORE2D*)a)->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 1), &((ns2__Coordinate_USCORE2D*)a)->y))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Coordinate_USCORE2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Coordinate_USCORE2D, SOAP_TYPE_ns2__Coordinate_USCORE2D, sizeof(ns2__Coordinate_USCORE2D), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Coordinate_USCORE2D * SOAP_FMAC2 soap_instantiate_ns2__Coordinate_USCORE2D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Coordinate_USCORE2D(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:Coordinate_3D"))
		return soap_instantiate_ns2__Coordinate_USCORE3D(soap, n, NULL, NULL, size);
	ns2__Coordinate_USCORE2D *p;
	size_t k = sizeof(ns2__Coordinate_USCORE2D);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Coordinate_USCORE2D);
		if (p)
			((ns2__Coordinate_USCORE2D*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Coordinate_USCORE2D, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Coordinate_USCORE2D*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Coordinate_USCORE2D location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Coordinate_USCORE2D, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Coordinate_USCORE2D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__Coordinate_USCORE2D(soap, tag ? tag : "ns2:Coordinate_2D", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Coordinate_USCORE2D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Coordinate_USCORE2D(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Coordinate_USCORE2D * SOAP_FMAC4 soap_get_ns2__Coordinate_USCORE2D(struct soap *soap, ns2__Coordinate_USCORE2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Coordinate_USCORE2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FeatureInfoNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ExtendedNotificationBase::soap_default(soap);
	this->ns2__FeatureInfoNotification::active_USCOREcount_USCOREchannels = NULL;
	this->ns2__FeatureInfoNotification::active_USCOREzone_USCOREchannels = NULL;
}

void ns2__FeatureInfoNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__CountChannelsFeatureInfo(soap, &this->ns2__FeatureInfoNotification::active_USCOREcount_USCOREchannels);
	soap_serialize_PointerTons2__ZoneChannelsFeatureInfo(soap, &this->ns2__FeatureInfoNotification::active_USCOREzone_USCOREchannels);
	this->ns2__ExtendedNotificationBase::soap_serialize(soap);
#endif
}

int ns2__FeatureInfoNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FeatureInfoNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FeatureInfoNotification(struct soap *soap, const char *tag, int id, const ns2__FeatureInfoNotification *a, const char *type)
{
	soap_set_attr(soap, "ip_address", soap_ns2__IP_USCOREAddress2s(soap, ((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress), 2);
	soap_set_attr(soap, "firmware_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion), 2);
	soap_set_attr(soap, "customer_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion), 2);
	if (((ns2__ExtendedNotificationBase*)a)->version)
		soap_set_attr(soap, "version", soap_xsd__decimal2s(soap, *((ns2__ExtendedNotificationBase*)a)->version), 2);
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FeatureInfoNotification), type ? type : "ns2:FeatureInfoNotification"))
		return soap->error;
	if (!a->ns2__FeatureInfoNotification::active_USCOREcount_USCOREchannels)
	{	if (soap_element_nil(soap, "ns2:active_count_channels"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__CountChannelsFeatureInfo(soap, "ns2:active_count_channels", -1, &a->ns2__FeatureInfoNotification::active_USCOREcount_USCOREchannels, ""))
		return soap->error;
	if (soap_out_PointerTons2__ZoneChannelsFeatureInfo(soap, "ns2:active_zone_channels", -1, &a->ns2__FeatureInfoNotification::active_USCOREzone_USCOREchannels, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FeatureInfoNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FeatureInfoNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FeatureInfoNotification * SOAP_FMAC4 soap_in_ns2__FeatureInfoNotification(struct soap *soap, const char *tag, ns2__FeatureInfoNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FeatureInfoNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FeatureInfoNotification, sizeof(ns2__FeatureInfoNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FeatureInfoNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FeatureInfoNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__IP_USCOREAddress(soap, soap_attr_value(soap, "ip_address", 1), &((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "firmware_version", 1), &((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_version", 1), &((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion))
		return NULL;
	{	const char *t = soap_attr_value(soap, "version", 0);
		if (t)
		{
			if (!(((ns2__ExtendedNotificationBase*)a)->version = soap_new_xsd__decimal(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__decimal(soap, t, ((ns2__ExtendedNotificationBase*)a)->version))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	size_t soap_flag_active_USCOREcount_USCOREchannels1 = 1;
	size_t soap_flag_active_USCOREzone_USCOREchannels1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_active_USCOREcount_USCOREchannels1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CountChannelsFeatureInfo(soap, "ns2:active_count_channels", &a->ns2__FeatureInfoNotification::active_USCOREcount_USCOREchannels, "ns2:CountChannelsFeatureInfo"))
				{	soap_flag_active_USCOREcount_USCOREchannels1--;
					continue;
				}
			if (soap_flag_active_USCOREzone_USCOREchannels1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ZoneChannelsFeatureInfo(soap, "ns2:active_zone_channels", &a->ns2__FeatureInfoNotification::active_USCOREzone_USCOREchannels, "ns2:ZoneChannelsFeatureInfo"))
				{	soap_flag_active_USCOREzone_USCOREchannels1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_active_USCOREcount_USCOREchannels1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__FeatureInfoNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FeatureInfoNotification, SOAP_TYPE_ns2__FeatureInfoNotification, sizeof(ns2__FeatureInfoNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FeatureInfoNotification * SOAP_FMAC2 soap_instantiate_ns2__FeatureInfoNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FeatureInfoNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FeatureInfoNotification *p;
	size_t k = sizeof(ns2__FeatureInfoNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FeatureInfoNotification);
		if (p)
			((ns2__FeatureInfoNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FeatureInfoNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FeatureInfoNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FeatureInfoNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FeatureInfoNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FeatureInfoNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__FeatureInfoNotification(soap, tag ? tag : "ns2:FeatureInfoNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FeatureInfoNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FeatureInfoNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FeatureInfoNotification * SOAP_FMAC4 soap_get_ns2__FeatureInfoNotification(struct soap *soap, ns2__FeatureInfoNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FeatureInfoNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ZoneChannelsFeatureInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ZoneChannelsFeatureInfo::__sizezone_USCOREchannel = 0;
	this->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel = NULL;
	/* transient soap skipped */
}

void ns2__ZoneChannelsFeatureInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel)
	{	int i;
		for (i = 0; i < (int)this->ns2__ZoneChannelsFeatureInfo::__sizezone_USCOREchannel; i++)
		{
			soap_serialize_PointerTons2__ZoneChannelFeatureInfo(soap, this->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel + i);
		}
	}
#endif
}

int ns2__ZoneChannelsFeatureInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ZoneChannelsFeatureInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ZoneChannelsFeatureInfo(struct soap *soap, const char *tag, int id, const ns2__ZoneChannelsFeatureInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ZoneChannelsFeatureInfo), type))
		return soap->error;
	if (a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel)
	{	int i;
		for (i = 0; i < (int)a->ns2__ZoneChannelsFeatureInfo::__sizezone_USCOREchannel; i++)
			if (soap_out_PointerTons2__ZoneChannelFeatureInfo(soap, "ns2:zone_channel", -1, a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__ZoneChannelsFeatureInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ZoneChannelsFeatureInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ZoneChannelsFeatureInfo * SOAP_FMAC4 soap_in_ns2__ZoneChannelsFeatureInfo(struct soap *soap, const char *tag, ns2__ZoneChannelsFeatureInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ZoneChannelsFeatureInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ZoneChannelsFeatureInfo, sizeof(ns2__ZoneChannelsFeatureInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ZoneChannelsFeatureInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ZoneChannelsFeatureInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist_zone_USCOREchannel1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:zone_channel", 1, NULL))
			{	if (a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel == NULL)
				{	if (soap_blist_zone_USCOREchannel1 == NULL)
						soap_blist_zone_USCOREchannel1 = soap_new_block(soap);
					a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel = (ns2__ZoneChannelFeatureInfo **)soap_push_block_max(soap, soap_blist_zone_USCOREchannel1, sizeof(ns2__ZoneChannelFeatureInfo *));
					if (a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel == NULL)
						return NULL;
					*a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__ZoneChannelFeatureInfo(soap, "ns2:zone_channel", a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel, "ns2:ZoneChannelFeatureInfo"))
				{	a->ns2__ZoneChannelsFeatureInfo::__sizezone_USCOREchannel++;
					a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel)
			soap_pop_block(soap, soap_blist_zone_USCOREchannel1);
		if (a->ns2__ZoneChannelsFeatureInfo::__sizezone_USCOREchannel)
		{	a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel = (ns2__ZoneChannelFeatureInfo **)soap_save_block(soap, soap_blist_zone_USCOREchannel1, NULL, 1);
		}
		else
		{	a->ns2__ZoneChannelsFeatureInfo::zone_USCOREchannel = NULL;
			if (soap_blist_zone_USCOREchannel1)
				soap_end_block(soap, soap_blist_zone_USCOREchannel1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ZoneChannelsFeatureInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ZoneChannelsFeatureInfo, SOAP_TYPE_ns2__ZoneChannelsFeatureInfo, sizeof(ns2__ZoneChannelsFeatureInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ZoneChannelsFeatureInfo * SOAP_FMAC2 soap_instantiate_ns2__ZoneChannelsFeatureInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ZoneChannelsFeatureInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ZoneChannelsFeatureInfo *p;
	size_t k = sizeof(ns2__ZoneChannelsFeatureInfo);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ZoneChannelsFeatureInfo);
		if (p)
			((ns2__ZoneChannelsFeatureInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ZoneChannelsFeatureInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ZoneChannelsFeatureInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ZoneChannelsFeatureInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ZoneChannelsFeatureInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ZoneChannelsFeatureInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ZoneChannelsFeatureInfo(soap, tag ? tag : "ns2:ZoneChannelsFeatureInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ZoneChannelsFeatureInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ZoneChannelsFeatureInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ZoneChannelsFeatureInfo * SOAP_FMAC4 soap_get_ns2__ZoneChannelsFeatureInfo(struct soap *soap, ns2__ZoneChannelsFeatureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ZoneChannelsFeatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ZoneChannelFeatureInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__MeasuringChannelName(soap, &this->ns2__ZoneChannelFeatureInfo::name);
	this->ns2__ZoneChannelFeatureInfo::objClass = NULL;
	/* transient soap skipped */
}

void ns2__ZoneChannelFeatureInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__ZoneChannelFeatureInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ZoneChannelFeatureInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ZoneChannelFeatureInfo(struct soap *soap, const char *tag, int id, const ns2__ZoneChannelFeatureInfo *a, const char *type)
{
	soap_set_attr(soap, "name", soap_ns2__MeasuringChannelName2s(soap, ((ns2__ZoneChannelFeatureInfo*)a)->name), 2);
	if (((ns2__ZoneChannelFeatureInfo*)a)->objClass)
		soap_set_attr(soap, "objClass", soap_ns2__ObjectClassName2s(soap, *((ns2__ZoneChannelFeatureInfo*)a)->objClass), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ZoneChannelFeatureInfo), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ZoneChannelFeatureInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ZoneChannelFeatureInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ZoneChannelFeatureInfo * SOAP_FMAC4 soap_in_ns2__ZoneChannelFeatureInfo(struct soap *soap, const char *tag, ns2__ZoneChannelFeatureInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ZoneChannelFeatureInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ZoneChannelFeatureInfo, sizeof(ns2__ZoneChannelFeatureInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ZoneChannelFeatureInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ZoneChannelFeatureInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__MeasuringChannelName(soap, soap_attr_value(soap, "name", 1), &((ns2__ZoneChannelFeatureInfo*)a)->name))
		return NULL;
	{	const char *t = soap_attr_value(soap, "objClass", 0);
		if (t)
		{
			if (!(((ns2__ZoneChannelFeatureInfo*)a)->objClass = soap_new_ns2__ObjectClassName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__ObjectClassName(soap, t, ((ns2__ZoneChannelFeatureInfo*)a)->objClass))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ZoneChannelFeatureInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ZoneChannelFeatureInfo, SOAP_TYPE_ns2__ZoneChannelFeatureInfo, sizeof(ns2__ZoneChannelFeatureInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ZoneChannelFeatureInfo * SOAP_FMAC2 soap_instantiate_ns2__ZoneChannelFeatureInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ZoneChannelFeatureInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ZoneChannelFeatureInfo *p;
	size_t k = sizeof(ns2__ZoneChannelFeatureInfo);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ZoneChannelFeatureInfo);
		if (p)
			((ns2__ZoneChannelFeatureInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ZoneChannelFeatureInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ZoneChannelFeatureInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ZoneChannelFeatureInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ZoneChannelFeatureInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ZoneChannelFeatureInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ZoneChannelFeatureInfo(soap, tag ? tag : "ns2:ZoneChannelFeatureInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ZoneChannelFeatureInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ZoneChannelFeatureInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ZoneChannelFeatureInfo * SOAP_FMAC4 soap_get_ns2__ZoneChannelFeatureInfo(struct soap *soap, ns2__ZoneChannelFeatureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ZoneChannelFeatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CountChannelsFeatureInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CountChannelsFeatureInfo::__sizecount_USCOREchannel = 0;
	this->ns2__CountChannelsFeatureInfo::count_USCOREchannel = NULL;
	/* transient soap skipped */
}

void ns2__CountChannelsFeatureInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__CountChannelsFeatureInfo::count_USCOREchannel)
	{	int i;
		for (i = 0; i < (int)this->ns2__CountChannelsFeatureInfo::__sizecount_USCOREchannel; i++)
		{
			soap_serialize_PointerTons2__CountChannelFeatureInfo(soap, this->ns2__CountChannelsFeatureInfo::count_USCOREchannel + i);
		}
	}
#endif
}

int ns2__CountChannelsFeatureInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CountChannelsFeatureInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CountChannelsFeatureInfo(struct soap *soap, const char *tag, int id, const ns2__CountChannelsFeatureInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CountChannelsFeatureInfo), type))
		return soap->error;
	if (a->ns2__CountChannelsFeatureInfo::count_USCOREchannel)
	{	int i;
		for (i = 0; i < (int)a->ns2__CountChannelsFeatureInfo::__sizecount_USCOREchannel; i++)
			if (soap_out_PointerTons2__CountChannelFeatureInfo(soap, "ns2:count_channel", -1, a->ns2__CountChannelsFeatureInfo::count_USCOREchannel + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__CountChannelsFeatureInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CountChannelsFeatureInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CountChannelsFeatureInfo * SOAP_FMAC4 soap_in_ns2__CountChannelsFeatureInfo(struct soap *soap, const char *tag, ns2__CountChannelsFeatureInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CountChannelsFeatureInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CountChannelsFeatureInfo, sizeof(ns2__CountChannelsFeatureInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CountChannelsFeatureInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CountChannelsFeatureInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist_count_USCOREchannel1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:count_channel", 1, NULL))
			{	if (a->ns2__CountChannelsFeatureInfo::count_USCOREchannel == NULL)
				{	if (soap_blist_count_USCOREchannel1 == NULL)
						soap_blist_count_USCOREchannel1 = soap_new_block(soap);
					a->ns2__CountChannelsFeatureInfo::count_USCOREchannel = (ns2__CountChannelFeatureInfo **)soap_push_block_max(soap, soap_blist_count_USCOREchannel1, sizeof(ns2__CountChannelFeatureInfo *));
					if (a->ns2__CountChannelsFeatureInfo::count_USCOREchannel == NULL)
						return NULL;
					*a->ns2__CountChannelsFeatureInfo::count_USCOREchannel = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__CountChannelFeatureInfo(soap, "ns2:count_channel", a->ns2__CountChannelsFeatureInfo::count_USCOREchannel, "ns2:CountChannelFeatureInfo"))
				{	a->ns2__CountChannelsFeatureInfo::__sizecount_USCOREchannel++;
					a->ns2__CountChannelsFeatureInfo::count_USCOREchannel = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__CountChannelsFeatureInfo::count_USCOREchannel)
			soap_pop_block(soap, soap_blist_count_USCOREchannel1);
		if (a->ns2__CountChannelsFeatureInfo::__sizecount_USCOREchannel)
		{	a->ns2__CountChannelsFeatureInfo::count_USCOREchannel = (ns2__CountChannelFeatureInfo **)soap_save_block(soap, soap_blist_count_USCOREchannel1, NULL, 1);
		}
		else
		{	a->ns2__CountChannelsFeatureInfo::count_USCOREchannel = NULL;
			if (soap_blist_count_USCOREchannel1)
				soap_end_block(soap, soap_blist_count_USCOREchannel1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CountChannelsFeatureInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CountChannelsFeatureInfo, SOAP_TYPE_ns2__CountChannelsFeatureInfo, sizeof(ns2__CountChannelsFeatureInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CountChannelsFeatureInfo * SOAP_FMAC2 soap_instantiate_ns2__CountChannelsFeatureInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CountChannelsFeatureInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CountChannelsFeatureInfo *p;
	size_t k = sizeof(ns2__CountChannelsFeatureInfo);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CountChannelsFeatureInfo);
		if (p)
			((ns2__CountChannelsFeatureInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CountChannelsFeatureInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CountChannelsFeatureInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CountChannelsFeatureInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CountChannelsFeatureInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CountChannelsFeatureInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CountChannelsFeatureInfo(soap, tag ? tag : "ns2:CountChannelsFeatureInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CountChannelsFeatureInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CountChannelsFeatureInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CountChannelsFeatureInfo * SOAP_FMAC4 soap_get_ns2__CountChannelsFeatureInfo(struct soap *soap, ns2__CountChannelsFeatureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CountChannelsFeatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CountChannelFeatureInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__MeasuringChannelName(soap, &this->ns2__CountChannelFeatureInfo::name);
	this->ns2__CountChannelFeatureInfo::objClass = NULL;
	/* transient soap skipped */
}

void ns2__CountChannelFeatureInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__CountChannelFeatureInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CountChannelFeatureInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CountChannelFeatureInfo(struct soap *soap, const char *tag, int id, const ns2__CountChannelFeatureInfo *a, const char *type)
{
	soap_set_attr(soap, "name", soap_ns2__MeasuringChannelName2s(soap, ((ns2__CountChannelFeatureInfo*)a)->name), 2);
	if (((ns2__CountChannelFeatureInfo*)a)->objClass)
		soap_set_attr(soap, "objClass", soap_ns2__ObjectClassName2s(soap, *((ns2__CountChannelFeatureInfo*)a)->objClass), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CountChannelFeatureInfo), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CountChannelFeatureInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CountChannelFeatureInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CountChannelFeatureInfo * SOAP_FMAC4 soap_in_ns2__CountChannelFeatureInfo(struct soap *soap, const char *tag, ns2__CountChannelFeatureInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CountChannelFeatureInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CountChannelFeatureInfo, sizeof(ns2__CountChannelFeatureInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CountChannelFeatureInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CountChannelFeatureInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__MeasuringChannelName(soap, soap_attr_value(soap, "name", 1), &((ns2__CountChannelFeatureInfo*)a)->name))
		return NULL;
	{	const char *t = soap_attr_value(soap, "objClass", 0);
		if (t)
		{
			if (!(((ns2__CountChannelFeatureInfo*)a)->objClass = soap_new_ns2__ObjectClassName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__ObjectClassName(soap, t, ((ns2__CountChannelFeatureInfo*)a)->objClass))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CountChannelFeatureInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CountChannelFeatureInfo, SOAP_TYPE_ns2__CountChannelFeatureInfo, sizeof(ns2__CountChannelFeatureInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CountChannelFeatureInfo * SOAP_FMAC2 soap_instantiate_ns2__CountChannelFeatureInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CountChannelFeatureInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CountChannelFeatureInfo *p;
	size_t k = sizeof(ns2__CountChannelFeatureInfo);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CountChannelFeatureInfo);
		if (p)
			((ns2__CountChannelFeatureInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CountChannelFeatureInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CountChannelFeatureInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CountChannelFeatureInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CountChannelFeatureInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CountChannelFeatureInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CountChannelFeatureInfo(soap, tag ? tag : "ns2:CountChannelFeatureInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CountChannelFeatureInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CountChannelFeatureInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CountChannelFeatureInfo * SOAP_FMAC4 soap_get_ns2__CountChannelFeatureInfo(struct soap *soap, ns2__CountChannelFeatureInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CountChannelFeatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__StartupNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ExtendedNotificationBase::soap_default(soap);
	soap_default_ns2__RebootType(soap, &this->ns2__StartupNotification::reboot_USCOREtype);
	soap_default_std__wstring(soap, &this->ns2__StartupNotification::xml_USCOREversion);
}

void ns2__StartupNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__ExtendedNotificationBase::soap_serialize(soap);
#endif
}

int ns2__StartupNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__StartupNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__StartupNotification(struct soap *soap, const char *tag, int id, const ns2__StartupNotification *a, const char *type)
{
	soap_set_attr(soap, "reboot_type", soap_ns2__RebootType2s(soap, ((ns2__StartupNotification*)a)->reboot_USCOREtype), 1);
	soap_set_attr(soap, "xml_version", soap_std__wstring2s(soap, ((ns2__StartupNotification*)a)->xml_USCOREversion), 2);
	soap_set_attr(soap, "ip_address", soap_ns2__IP_USCOREAddress2s(soap, ((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress), 2);
	soap_set_attr(soap, "firmware_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion), 2);
	soap_set_attr(soap, "customer_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion), 2);
	if (((ns2__ExtendedNotificationBase*)a)->version)
		soap_set_attr(soap, "version", soap_xsd__decimal2s(soap, *((ns2__ExtendedNotificationBase*)a)->version), 2);
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__StartupNotification), type ? type : "ns2:StartupNotification"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__StartupNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__StartupNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__StartupNotification * SOAP_FMAC4 soap_in_ns2__StartupNotification(struct soap *soap, const char *tag, ns2__StartupNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__StartupNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__StartupNotification, sizeof(ns2__StartupNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__StartupNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__StartupNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__RebootType(soap, soap_attr_value(soap, "reboot_type", 1), &((ns2__StartupNotification*)a)->reboot_USCOREtype))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "xml_version", 1), &((ns2__StartupNotification*)a)->xml_USCOREversion))
		return NULL;
	if (soap_s2ns2__IP_USCOREAddress(soap, soap_attr_value(soap, "ip_address", 1), &((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "firmware_version", 1), &((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_version", 1), &((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion))
		return NULL;
	{	const char *t = soap_attr_value(soap, "version", 0);
		if (t)
		{
			if (!(((ns2__ExtendedNotificationBase*)a)->version = soap_new_xsd__decimal(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__decimal(soap, t, ((ns2__ExtendedNotificationBase*)a)->version))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__StartupNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__StartupNotification, SOAP_TYPE_ns2__StartupNotification, sizeof(ns2__StartupNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__StartupNotification * SOAP_FMAC2 soap_instantiate_ns2__StartupNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__StartupNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__StartupNotification *p;
	size_t k = sizeof(ns2__StartupNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__StartupNotification);
		if (p)
			((ns2__StartupNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__StartupNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__StartupNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__StartupNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__StartupNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__StartupNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__StartupNotification(soap, tag ? tag : "ns2:StartupNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__StartupNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__StartupNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__StartupNotification * SOAP_FMAC4 soap_get_ns2__StartupNotification(struct soap *soap, ns2__StartupNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__StartupNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AliveNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ExtendedNotificationBase::soap_default(soap);
}

void ns2__AliveNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__ExtendedNotificationBase::soap_serialize(soap);
#endif
}

int ns2__AliveNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AliveNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AliveNotification(struct soap *soap, const char *tag, int id, const ns2__AliveNotification *a, const char *type)
{
	soap_set_attr(soap, "ip_address", soap_ns2__IP_USCOREAddress2s(soap, ((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress), 2);
	soap_set_attr(soap, "firmware_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion), 2);
	soap_set_attr(soap, "customer_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion), 2);
	if (((ns2__ExtendedNotificationBase*)a)->version)
		soap_set_attr(soap, "version", soap_xsd__decimal2s(soap, *((ns2__ExtendedNotificationBase*)a)->version), 2);
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AliveNotification), type ? type : "ns2:AliveNotification"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AliveNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AliveNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AliveNotification * SOAP_FMAC4 soap_in_ns2__AliveNotification(struct soap *soap, const char *tag, ns2__AliveNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AliveNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AliveNotification, sizeof(ns2__AliveNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AliveNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AliveNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__IP_USCOREAddress(soap, soap_attr_value(soap, "ip_address", 1), &((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "firmware_version", 1), &((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_version", 1), &((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion))
		return NULL;
	{	const char *t = soap_attr_value(soap, "version", 0);
		if (t)
		{
			if (!(((ns2__ExtendedNotificationBase*)a)->version = soap_new_xsd__decimal(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__decimal(soap, t, ((ns2__ExtendedNotificationBase*)a)->version))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AliveNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AliveNotification, SOAP_TYPE_ns2__AliveNotification, sizeof(ns2__AliveNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AliveNotification * SOAP_FMAC2 soap_instantiate_ns2__AliveNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AliveNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AliveNotification *p;
	size_t k = sizeof(ns2__AliveNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AliveNotification);
		if (p)
			((ns2__AliveNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AliveNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AliveNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AliveNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AliveNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AliveNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__AliveNotification(soap, tag ? tag : "ns2:AliveNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AliveNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AliveNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AliveNotification * SOAP_FMAC4 soap_get_ns2__AliveNotification(struct soap *soap, ns2__AliveNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AliveNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ErrorLogfilesNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ExtendedNotificationBase::soap_default(soap);
	this->ns2__ErrorLogfilesNotification::error_USCORElog_USCOREdata = NULL;
}

void ns2__ErrorLogfilesNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__BinaryData(soap, &this->ns2__ErrorLogfilesNotification::error_USCORElog_USCOREdata);
	this->ns2__ExtendedNotificationBase::soap_serialize(soap);
#endif
}

int ns2__ErrorLogfilesNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ErrorLogfilesNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ErrorLogfilesNotification(struct soap *soap, const char *tag, int id, const ns2__ErrorLogfilesNotification *a, const char *type)
{
	soap_set_attr(soap, "ip_address", soap_ns2__IP_USCOREAddress2s(soap, ((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress), 2);
	soap_set_attr(soap, "firmware_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion), 2);
	soap_set_attr(soap, "customer_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion), 2);
	if (((ns2__ExtendedNotificationBase*)a)->version)
		soap_set_attr(soap, "version", soap_xsd__decimal2s(soap, *((ns2__ExtendedNotificationBase*)a)->version), 2);
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ErrorLogfilesNotification), type ? type : "ns2:ErrorLogfilesNotification"))
		return soap->error;
	if (!a->ns2__ErrorLogfilesNotification::error_USCORElog_USCOREdata)
	{	if (soap_element_nil(soap, "ns2:error_log_data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__BinaryData(soap, "ns2:error_log_data", -1, &a->ns2__ErrorLogfilesNotification::error_USCORElog_USCOREdata, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ErrorLogfilesNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ErrorLogfilesNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ErrorLogfilesNotification * SOAP_FMAC4 soap_in_ns2__ErrorLogfilesNotification(struct soap *soap, const char *tag, ns2__ErrorLogfilesNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ErrorLogfilesNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ErrorLogfilesNotification, sizeof(ns2__ErrorLogfilesNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ErrorLogfilesNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ErrorLogfilesNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__IP_USCOREAddress(soap, soap_attr_value(soap, "ip_address", 1), &((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "firmware_version", 1), &((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_version", 1), &((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion))
		return NULL;
	{	const char *t = soap_attr_value(soap, "version", 0);
		if (t)
		{
			if (!(((ns2__ExtendedNotificationBase*)a)->version = soap_new_xsd__decimal(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__decimal(soap, t, ((ns2__ExtendedNotificationBase*)a)->version))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	size_t soap_flag_error_USCORElog_USCOREdata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error_USCORElog_USCOREdata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinaryData(soap, "ns2:error_log_data", &a->ns2__ErrorLogfilesNotification::error_USCORElog_USCOREdata, "ns2:BinaryData"))
				{	soap_flag_error_USCORElog_USCOREdata1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error_USCORElog_USCOREdata1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ErrorLogfilesNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ErrorLogfilesNotification, SOAP_TYPE_ns2__ErrorLogfilesNotification, sizeof(ns2__ErrorLogfilesNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ErrorLogfilesNotification * SOAP_FMAC2 soap_instantiate_ns2__ErrorLogfilesNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ErrorLogfilesNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ErrorLogfilesNotification *p;
	size_t k = sizeof(ns2__ErrorLogfilesNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ErrorLogfilesNotification);
		if (p)
			((ns2__ErrorLogfilesNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ErrorLogfilesNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ErrorLogfilesNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ErrorLogfilesNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ErrorLogfilesNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ErrorLogfilesNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ErrorLogfilesNotification(soap, tag ? tag : "ns2:ErrorLogfilesNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ErrorLogfilesNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ErrorLogfilesNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ErrorLogfilesNotification * SOAP_FMAC4 soap_get_ns2__ErrorLogfilesNotification(struct soap *soap, ns2__ErrorLogfilesNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ErrorLogfilesNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ParameterNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationBase::soap_default(soap);
	this->ns2__ParameterNotification::parameter_USCOREdata = NULL;
}

void ns2__ParameterNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__BinaryData(soap, &this->ns2__ParameterNotification::parameter_USCOREdata);
	this->ns2__NotificationBase::soap_serialize(soap);
#endif
}

int ns2__ParameterNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParameterNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParameterNotification(struct soap *soap, const char *tag, int id, const ns2__ParameterNotification *a, const char *type)
{
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParameterNotification), type ? type : "ns2:ParameterNotification"))
		return soap->error;
	if (!a->ns2__ParameterNotification::parameter_USCOREdata)
	{	if (soap_element_nil(soap, "ns2:parameter_data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__BinaryData(soap, "ns2:parameter_data", -1, &a->ns2__ParameterNotification::parameter_USCOREdata, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ParameterNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParameterNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParameterNotification * SOAP_FMAC4 soap_in_ns2__ParameterNotification(struct soap *soap, const char *tag, ns2__ParameterNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParameterNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParameterNotification, sizeof(ns2__ParameterNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ParameterNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ParameterNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	size_t soap_flag_parameter_USCOREdata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parameter_USCOREdata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinaryData(soap, "ns2:parameter_data", &a->ns2__ParameterNotification::parameter_USCOREdata, "ns2:BinaryData"))
				{	soap_flag_parameter_USCOREdata1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parameter_USCOREdata1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ParameterNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParameterNotification, SOAP_TYPE_ns2__ParameterNotification, sizeof(ns2__ParameterNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ParameterNotification * SOAP_FMAC2 soap_instantiate_ns2__ParameterNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParameterNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ParameterNotification *p;
	size_t k = sizeof(ns2__ParameterNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ParameterNotification);
		if (p)
			((ns2__ParameterNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ParameterNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ParameterNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ParameterNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ParameterNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ParameterNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ParameterNotification(soap, tag ? tag : "ns2:ParameterNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParameterNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParameterNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParameterNotification * SOAP_FMAC4 soap_get_ns2__ParameterNotification(struct soap *soap, ns2__ParameterNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParameterNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__LogfilesNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationBase::soap_default(soap);
	this->ns2__LogfilesNotification::log_USCOREdata = NULL;
}

void ns2__LogfilesNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__BinaryData(soap, &this->ns2__LogfilesNotification::log_USCOREdata);
	this->ns2__NotificationBase::soap_serialize(soap);
#endif
}

int ns2__LogfilesNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LogfilesNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LogfilesNotification(struct soap *soap, const char *tag, int id, const ns2__LogfilesNotification *a, const char *type)
{
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LogfilesNotification), type ? type : "ns2:LogfilesNotification"))
		return soap->error;
	if (!a->ns2__LogfilesNotification::log_USCOREdata)
	{	if (soap_element_nil(soap, "ns2:log_data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__BinaryData(soap, "ns2:log_data", -1, &a->ns2__LogfilesNotification::log_USCOREdata, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__LogfilesNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LogfilesNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LogfilesNotification * SOAP_FMAC4 soap_in_ns2__LogfilesNotification(struct soap *soap, const char *tag, ns2__LogfilesNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LogfilesNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LogfilesNotification, sizeof(ns2__LogfilesNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__LogfilesNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__LogfilesNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	size_t soap_flag_log_USCOREdata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_log_USCOREdata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinaryData(soap, "ns2:log_data", &a->ns2__LogfilesNotification::log_USCOREdata, "ns2:BinaryData"))
				{	soap_flag_log_USCOREdata1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_log_USCOREdata1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__LogfilesNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LogfilesNotification, SOAP_TYPE_ns2__LogfilesNotification, sizeof(ns2__LogfilesNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__LogfilesNotification * SOAP_FMAC2 soap_instantiate_ns2__LogfilesNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LogfilesNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__LogfilesNotification *p;
	size_t k = sizeof(ns2__LogfilesNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__LogfilesNotification);
		if (p)
			((ns2__LogfilesNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__LogfilesNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__LogfilesNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__LogfilesNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__LogfilesNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__LogfilesNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__LogfilesNotification(soap, tag ? tag : "ns2:LogfilesNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LogfilesNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LogfilesNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LogfilesNotification * SOAP_FMAC4 soap_get_ns2__LogfilesNotification(struct soap *soap, ns2__LogfilesNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LogfilesNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CameraImagesNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationWithOSDState::soap_default(soap);
	this->ns2__CameraImagesNotification::camera_USCOREimages = NULL;
	this->ns2__CameraImagesNotification::eval_USCOREmap = NULL;
}

void ns2__CameraImagesNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__BinaryData(soap, &this->ns2__CameraImagesNotification::camera_USCOREimages);
	soap_serialize_PointerTons2__BinaryData(soap, &this->ns2__CameraImagesNotification::eval_USCOREmap);
	this->ns2__NotificationWithOSDState::soap_serialize(soap);
#endif
}

int ns2__CameraImagesNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CameraImagesNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CameraImagesNotification(struct soap *soap, const char *tag, int id, const ns2__CameraImagesNotification *a, const char *type)
{
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CameraImagesNotification), type ? type : "ns2:CameraImagesNotification"))
		return soap->error;
	if (!a->ns2__CameraImagesNotification::camera_USCOREimages)
	{	if (soap_element_nil(soap, "ns2:camera_images"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__BinaryData(soap, "ns2:camera_images", -1, &a->ns2__CameraImagesNotification::camera_USCOREimages, ""))
		return soap->error;
	if (!a->ns2__CameraImagesNotification::eval_USCOREmap)
	{	if (soap_element_nil(soap, "ns2:eval_map"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__BinaryData(soap, "ns2:eval_map", -1, &a->ns2__CameraImagesNotification::eval_USCOREmap, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CameraImagesNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CameraImagesNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CameraImagesNotification * SOAP_FMAC4 soap_in_ns2__CameraImagesNotification(struct soap *soap, const char *tag, ns2__CameraImagesNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CameraImagesNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CameraImagesNotification, sizeof(ns2__CameraImagesNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CameraImagesNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CameraImagesNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	size_t soap_flag_camera_USCOREimages1 = 1;
	size_t soap_flag_eval_USCOREmap1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_camera_USCOREimages1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinaryData(soap, "ns2:camera_images", &a->ns2__CameraImagesNotification::camera_USCOREimages, "ns2:BinaryData"))
				{	soap_flag_camera_USCOREimages1--;
					continue;
				}
			if (soap_flag_eval_USCOREmap1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinaryData(soap, "ns2:eval_map", &a->ns2__CameraImagesNotification::eval_USCOREmap, "ns2:BinaryData"))
				{	soap_flag_eval_USCOREmap1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_camera_USCOREimages1 > 0 || soap_flag_eval_USCOREmap1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CameraImagesNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CameraImagesNotification, SOAP_TYPE_ns2__CameraImagesNotification, sizeof(ns2__CameraImagesNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CameraImagesNotification * SOAP_FMAC2 soap_instantiate_ns2__CameraImagesNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CameraImagesNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CameraImagesNotification *p;
	size_t k = sizeof(ns2__CameraImagesNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CameraImagesNotification);
		if (p)
			((ns2__CameraImagesNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CameraImagesNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CameraImagesNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CameraImagesNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CameraImagesNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CameraImagesNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CameraImagesNotification(soap, tag ? tag : "ns2:CameraImagesNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CameraImagesNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CameraImagesNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CameraImagesNotification * SOAP_FMAC4 soap_get_ns2__CameraImagesNotification(struct soap *soap, ns2__CameraImagesNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CameraImagesNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ClearZoneNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationWithOSDState::soap_default(soap);
	this->ns2__ClearZoneNotification::clear_USCOREzone_USCOREid = NULL;
	soap_default_bool(soap, &this->ns2__ClearZoneNotification::is_USCOREblocked);
}

void ns2__ClearZoneNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__ClearZoneID(soap, &this->ns2__ClearZoneNotification::clear_USCOREzone_USCOREid);
	this->ns2__NotificationWithOSDState::soap_serialize(soap);
#endif
}

int ns2__ClearZoneNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ClearZoneNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ClearZoneNotification(struct soap *soap, const char *tag, int id, const ns2__ClearZoneNotification *a, const char *type)
{
	soap_set_attr(soap, "is_blocked", soap_bool2s(soap, ((ns2__ClearZoneNotification*)a)->is_USCOREblocked), 1);
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ClearZoneNotification), type ? type : "ns2:ClearZoneNotification"))
		return soap->error;
	if (!a->ns2__ClearZoneNotification::clear_USCOREzone_USCOREid)
	{	if (soap_element_nil(soap, "ns2:clear_zone_id"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__ClearZoneID(soap, "ns2:clear_zone_id", -1, &a->ns2__ClearZoneNotification::clear_USCOREzone_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ClearZoneNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ClearZoneNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ClearZoneNotification * SOAP_FMAC4 soap_in_ns2__ClearZoneNotification(struct soap *soap, const char *tag, ns2__ClearZoneNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ClearZoneNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ClearZoneNotification, sizeof(ns2__ClearZoneNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ClearZoneNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ClearZoneNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "is_blocked", 1), &((ns2__ClearZoneNotification*)a)->is_USCOREblocked))
		return NULL;
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	size_t soap_flag_clear_USCOREzone_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clear_USCOREzone_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ClearZoneID(soap, "ns2:clear_zone_id", &a->ns2__ClearZoneNotification::clear_USCOREzone_USCOREid, "ns2:ClearZoneID"))
				{	soap_flag_clear_USCOREzone_USCOREid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_clear_USCOREzone_USCOREid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ClearZoneNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ClearZoneNotification, SOAP_TYPE_ns2__ClearZoneNotification, sizeof(ns2__ClearZoneNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ClearZoneNotification * SOAP_FMAC2 soap_instantiate_ns2__ClearZoneNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ClearZoneNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ClearZoneNotification *p;
	size_t k = sizeof(ns2__ClearZoneNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ClearZoneNotification);
		if (p)
			((ns2__ClearZoneNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ClearZoneNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ClearZoneNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ClearZoneNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ClearZoneNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ClearZoneNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ClearZoneNotification(soap, tag ? tag : "ns2:ClearZoneNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ClearZoneNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ClearZoneNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ClearZoneNotification * SOAP_FMAC4 soap_get_ns2__ClearZoneNotification(struct soap *soap, ns2__ClearZoneNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ClearZoneNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DigitalInputNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationBase::soap_default(soap);
	this->ns2__DigitalInputNotification::__sizedigital_USCOREinput_USCOREport = 0;
	this->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport = NULL;
}

void ns2__DigitalInputNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport)
	{	int i;
		for (i = 0; i < (int)this->ns2__DigitalInputNotification::__sizedigital_USCOREinput_USCOREport; i++)
		{
			soap_serialize_PointerTons2__DigitalInputElement(soap, this->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport + i);
		}
	}
	this->ns2__NotificationBase::soap_serialize(soap);
#endif
}

int ns2__DigitalInputNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DigitalInputNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DigitalInputNotification(struct soap *soap, const char *tag, int id, const ns2__DigitalInputNotification *a, const char *type)
{
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DigitalInputNotification), type ? type : "ns2:DigitalInputNotification"))
		return soap->error;
	if (a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport)
	{	int i;
		for (i = 0; i < (int)a->ns2__DigitalInputNotification::__sizedigital_USCOREinput_USCOREport; i++)
			if (soap_out_PointerTons2__DigitalInputElement(soap, "ns2:digital_input_port", -1, a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__DigitalInputNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DigitalInputNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DigitalInputNotification * SOAP_FMAC4 soap_in_ns2__DigitalInputNotification(struct soap *soap, const char *tag, ns2__DigitalInputNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DigitalInputNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DigitalInputNotification, sizeof(ns2__DigitalInputNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DigitalInputNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DigitalInputNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	struct soap_blist *soap_blist_digital_USCOREinput_USCOREport1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:digital_input_port", 1, NULL))
			{	if (a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport == NULL)
				{	if (soap_blist_digital_USCOREinput_USCOREport1 == NULL)
						soap_blist_digital_USCOREinput_USCOREport1 = soap_new_block(soap);
					a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport = (ns2__DigitalInputElement **)soap_push_block_max(soap, soap_blist_digital_USCOREinput_USCOREport1, sizeof(ns2__DigitalInputElement *));
					if (a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport == NULL)
						return NULL;
					*a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__DigitalInputElement(soap, "ns2:digital_input_port", a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport, "ns2:DigitalInputElement"))
				{	a->ns2__DigitalInputNotification::__sizedigital_USCOREinput_USCOREport++;
					a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport)
			soap_pop_block(soap, soap_blist_digital_USCOREinput_USCOREport1);
		if (a->ns2__DigitalInputNotification::__sizedigital_USCOREinput_USCOREport)
		{	a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport = (ns2__DigitalInputElement **)soap_save_block(soap, soap_blist_digital_USCOREinput_USCOREport1, NULL, 1);
		}
		else
		{	a->ns2__DigitalInputNotification::digital_USCOREinput_USCOREport = NULL;
			if (soap_blist_digital_USCOREinput_USCOREport1)
				soap_end_block(soap, soap_blist_digital_USCOREinput_USCOREport1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__DigitalInputNotification::__sizedigital_USCOREinput_USCOREport < 1 || a->ns2__DigitalInputNotification::__sizedigital_USCOREinput_USCOREport > 16))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__DigitalInputNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DigitalInputNotification, SOAP_TYPE_ns2__DigitalInputNotification, sizeof(ns2__DigitalInputNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DigitalInputNotification * SOAP_FMAC2 soap_instantiate_ns2__DigitalInputNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DigitalInputNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DigitalInputNotification *p;
	size_t k = sizeof(ns2__DigitalInputNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DigitalInputNotification);
		if (p)
			((ns2__DigitalInputNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DigitalInputNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DigitalInputNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DigitalInputNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DigitalInputNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DigitalInputNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__DigitalInputNotification(soap, tag ? tag : "ns2:DigitalInputNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DigitalInputNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DigitalInputNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DigitalInputNotification * SOAP_FMAC4 soap_get_ns2__DigitalInputNotification(struct soap *soap, ns2__DigitalInputNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DigitalInputNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FillNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationWithOSDState::soap_default(soap);
	this->ns2__FillNotification::fill_USCOREregion_USCOREid = NULL;
	soap_default_unsignedInt(soap, &this->ns2__FillNotification::fill_USCORElevel);
}

void ns2__FillNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__FillRegionID(soap, &this->ns2__FillNotification::fill_USCOREregion_USCOREid);
	this->ns2__NotificationWithOSDState::soap_serialize(soap);
#endif
}

int ns2__FillNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FillNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FillNotification(struct soap *soap, const char *tag, int id, const ns2__FillNotification *a, const char *type)
{
	soap_set_attr(soap, "fill_level", soap_unsignedInt2s(soap, ((ns2__FillNotification*)a)->fill_USCORElevel), 1);
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FillNotification), type ? type : "ns2:FillNotification"))
		return soap->error;
	if (!a->ns2__FillNotification::fill_USCOREregion_USCOREid)
	{	if (soap_element_nil(soap, "ns2:fill_region_id"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__FillRegionID(soap, "ns2:fill_region_id", -1, &a->ns2__FillNotification::fill_USCOREregion_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FillNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FillNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FillNotification * SOAP_FMAC4 soap_in_ns2__FillNotification(struct soap *soap, const char *tag, ns2__FillNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FillNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FillNotification, sizeof(ns2__FillNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FillNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FillNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "fill_level", 1), &((ns2__FillNotification*)a)->fill_USCORElevel))
		return NULL;
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	size_t soap_flag_fill_USCOREregion_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fill_USCOREregion_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FillRegionID(soap, "ns2:fill_region_id", &a->ns2__FillNotification::fill_USCOREregion_USCOREid, "ns2:FillRegionID"))
				{	soap_flag_fill_USCOREregion_USCOREid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fill_USCOREregion_USCOREid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__FillNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FillNotification, SOAP_TYPE_ns2__FillNotification, sizeof(ns2__FillNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FillNotification * SOAP_FMAC2 soap_instantiate_ns2__FillNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FillNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FillNotification *p;
	size_t k = sizeof(ns2__FillNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FillNotification);
		if (p)
			((ns2__FillNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FillNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FillNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FillNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FillNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FillNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__FillNotification(soap, tag ? tag : "ns2:FillNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FillNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FillNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FillNotification * SOAP_FMAC4 soap_get_ns2__FillNotification(struct soap *soap, ns2__FillNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FillNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ZoneChannelsNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationWithOSDState::soap_default(soap);
	this->ns2__ZoneChannelsNotification::__sizezone_USCOREchannel = 0;
	this->ns2__ZoneChannelsNotification::zone_USCOREchannel = NULL;
}

void ns2__ZoneChannelsNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__ZoneChannelsNotification::zone_USCOREchannel)
	{	int i;
		for (i = 0; i < (int)this->ns2__ZoneChannelsNotification::__sizezone_USCOREchannel; i++)
		{
			soap_serialize_PointerTons2__ZoneData(soap, this->ns2__ZoneChannelsNotification::zone_USCOREchannel + i);
		}
	}
	this->ns2__NotificationWithOSDState::soap_serialize(soap);
#endif
}

int ns2__ZoneChannelsNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ZoneChannelsNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ZoneChannelsNotification(struct soap *soap, const char *tag, int id, const ns2__ZoneChannelsNotification *a, const char *type)
{
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ZoneChannelsNotification), type ? type : "ns2:ZoneChannelsNotification"))
		return soap->error;
	if (a->ns2__ZoneChannelsNotification::zone_USCOREchannel)
	{	int i;
		for (i = 0; i < (int)a->ns2__ZoneChannelsNotification::__sizezone_USCOREchannel; i++)
			if (soap_out_PointerTons2__ZoneData(soap, "ns2:zone_channel", -1, a->ns2__ZoneChannelsNotification::zone_USCOREchannel + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__ZoneChannelsNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ZoneChannelsNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ZoneChannelsNotification * SOAP_FMAC4 soap_in_ns2__ZoneChannelsNotification(struct soap *soap, const char *tag, ns2__ZoneChannelsNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ZoneChannelsNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ZoneChannelsNotification, sizeof(ns2__ZoneChannelsNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ZoneChannelsNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ZoneChannelsNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	struct soap_blist *soap_blist_zone_USCOREchannel1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:zone_channel", 1, NULL))
			{	if (a->ns2__ZoneChannelsNotification::zone_USCOREchannel == NULL)
				{	if (soap_blist_zone_USCOREchannel1 == NULL)
						soap_blist_zone_USCOREchannel1 = soap_new_block(soap);
					a->ns2__ZoneChannelsNotification::zone_USCOREchannel = (ns2__ZoneData **)soap_push_block_max(soap, soap_blist_zone_USCOREchannel1, sizeof(ns2__ZoneData *));
					if (a->ns2__ZoneChannelsNotification::zone_USCOREchannel == NULL)
						return NULL;
					*a->ns2__ZoneChannelsNotification::zone_USCOREchannel = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__ZoneData(soap, "ns2:zone_channel", a->ns2__ZoneChannelsNotification::zone_USCOREchannel, "ns2:ZoneData"))
				{	a->ns2__ZoneChannelsNotification::__sizezone_USCOREchannel++;
					a->ns2__ZoneChannelsNotification::zone_USCOREchannel = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__ZoneChannelsNotification::zone_USCOREchannel)
			soap_pop_block(soap, soap_blist_zone_USCOREchannel1);
		if (a->ns2__ZoneChannelsNotification::__sizezone_USCOREchannel)
		{	a->ns2__ZoneChannelsNotification::zone_USCOREchannel = (ns2__ZoneData **)soap_save_block(soap, soap_blist_zone_USCOREchannel1, NULL, 1);
		}
		else
		{	a->ns2__ZoneChannelsNotification::zone_USCOREchannel = NULL;
			if (soap_blist_zone_USCOREchannel1)
				soap_end_block(soap, soap_blist_zone_USCOREchannel1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ZoneChannelsNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ZoneChannelsNotification, SOAP_TYPE_ns2__ZoneChannelsNotification, sizeof(ns2__ZoneChannelsNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ZoneChannelsNotification * SOAP_FMAC2 soap_instantiate_ns2__ZoneChannelsNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ZoneChannelsNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ZoneChannelsNotification *p;
	size_t k = sizeof(ns2__ZoneChannelsNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ZoneChannelsNotification);
		if (p)
			((ns2__ZoneChannelsNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ZoneChannelsNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ZoneChannelsNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ZoneChannelsNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ZoneChannelsNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ZoneChannelsNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ZoneChannelsNotification(soap, tag ? tag : "ns2:ZoneChannelsNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ZoneChannelsNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ZoneChannelsNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ZoneChannelsNotification * SOAP_FMAC4 soap_get_ns2__ZoneChannelsNotification(struct soap *soap, ns2__ZoneChannelsNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ZoneChannelsNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ZoneData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ZoneData::zone_USCOREname = NULL;
	this->ns2__ZoneData::objClass = NULL;
	soap_default_unsignedInt(soap, &this->ns2__ZoneData::fill_USCORElevel);
	/* transient soap skipped */
}

void ns2__ZoneData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__ZoneData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ZoneData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ZoneData(struct soap *soap, const char *tag, int id, const ns2__ZoneData *a, const char *type)
{
	if (((ns2__ZoneData*)a)->zone_USCOREname)
		soap_set_attr(soap, "zone_name", soap_ns2__MeasuringChannelName2s(soap, *((ns2__ZoneData*)a)->zone_USCOREname), 2);
	if (((ns2__ZoneData*)a)->objClass)
		soap_set_attr(soap, "objClass", soap_ns2__ObjectClassName2s(soap, *((ns2__ZoneData*)a)->objClass), 2);
	soap_set_attr(soap, "fill_level", soap_unsignedInt2s(soap, ((ns2__ZoneData*)a)->fill_USCORElevel), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ZoneData), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ZoneData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ZoneData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ZoneData * SOAP_FMAC4 soap_in_ns2__ZoneData(struct soap *soap, const char *tag, ns2__ZoneData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ZoneData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ZoneData, sizeof(ns2__ZoneData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ZoneData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ZoneData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "zone_name", 0);
		if (t)
		{
			if (!(((ns2__ZoneData*)a)->zone_USCOREname = soap_new_ns2__MeasuringChannelName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__MeasuringChannelName(soap, t, ((ns2__ZoneData*)a)->zone_USCOREname))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "objClass", 0);
		if (t)
		{
			if (!(((ns2__ZoneData*)a)->objClass = soap_new_ns2__ObjectClassName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__ObjectClassName(soap, t, ((ns2__ZoneData*)a)->objClass))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "fill_level", 1), &((ns2__ZoneData*)a)->fill_USCORElevel))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ZoneData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ZoneData, SOAP_TYPE_ns2__ZoneData, sizeof(ns2__ZoneData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ZoneData * SOAP_FMAC2 soap_instantiate_ns2__ZoneData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ZoneData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ZoneData *p;
	size_t k = sizeof(ns2__ZoneData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ZoneData);
		if (p)
			((ns2__ZoneData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ZoneData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ZoneData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ZoneData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ZoneData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ZoneData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ZoneData(soap, tag ? tag : "ns2:ZoneData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ZoneData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ZoneData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ZoneData * SOAP_FMAC4 soap_get_ns2__ZoneData(struct soap *soap, ns2__ZoneData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ZoneData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CountChannelsNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationWithOSDState::soap_default(soap);
	this->ns2__CountChannelsNotification::__sizecount_USCOREchannel = 0;
	this->ns2__CountChannelsNotification::count_USCOREchannel = NULL;
}

void ns2__CountChannelsNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__CountChannelsNotification::count_USCOREchannel)
	{	int i;
		for (i = 0; i < (int)this->ns2__CountChannelsNotification::__sizecount_USCOREchannel; i++)
		{
			soap_serialize_PointerTons2__CountChannelData(soap, this->ns2__CountChannelsNotification::count_USCOREchannel + i);
		}
	}
	this->ns2__NotificationWithOSDState::soap_serialize(soap);
#endif
}

int ns2__CountChannelsNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CountChannelsNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CountChannelsNotification(struct soap *soap, const char *tag, int id, const ns2__CountChannelsNotification *a, const char *type)
{
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CountChannelsNotification), type ? type : "ns2:CountChannelsNotification"))
		return soap->error;
	if (a->ns2__CountChannelsNotification::count_USCOREchannel)
	{	int i;
		for (i = 0; i < (int)a->ns2__CountChannelsNotification::__sizecount_USCOREchannel; i++)
			if (soap_out_PointerTons2__CountChannelData(soap, "ns2:count_channel", -1, a->ns2__CountChannelsNotification::count_USCOREchannel + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__CountChannelsNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CountChannelsNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CountChannelsNotification * SOAP_FMAC4 soap_in_ns2__CountChannelsNotification(struct soap *soap, const char *tag, ns2__CountChannelsNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CountChannelsNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CountChannelsNotification, sizeof(ns2__CountChannelsNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CountChannelsNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CountChannelsNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	struct soap_blist *soap_blist_count_USCOREchannel1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:count_channel", 1, NULL))
			{	if (a->ns2__CountChannelsNotification::count_USCOREchannel == NULL)
				{	if (soap_blist_count_USCOREchannel1 == NULL)
						soap_blist_count_USCOREchannel1 = soap_new_block(soap);
					a->ns2__CountChannelsNotification::count_USCOREchannel = (ns2__CountChannelData **)soap_push_block_max(soap, soap_blist_count_USCOREchannel1, sizeof(ns2__CountChannelData *));
					if (a->ns2__CountChannelsNotification::count_USCOREchannel == NULL)
						return NULL;
					*a->ns2__CountChannelsNotification::count_USCOREchannel = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__CountChannelData(soap, "ns2:count_channel", a->ns2__CountChannelsNotification::count_USCOREchannel, "ns2:CountChannelData"))
				{	a->ns2__CountChannelsNotification::__sizecount_USCOREchannel++;
					a->ns2__CountChannelsNotification::count_USCOREchannel = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__CountChannelsNotification::count_USCOREchannel)
			soap_pop_block(soap, soap_blist_count_USCOREchannel1);
		if (a->ns2__CountChannelsNotification::__sizecount_USCOREchannel)
		{	a->ns2__CountChannelsNotification::count_USCOREchannel = (ns2__CountChannelData **)soap_save_block(soap, soap_blist_count_USCOREchannel1, NULL, 1);
		}
		else
		{	a->ns2__CountChannelsNotification::count_USCOREchannel = NULL;
			if (soap_blist_count_USCOREchannel1)
				soap_end_block(soap, soap_blist_count_USCOREchannel1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CountChannelsNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CountChannelsNotification, SOAP_TYPE_ns2__CountChannelsNotification, sizeof(ns2__CountChannelsNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CountChannelsNotification * SOAP_FMAC2 soap_instantiate_ns2__CountChannelsNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CountChannelsNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CountChannelsNotification *p;
	size_t k = sizeof(ns2__CountChannelsNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CountChannelsNotification);
		if (p)
			((ns2__CountChannelsNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CountChannelsNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CountChannelsNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CountChannelsNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CountChannelsNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CountChannelsNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CountChannelsNotification(soap, tag ? tag : "ns2:CountChannelsNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CountChannelsNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CountChannelsNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CountChannelsNotification * SOAP_FMAC4 soap_get_ns2__CountChannelsNotification(struct soap *soap, ns2__CountChannelsNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CountChannelsNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CountChannelData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CountChannelData::channel_USCOREname = NULL;
	this->ns2__CountChannelData::objClass = NULL;
	soap_default_unsignedInt(soap, &this->ns2__CountChannelData::count_USCOREin);
	soap_default_unsignedInt(soap, &this->ns2__CountChannelData::count_USCOREout);
	/* transient soap skipped */
}

void ns2__CountChannelData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__CountChannelData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CountChannelData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CountChannelData(struct soap *soap, const char *tag, int id, const ns2__CountChannelData *a, const char *type)
{
	if (((ns2__CountChannelData*)a)->channel_USCOREname)
		soap_set_attr(soap, "channel_name", soap_ns2__MeasuringChannelName2s(soap, *((ns2__CountChannelData*)a)->channel_USCOREname), 2);
	if (((ns2__CountChannelData*)a)->objClass)
		soap_set_attr(soap, "objClass", soap_ns2__ObjectClassName2s(soap, *((ns2__CountChannelData*)a)->objClass), 2);
	soap_set_attr(soap, "count_in", soap_unsignedInt2s(soap, ((ns2__CountChannelData*)a)->count_USCOREin), 1);
	soap_set_attr(soap, "count_out", soap_unsignedInt2s(soap, ((ns2__CountChannelData*)a)->count_USCOREout), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CountChannelData), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CountChannelData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CountChannelData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CountChannelData * SOAP_FMAC4 soap_in_ns2__CountChannelData(struct soap *soap, const char *tag, ns2__CountChannelData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CountChannelData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CountChannelData, sizeof(ns2__CountChannelData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CountChannelData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CountChannelData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "channel_name", 0);
		if (t)
		{
			if (!(((ns2__CountChannelData*)a)->channel_USCOREname = soap_new_ns2__MeasuringChannelName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__MeasuringChannelName(soap, t, ((ns2__CountChannelData*)a)->channel_USCOREname))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "objClass", 0);
		if (t)
		{
			if (!(((ns2__CountChannelData*)a)->objClass = soap_new_ns2__ObjectClassName(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__ObjectClassName(soap, t, ((ns2__CountChannelData*)a)->objClass))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "count_in", 1), &((ns2__CountChannelData*)a)->count_USCOREin))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "count_out", 1), &((ns2__CountChannelData*)a)->count_USCOREout))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CountChannelData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CountChannelData, SOAP_TYPE_ns2__CountChannelData, sizeof(ns2__CountChannelData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CountChannelData * SOAP_FMAC2 soap_instantiate_ns2__CountChannelData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CountChannelData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CountChannelData *p;
	size_t k = sizeof(ns2__CountChannelData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CountChannelData);
		if (p)
			((ns2__CountChannelData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CountChannelData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CountChannelData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CountChannelData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CountChannelData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CountChannelData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CountChannelData(soap, tag ? tag : "ns2:CountChannelData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CountChannelData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CountChannelData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CountChannelData * SOAP_FMAC4 soap_get_ns2__CountChannelData(struct soap *soap, ns2__CountChannelData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CountChannelData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CountNotification::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationWithOSDState::soap_default(soap);
	this->ns2__CountNotification::counting_USCOREgate_USCOREid = NULL;
	soap_default_unsignedInt(soap, &this->ns2__CountNotification::count_USCOREin);
	soap_default_unsignedInt(soap, &this->ns2__CountNotification::count_USCOREout);
}

void ns2__CountNotification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__CountingGateID(soap, &this->ns2__CountNotification::counting_USCOREgate_USCOREid);
	this->ns2__NotificationWithOSDState::soap_serialize(soap);
#endif
}

int ns2__CountNotification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CountNotification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CountNotification(struct soap *soap, const char *tag, int id, const ns2__CountNotification *a, const char *type)
{
	soap_set_attr(soap, "count_in", soap_unsignedInt2s(soap, ((ns2__CountNotification*)a)->count_USCOREin), 1);
	soap_set_attr(soap, "count_out", soap_unsignedInt2s(soap, ((ns2__CountNotification*)a)->count_USCOREout), 1);
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CountNotification), type ? type : "ns2:CountNotification"))
		return soap->error;
	if (!a->ns2__CountNotification::counting_USCOREgate_USCOREid)
	{	if (soap_element_nil(soap, "ns2:counting_gate_id"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__CountingGateID(soap, "ns2:counting_gate_id", -1, &a->ns2__CountNotification::counting_USCOREgate_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CountNotification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CountNotification(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CountNotification * SOAP_FMAC4 soap_in_ns2__CountNotification(struct soap *soap, const char *tag, ns2__CountNotification *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CountNotification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CountNotification, sizeof(ns2__CountNotification), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CountNotification)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CountNotification *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "count_in", 1), &((ns2__CountNotification*)a)->count_USCOREin))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "count_out", 1), &((ns2__CountNotification*)a)->count_USCOREout))
		return NULL;
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	size_t soap_flag_counting_USCOREgate_USCOREid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_counting_USCOREgate_USCOREid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CountingGateID(soap, "ns2:counting_gate_id", &a->ns2__CountNotification::counting_USCOREgate_USCOREid, "ns2:CountingGateID"))
				{	soap_flag_counting_USCOREgate_USCOREid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_counting_USCOREgate_USCOREid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CountNotification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CountNotification, SOAP_TYPE_ns2__CountNotification, sizeof(ns2__CountNotification), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CountNotification * SOAP_FMAC2 soap_instantiate_ns2__CountNotification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CountNotification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CountNotification *p;
	size_t k = sizeof(ns2__CountNotification);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CountNotification);
		if (p)
			((ns2__CountNotification*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CountNotification, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CountNotification*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CountNotification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CountNotification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CountNotification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CountNotification(soap, tag ? tag : "ns2:CountNotification", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CountNotification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CountNotification(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CountNotification * SOAP_FMAC4 soap_get_ns2__CountNotification(struct soap *soap, ns2__CountNotification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CountNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ExtendedNotificationBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationWithOSDState::soap_default(soap);
	soap_default_ns2__IP_USCOREAddress(soap, &this->ns2__ExtendedNotificationBase::ip_USCOREaddress);
	soap_default_std__wstring(soap, &this->ns2__ExtendedNotificationBase::firmware_USCOREversion);
	soap_default_std__wstring(soap, &this->ns2__ExtendedNotificationBase::customer_USCOREversion);
	this->ns2__ExtendedNotificationBase::version = NULL;
}

void ns2__ExtendedNotificationBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__NotificationWithOSDState::soap_serialize(soap);
#endif
}

int ns2__ExtendedNotificationBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ExtendedNotificationBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ExtendedNotificationBase(struct soap *soap, const char *tag, int id, const ns2__ExtendedNotificationBase *a, const char *type)
{
	soap_set_attr(soap, "ip_address", soap_ns2__IP_USCOREAddress2s(soap, ((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress), 2);
	soap_set_attr(soap, "firmware_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion), 2);
	soap_set_attr(soap, "customer_version", soap_std__wstring2s(soap, ((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion), 2);
	if (((ns2__ExtendedNotificationBase*)a)->version)
		soap_set_attr(soap, "version", soap_xsd__decimal2s(soap, *((ns2__ExtendedNotificationBase*)a)->version), 2);
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ExtendedNotificationBase), type ? type : "ns2:ExtendedNotificationBase"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ExtendedNotificationBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ExtendedNotificationBase(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ExtendedNotificationBase * SOAP_FMAC4 soap_in_ns2__ExtendedNotificationBase(struct soap *soap, const char *tag, ns2__ExtendedNotificationBase *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ExtendedNotificationBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ExtendedNotificationBase, sizeof(ns2__ExtendedNotificationBase), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ExtendedNotificationBase)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ExtendedNotificationBase *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__IP_USCOREAddress(soap, soap_attr_value(soap, "ip_address", 1), &((ns2__ExtendedNotificationBase*)a)->ip_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "firmware_version", 1), &((ns2__ExtendedNotificationBase*)a)->firmware_USCOREversion))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_version", 1), &((ns2__ExtendedNotificationBase*)a)->customer_USCOREversion))
		return NULL;
	{	const char *t = soap_attr_value(soap, "version", 0);
		if (t)
		{
			if (!(((ns2__ExtendedNotificationBase*)a)->version = soap_new_xsd__decimal(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__decimal(soap, t, ((ns2__ExtendedNotificationBase*)a)->version))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ExtendedNotificationBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ExtendedNotificationBase, SOAP_TYPE_ns2__ExtendedNotificationBase, sizeof(ns2__ExtendedNotificationBase), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ExtendedNotificationBase * SOAP_FMAC2 soap_instantiate_ns2__ExtendedNotificationBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ExtendedNotificationBase(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:ErrorLogfilesNotification"))
		return soap_instantiate_ns2__ErrorLogfilesNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:AliveNotification"))
		return soap_instantiate_ns2__AliveNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:StartupNotification"))
		return soap_instantiate_ns2__StartupNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:FeatureInfoNotification"))
		return soap_instantiate_ns2__FeatureInfoNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ErrorContainer"))
		return soap_instantiate_ns2__ErrorContainer(soap, n, NULL, NULL, size);
	ns2__ExtendedNotificationBase *p;
	size_t k = sizeof(ns2__ExtendedNotificationBase);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ExtendedNotificationBase);
		if (p)
			((ns2__ExtendedNotificationBase*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ExtendedNotificationBase, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ExtendedNotificationBase*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ExtendedNotificationBase location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ExtendedNotificationBase, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ExtendedNotificationBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ExtendedNotificationBase(soap, tag ? tag : "ns2:ExtendedNotificationBase", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ExtendedNotificationBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ExtendedNotificationBase(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ExtendedNotificationBase * SOAP_FMAC4 soap_get_ns2__ExtendedNotificationBase(struct soap *soap, ns2__ExtendedNotificationBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ExtendedNotificationBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__NotificationWithOSDState::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__NotificationBase::soap_default(soap);
	soap_default_ns2__OSD_USCOREState(soap, &this->ns2__NotificationWithOSDState::osd_USCOREstate);
}

void ns2__NotificationWithOSDState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__NotificationBase::soap_serialize(soap);
#endif
}

int ns2__NotificationWithOSDState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NotificationWithOSDState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NotificationWithOSDState(struct soap *soap, const char *tag, int id, const ns2__NotificationWithOSDState *a, const char *type)
{
	soap_set_attr(soap, "osd_state", soap_ns2__OSD_USCOREState2s(soap, ((ns2__NotificationWithOSDState*)a)->osd_USCOREstate), 1);
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NotificationWithOSDState), type ? type : "ns2:NotificationWithOSDState"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__NotificationWithOSDState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NotificationWithOSDState(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NotificationWithOSDState * SOAP_FMAC4 soap_in_ns2__NotificationWithOSDState(struct soap *soap, const char *tag, ns2__NotificationWithOSDState *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NotificationWithOSDState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NotificationWithOSDState, sizeof(ns2__NotificationWithOSDState), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__NotificationWithOSDState)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__NotificationWithOSDState *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__OSD_USCOREState(soap, soap_attr_value(soap, "osd_state", 1), &((ns2__NotificationWithOSDState*)a)->osd_USCOREstate))
		return NULL;
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NotificationWithOSDState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NotificationWithOSDState, SOAP_TYPE_ns2__NotificationWithOSDState, sizeof(ns2__NotificationWithOSDState), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__NotificationWithOSDState * SOAP_FMAC2 soap_instantiate_ns2__NotificationWithOSDState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NotificationWithOSDState(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:ExtendedNotificationBase"))
		return soap_instantiate_ns2__ExtendedNotificationBase(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:CountNotification"))
		return soap_instantiate_ns2__CountNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:CountChannelsNotification"))
		return soap_instantiate_ns2__CountChannelsNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ZoneChannelsNotification"))
		return soap_instantiate_ns2__ZoneChannelsNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:FillNotification"))
		return soap_instantiate_ns2__FillNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ClearZoneNotification"))
		return soap_instantiate_ns2__ClearZoneNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:CameraImagesNotification"))
		return soap_instantiate_ns2__CameraImagesNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:CurrentObjectListNotification"))
		return soap_instantiate_ns2__CurrentObjectListNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ErrorLogfilesNotification"))
		return soap_instantiate_ns2__ErrorLogfilesNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:AliveNotification"))
		return soap_instantiate_ns2__AliveNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:StartupNotification"))
		return soap_instantiate_ns2__StartupNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:FeatureInfoNotification"))
		return soap_instantiate_ns2__FeatureInfoNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ErrorContainer"))
		return soap_instantiate_ns2__ErrorContainer(soap, n, NULL, NULL, size);
	ns2__NotificationWithOSDState *p;
	size_t k = sizeof(ns2__NotificationWithOSDState);
	if (n < 0)
	{	p = SOAP_NEW(ns2__NotificationWithOSDState);
		if (p)
			((ns2__NotificationWithOSDState*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__NotificationWithOSDState, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__NotificationWithOSDState*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__NotificationWithOSDState location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__NotificationWithOSDState, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__NotificationWithOSDState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__NotificationWithOSDState(soap, tag ? tag : "ns2:NotificationWithOSDState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NotificationWithOSDState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NotificationWithOSDState(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NotificationWithOSDState * SOAP_FMAC4 soap_get_ns2__NotificationWithOSDState(struct soap *soap, ns2__NotificationWithOSDState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NotificationWithOSDState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__NotificationBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__MAC_USCOREAddress(soap, &this->ns2__NotificationBase::mac_USCOREaddress);
	soap_default_std__wstring(soap, &this->ns2__NotificationBase::customer_USCOREID);
	soap_default_ns2__TaskType(soap, &this->ns2__NotificationBase::task_USCOREtype);
	soap_default_unsignedInt(soap, &this->ns2__NotificationBase::notification_USCOREID);
	soap_default_unsignedInt(soap, &this->ns2__NotificationBase::serverTask_USCOREID);
	soap_default_std__wstring(soap, &this->ns2__NotificationBase::callerType_USCOREID);
	soap_default_dateTime(soap, &this->ns2__NotificationBase::timestamp);
	/* transient soap skipped */
}

void ns2__NotificationBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__NotificationBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NotificationBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NotificationBase(struct soap *soap, const char *tag, int id, const ns2__NotificationBase *a, const char *type)
{
	soap_set_attr(soap, "mac_address", soap_ns2__MAC_USCOREAddress2s(soap, ((ns2__NotificationBase*)a)->mac_USCOREaddress), 2);
	soap_set_attr(soap, "customer_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->customer_USCOREID), 2);
	soap_set_attr(soap, "task_type", soap_ns2__TaskType2s(soap, ((ns2__NotificationBase*)a)->task_USCOREtype), 1);
	soap_set_attr(soap, "notification_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->notification_USCOREID), 1);
	soap_set_attr(soap, "serverTask_ID", soap_unsignedInt2s(soap, ((ns2__NotificationBase*)a)->serverTask_USCOREID), 1);
	soap_set_attr(soap, "callerType_ID", soap_std__wstring2s(soap, ((ns2__NotificationBase*)a)->callerType_USCOREID), 2);
	soap_set_attr(soap, "timestamp", soap_dateTime2s(soap, ((ns2__NotificationBase*)a)->timestamp), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NotificationBase), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__NotificationBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NotificationBase(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NotificationBase * SOAP_FMAC4 soap_in_ns2__NotificationBase(struct soap *soap, const char *tag, ns2__NotificationBase *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NotificationBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NotificationBase, sizeof(ns2__NotificationBase), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__NotificationBase)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__NotificationBase *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__MAC_USCOREAddress(soap, soap_attr_value(soap, "mac_address", 1), &((ns2__NotificationBase*)a)->mac_USCOREaddress))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "customer_ID", 1), &((ns2__NotificationBase*)a)->customer_USCOREID))
		return NULL;
	if (soap_s2ns2__TaskType(soap, soap_attr_value(soap, "task_type", 1), &((ns2__NotificationBase*)a)->task_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "notification_ID", 1), &((ns2__NotificationBase*)a)->notification_USCOREID))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "serverTask_ID", 1), &((ns2__NotificationBase*)a)->serverTask_USCOREID))
		return NULL;
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "callerType_ID", 1), &((ns2__NotificationBase*)a)->callerType_USCOREID))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "timestamp", 1), &((ns2__NotificationBase*)a)->timestamp))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NotificationBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NotificationBase, SOAP_TYPE_ns2__NotificationBase, sizeof(ns2__NotificationBase), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__NotificationBase * SOAP_FMAC2 soap_instantiate_ns2__NotificationBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NotificationBase(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "ns2:NotificationWithOSDState"))
		return soap_instantiate_ns2__NotificationWithOSDState(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:DigitalInputNotification"))
		return soap_instantiate_ns2__DigitalInputNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:LogfilesNotification"))
		return soap_instantiate_ns2__LogfilesNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ParameterNotification"))
		return soap_instantiate_ns2__ParameterNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:HistoricObjectListNotificationBase"))
		return soap_instantiate_ns2__HistoricObjectListNotificationBase(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ExtendedNotificationBase"))
		return soap_instantiate_ns2__ExtendedNotificationBase(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:CountNotification"))
		return soap_instantiate_ns2__CountNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:CountChannelsNotification"))
		return soap_instantiate_ns2__CountChannelsNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ZoneChannelsNotification"))
		return soap_instantiate_ns2__ZoneChannelsNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:FillNotification"))
		return soap_instantiate_ns2__FillNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ClearZoneNotification"))
		return soap_instantiate_ns2__ClearZoneNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:CameraImagesNotification"))
		return soap_instantiate_ns2__CameraImagesNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:CurrentObjectListNotification"))
		return soap_instantiate_ns2__CurrentObjectListNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:HistoricObjectListNotification"))
		return soap_instantiate_ns2__HistoricObjectListNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ErrorLogfilesNotification"))
		return soap_instantiate_ns2__ErrorLogfilesNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:AliveNotification"))
		return soap_instantiate_ns2__AliveNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:StartupNotification"))
		return soap_instantiate_ns2__StartupNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:FeatureInfoNotification"))
		return soap_instantiate_ns2__FeatureInfoNotification(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "ns2:ErrorContainer"))
		return soap_instantiate_ns2__ErrorContainer(soap, n, NULL, NULL, size);
	ns2__NotificationBase *p;
	size_t k = sizeof(ns2__NotificationBase);
	if (n < 0)
	{	p = SOAP_NEW(ns2__NotificationBase);
		if (p)
			((ns2__NotificationBase*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__NotificationBase, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__NotificationBase*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__NotificationBase location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__NotificationBase, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__NotificationBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__NotificationBase(soap, tag ? tag : "ns2:NotificationBase", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NotificationBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NotificationBase(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NotificationBase * SOAP_FMAC4 soap_get_ns2__NotificationBase(struct soap *soap, ns2__NotificationBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NotificationBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BinaryData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BinaryData::bin_USCOREdata.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void ns2__BinaryData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns2__BinaryData::bin_USCOREdata.soap_serialize(soap);
#endif
}

int ns2__BinaryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BinaryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BinaryData(struct soap *soap, const char *tag, int id, const ns2__BinaryData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BinaryData), type))
		return soap->error;
	if ((a->ns2__BinaryData::bin_USCOREdata).soap_out(soap, "ns2:bin_data", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BinaryData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BinaryData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BinaryData * SOAP_FMAC4 soap_in_ns2__BinaryData(struct soap *soap, const char *tag, ns2__BinaryData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BinaryData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BinaryData, sizeof(ns2__BinaryData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BinaryData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BinaryData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_bin_USCOREdata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bin_USCOREdata1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns2__BinaryData::bin_USCOREdata).soap_in(soap, "ns2:bin_data", "xsd:base64Binary"))
				{	soap_flag_bin_USCOREdata1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bin_USCOREdata1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__BinaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BinaryData, SOAP_TYPE_ns2__BinaryData, sizeof(ns2__BinaryData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BinaryData * SOAP_FMAC2 soap_instantiate_ns2__BinaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BinaryData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BinaryData *p;
	size_t k = sizeof(ns2__BinaryData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BinaryData);
		if (p)
			((ns2__BinaryData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BinaryData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BinaryData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BinaryData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BinaryData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BinaryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__BinaryData(soap, tag ? tag : "ns2:BinaryData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BinaryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BinaryData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BinaryData * SOAP_FMAC4 soap_get_ns2__BinaryData(struct soap *soap, ns2__BinaryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ClearZoneID::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->ns2__ClearZoneID::id);
	/* transient soap skipped */
}

void ns2__ClearZoneID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__ClearZoneID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ClearZoneID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ClearZoneID(struct soap *soap, const char *tag, int id, const ns2__ClearZoneID *a, const char *type)
{
	soap_set_attr(soap, "id", soap_std__wstring2s(soap, ((ns2__ClearZoneID*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ClearZoneID), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ClearZoneID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ClearZoneID(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ClearZoneID * SOAP_FMAC4 soap_in_ns2__ClearZoneID(struct soap *soap, const char *tag, ns2__ClearZoneID *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ClearZoneID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ClearZoneID, sizeof(ns2__ClearZoneID), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ClearZoneID)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ClearZoneID *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "id", 1), &((ns2__ClearZoneID*)a)->id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ClearZoneID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ClearZoneID, SOAP_TYPE_ns2__ClearZoneID, sizeof(ns2__ClearZoneID), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ClearZoneID * SOAP_FMAC2 soap_instantiate_ns2__ClearZoneID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ClearZoneID(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ClearZoneID *p;
	size_t k = sizeof(ns2__ClearZoneID);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ClearZoneID);
		if (p)
			((ns2__ClearZoneID*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ClearZoneID, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ClearZoneID*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ClearZoneID location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ClearZoneID, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ClearZoneID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ClearZoneID(soap, tag ? tag : "ns2:ClearZoneID", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ClearZoneID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ClearZoneID(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ClearZoneID * SOAP_FMAC4 soap_get_ns2__ClearZoneID(struct soap *soap, ns2__ClearZoneID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ClearZoneID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FillRegionID::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->ns2__FillRegionID::id);
	/* transient soap skipped */
}

void ns2__FillRegionID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__FillRegionID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FillRegionID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FillRegionID(struct soap *soap, const char *tag, int id, const ns2__FillRegionID *a, const char *type)
{
	soap_set_attr(soap, "id", soap_std__wstring2s(soap, ((ns2__FillRegionID*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FillRegionID), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FillRegionID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FillRegionID(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FillRegionID * SOAP_FMAC4 soap_in_ns2__FillRegionID(struct soap *soap, const char *tag, ns2__FillRegionID *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FillRegionID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FillRegionID, sizeof(ns2__FillRegionID), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FillRegionID)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FillRegionID *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "id", 1), &((ns2__FillRegionID*)a)->id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FillRegionID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FillRegionID, SOAP_TYPE_ns2__FillRegionID, sizeof(ns2__FillRegionID), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FillRegionID * SOAP_FMAC2 soap_instantiate_ns2__FillRegionID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FillRegionID(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FillRegionID *p;
	size_t k = sizeof(ns2__FillRegionID);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FillRegionID);
		if (p)
			((ns2__FillRegionID*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FillRegionID, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FillRegionID*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FillRegionID location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FillRegionID, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FillRegionID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__FillRegionID(soap, tag ? tag : "ns2:FillRegionID", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FillRegionID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FillRegionID(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FillRegionID * SOAP_FMAC4 soap_get_ns2__FillRegionID(struct soap *soap, ns2__FillRegionID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FillRegionID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CountingGateID::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->ns2__CountingGateID::id);
	/* transient soap skipped */
}

void ns2__CountingGateID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__CountingGateID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CountingGateID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CountingGateID(struct soap *soap, const char *tag, int id, const ns2__CountingGateID *a, const char *type)
{
	soap_set_attr(soap, "id", soap_std__wstring2s(soap, ((ns2__CountingGateID*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CountingGateID), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CountingGateID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CountingGateID(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CountingGateID * SOAP_FMAC4 soap_in_ns2__CountingGateID(struct soap *soap, const char *tag, ns2__CountingGateID *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CountingGateID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CountingGateID, sizeof(ns2__CountingGateID), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CountingGateID)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CountingGateID *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__wstring(soap, soap_attr_value(soap, "id", 1), &((ns2__CountingGateID*)a)->id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CountingGateID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CountingGateID, SOAP_TYPE_ns2__CountingGateID, sizeof(ns2__CountingGateID), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CountingGateID * SOAP_FMAC2 soap_instantiate_ns2__CountingGateID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CountingGateID(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CountingGateID *p;
	size_t k = sizeof(ns2__CountingGateID);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CountingGateID);
		if (p)
			((ns2__CountingGateID*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CountingGateID, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CountingGateID*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CountingGateID location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CountingGateID, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CountingGateID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CountingGateID(soap, tag ? tag : "ns2:CountingGateID", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CountingGateID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CountingGateID(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CountingGateID * SOAP_FMAC4 soap_get_ns2__CountingGateID(struct soap *soap, ns2__CountingGateID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CountingGateID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Trigger::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Trigger::__union_Trigger = -1;
	/* transient soap skipped */
}

void ns2__Trigger::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns2__union_Trigger(soap, this->ns2__Trigger::__union_Trigger, &this->ns2__Trigger::union_Trigger);
#endif
}

int ns2__Trigger::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Trigger(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Trigger(struct soap *soap, const char *tag, int id, const ns2__Trigger *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Trigger), type))
		return soap->error;
	if (soap_out__ns2__union_Trigger(soap, a->ns2__Trigger::__union_Trigger, &a->ns2__Trigger::union_Trigger))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Trigger::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Trigger(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Trigger * SOAP_FMAC4 soap_in_ns2__Trigger(struct soap *soap, const char *tag, ns2__Trigger *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Trigger *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Trigger, sizeof(ns2__Trigger), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__ns2__union_Trigger(soap, &a->__union_Trigger, &a->union_Trigger))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns2__Trigger *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Trigger, SOAP_TYPE_ns2__Trigger, sizeof(ns2__Trigger), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Trigger * SOAP_FMAC2 soap_instantiate_ns2__Trigger(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Trigger(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Trigger *p;
	size_t k = sizeof(ns2__Trigger);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Trigger);
		if (p)
			((ns2__Trigger*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Trigger, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Trigger*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Trigger location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Trigger, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Trigger::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__Trigger(soap, tag ? tag : "ns2:Trigger", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Trigger::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Trigger(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Trigger * SOAP_FMAC4 soap_get_ns2__Trigger(struct soap *soap, ns2__Trigger *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Trigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TimeTrigger::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TimeTrigger::date = NULL;
	this->ns2__TimeTrigger::start = NULL;
	this->ns2__TimeTrigger::cycle = NULL;
	this->ns2__TimeTrigger::random_USCOREoffset = NULL;
	/* transient soap skipped */
}

void ns2__TimeTrigger::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__Date(soap, &this->ns2__TimeTrigger::date);
	soap_serialize_PointerTons2__ClockTime(soap, &this->ns2__TimeTrigger::start);
	soap_serialize_PointerToxsd__duration(soap, &this->ns2__TimeTrigger::cycle);
	soap_serialize_PointerToxsd__duration(soap, &this->ns2__TimeTrigger::random_USCOREoffset);
#endif
}

int ns2__TimeTrigger::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TimeTrigger(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TimeTrigger(struct soap *soap, const char *tag, int id, const ns2__TimeTrigger *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TimeTrigger), type))
		return soap->error;
	if (soap_out_PointerTons2__Date(soap, "ns2:date", -1, &a->ns2__TimeTrigger::date, ""))
		return soap->error;
	if (!a->ns2__TimeTrigger::start)
	{	if (soap_element_nil(soap, "ns2:start"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons2__ClockTime(soap, "ns2:start", -1, &a->ns2__TimeTrigger::start, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "ns2:cycle", -1, &a->ns2__TimeTrigger::cycle, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "ns2:random_offset", -1, &a->ns2__TimeTrigger::random_USCOREoffset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TimeTrigger::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TimeTrigger(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TimeTrigger * SOAP_FMAC4 soap_in_ns2__TimeTrigger(struct soap *soap, const char *tag, ns2__TimeTrigger *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TimeTrigger *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TimeTrigger, sizeof(ns2__TimeTrigger), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TimeTrigger)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TimeTrigger *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_date1 = 1;
	size_t soap_flag_start1 = 1;
	size_t soap_flag_cycle1 = 1;
	size_t soap_flag_random_USCOREoffset1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Date(soap, "ns2:date", &a->ns2__TimeTrigger::date, "ns2:Date"))
				{	soap_flag_date1--;
					continue;
				}
			if (soap_flag_start1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ClockTime(soap, "ns2:start", &a->ns2__TimeTrigger::start, "ns2:ClockTime"))
				{	soap_flag_start1--;
					continue;
				}
			if (soap_flag_cycle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "ns2:cycle", &a->ns2__TimeTrigger::cycle, "xsd:duration"))
				{	soap_flag_cycle1--;
					continue;
				}
			if (soap_flag_random_USCOREoffset1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "ns2:random_offset", &a->ns2__TimeTrigger::random_USCOREoffset, "xsd:duration"))
				{	soap_flag_random_USCOREoffset1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_start1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TimeTrigger *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TimeTrigger, SOAP_TYPE_ns2__TimeTrigger, sizeof(ns2__TimeTrigger), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TimeTrigger * SOAP_FMAC2 soap_instantiate_ns2__TimeTrigger(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TimeTrigger(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TimeTrigger *p;
	size_t k = sizeof(ns2__TimeTrigger);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TimeTrigger);
		if (p)
			((ns2__TimeTrigger*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TimeTrigger, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TimeTrigger*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TimeTrigger location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TimeTrigger, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TimeTrigger::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__TimeTrigger(soap, tag ? tag : "ns2:TimeTrigger", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TimeTrigger::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TimeTrigger(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TimeTrigger * SOAP_FMAC4 soap_get_ns2__TimeTrigger(struct soap *soap, ns2__TimeTrigger *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TimeTrigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ClockTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__HoursOfDay(soap, &this->ns2__ClockTime::hours);
	soap_default_ns2__MinutesOrSeconds(soap, &this->ns2__ClockTime::minutes);
	soap_default_ns2__MinutesOrSeconds(soap, &this->ns2__ClockTime::seconds);
	/* transient soap skipped */
}

void ns2__ClockTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__ClockTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ClockTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ClockTime(struct soap *soap, const char *tag, int id, const ns2__ClockTime *a, const char *type)
{
	soap_set_attr(soap, "hours", soap_ns2__HoursOfDay2s(soap, ((ns2__ClockTime*)a)->hours), 1);
	soap_set_attr(soap, "minutes", soap_ns2__MinutesOrSeconds2s(soap, ((ns2__ClockTime*)a)->minutes), 1);
	soap_set_attr(soap, "seconds", soap_ns2__MinutesOrSeconds2s(soap, ((ns2__ClockTime*)a)->seconds), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ClockTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ClockTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ClockTime(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ClockTime * SOAP_FMAC4 soap_in_ns2__ClockTime(struct soap *soap, const char *tag, ns2__ClockTime *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ClockTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ClockTime, sizeof(ns2__ClockTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ClockTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ClockTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__HoursOfDay(soap, soap_attr_value(soap, "hours", 1), &((ns2__ClockTime*)a)->hours))
		return NULL;
	if (soap_s2ns2__MinutesOrSeconds(soap, soap_attr_value(soap, "minutes", 1), &((ns2__ClockTime*)a)->minutes))
		return NULL;
	if (soap_s2ns2__MinutesOrSeconds(soap, soap_attr_value(soap, "seconds", 1), &((ns2__ClockTime*)a)->seconds))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ClockTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ClockTime, SOAP_TYPE_ns2__ClockTime, sizeof(ns2__ClockTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ClockTime * SOAP_FMAC2 soap_instantiate_ns2__ClockTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ClockTime(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ClockTime *p;
	size_t k = sizeof(ns2__ClockTime);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ClockTime);
		if (p)
			((ns2__ClockTime*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ClockTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ClockTime*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ClockTime location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ClockTime, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ClockTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ClockTime(soap, tag ? tag : "ns2:ClockTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ClockTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ClockTime(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ClockTime * SOAP_FMAC4 soap_get_ns2__ClockTime(struct soap *soap, ns2__ClockTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ClockTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Date::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__DateType(soap, &this->ns2__Date::kind);
	this->ns2__Date::day_USCOREof_USCOREweek = NULL;
	this->ns2__Date::day_USCOREof_USCOREmonth = NULL;
	/* transient soap skipped */
}

void ns2__Date::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__Date::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Date(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Date(struct soap *soap, const char *tag, int id, const ns2__Date *a, const char *type)
{
	soap_set_attr(soap, "kind", soap_ns2__DateType2s(soap, ((ns2__Date*)a)->kind), 1);
	if (((ns2__Date*)a)->day_USCOREof_USCOREweek)
		soap_set_attr(soap, "day_of_week", soap_ns2__DayOfWeek2s(soap, *((ns2__Date*)a)->day_USCOREof_USCOREweek), 1);
	if (((ns2__Date*)a)->day_USCOREof_USCOREmonth)
		soap_set_attr(soap, "day_of_month", soap_ns2__DayOfMonth2s(soap, *((ns2__Date*)a)->day_USCOREof_USCOREmonth), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Date), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Date::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Date(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Date * SOAP_FMAC4 soap_in_ns2__Date(struct soap *soap, const char *tag, ns2__Date *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Date *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Date, sizeof(ns2__Date), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Date)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Date *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__DateType(soap, soap_attr_value(soap, "kind", 1), &((ns2__Date*)a)->kind))
		return NULL;
	{	const char *t = soap_attr_value(soap, "day_of_week", 0);
		if (t)
		{
			if (!(((ns2__Date*)a)->day_USCOREof_USCOREweek = (enum ns2__DayOfWeek *)soap_malloc(soap, sizeof(enum ns2__DayOfWeek))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__DayOfWeek(soap, t, ((ns2__Date*)a)->day_USCOREof_USCOREweek))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "day_of_month", 0);
		if (t)
		{
			if (!(((ns2__Date*)a)->day_USCOREof_USCOREmonth = (unsigned int *)soap_malloc(soap, sizeof(unsigned int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns2__DayOfMonth(soap, t, ((ns2__Date*)a)->day_USCOREof_USCOREmonth))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Date, SOAP_TYPE_ns2__Date, sizeof(ns2__Date), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Date * SOAP_FMAC2 soap_instantiate_ns2__Date(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Date(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Date *p;
	size_t k = sizeof(ns2__Date);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Date);
		if (p)
			((ns2__Date*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Date, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Date*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Date location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Date, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Date::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__Date(soap, tag ? tag : "ns2:Date", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Date::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Date(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Date * SOAP_FMAC4 soap_get_ns2__Date(struct soap *soap, ns2__Date *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__EventTrigger::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__EventTrigger::__union_EventTrigger = -1;
	/* transient soap skipped */
}

void ns2__EventTrigger::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ns2__union_EventTrigger(soap, this->ns2__EventTrigger::__union_EventTrigger, &this->ns2__EventTrigger::union_EventTrigger);
#endif
}

int ns2__EventTrigger::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EventTrigger(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EventTrigger(struct soap *soap, const char *tag, int id, const ns2__EventTrigger *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EventTrigger), type))
		return soap->error;
	if (soap_out__ns2__union_EventTrigger(soap, a->ns2__EventTrigger::__union_EventTrigger, &a->ns2__EventTrigger::union_EventTrigger))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__EventTrigger::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EventTrigger(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EventTrigger * SOAP_FMAC4 soap_in_ns2__EventTrigger(struct soap *soap, const char *tag, ns2__EventTrigger *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EventTrigger *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EventTrigger, sizeof(ns2__EventTrigger), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__ns2__union_EventTrigger(soap, &a->__union_EventTrigger, &a->union_EventTrigger))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (ns2__EventTrigger *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EventTrigger, SOAP_TYPE_ns2__EventTrigger, sizeof(ns2__EventTrigger), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__EventTrigger * SOAP_FMAC2 soap_instantiate_ns2__EventTrigger(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EventTrigger(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__EventTrigger *p;
	size_t k = sizeof(ns2__EventTrigger);
	if (n < 0)
	{	p = SOAP_NEW(ns2__EventTrigger);
		if (p)
			((ns2__EventTrigger*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__EventTrigger, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__EventTrigger*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__EventTrigger location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__EventTrigger, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__EventTrigger::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__EventTrigger(soap, tag ? tag : "ns2:EventTrigger", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EventTrigger::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EventTrigger(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EventTrigger * SOAP_FMAC4 soap_get_ns2__EventTrigger(struct soap *soap, ns2__EventTrigger *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EventTrigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FeatureChangedEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns2__FeatureChangedEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__FeatureChangedEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FeatureChangedEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FeatureChangedEvent(struct soap *soap, const char *tag, int id, const ns2__FeatureChangedEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FeatureChangedEvent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FeatureChangedEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FeatureChangedEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FeatureChangedEvent * SOAP_FMAC4 soap_in_ns2__FeatureChangedEvent(struct soap *soap, const char *tag, ns2__FeatureChangedEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FeatureChangedEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FeatureChangedEvent, sizeof(ns2__FeatureChangedEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FeatureChangedEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FeatureChangedEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FeatureChangedEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FeatureChangedEvent, SOAP_TYPE_ns2__FeatureChangedEvent, sizeof(ns2__FeatureChangedEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FeatureChangedEvent * SOAP_FMAC2 soap_instantiate_ns2__FeatureChangedEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FeatureChangedEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FeatureChangedEvent *p;
	size_t k = sizeof(ns2__FeatureChangedEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FeatureChangedEvent);
		if (p)
			((ns2__FeatureChangedEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FeatureChangedEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FeatureChangedEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FeatureChangedEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FeatureChangedEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FeatureChangedEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__FeatureChangedEvent(soap, tag ? tag : "ns2:FeatureChangedEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FeatureChangedEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FeatureChangedEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FeatureChangedEvent * SOAP_FMAC4 soap_get_ns2__FeatureChangedEvent(struct soap *soap, ns2__FeatureChangedEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FeatureChangedEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__OSD_USCOREEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns2__OSD_USCOREEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__OSD_USCOREEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OSD_USCOREEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OSD_USCOREEvent(struct soap *soap, const char *tag, int id, const ns2__OSD_USCOREEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OSD_USCOREEvent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OSD_USCOREEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OSD_USCOREEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OSD_USCOREEvent * SOAP_FMAC4 soap_in_ns2__OSD_USCOREEvent(struct soap *soap, const char *tag, ns2__OSD_USCOREEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OSD_USCOREEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OSD_USCOREEvent, sizeof(ns2__OSD_USCOREEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__OSD_USCOREEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__OSD_USCOREEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OSD_USCOREEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OSD_USCOREEvent, SOAP_TYPE_ns2__OSD_USCOREEvent, sizeof(ns2__OSD_USCOREEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__OSD_USCOREEvent * SOAP_FMAC2 soap_instantiate_ns2__OSD_USCOREEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OSD_USCOREEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__OSD_USCOREEvent *p;
	size_t k = sizeof(ns2__OSD_USCOREEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__OSD_USCOREEvent);
		if (p)
			((ns2__OSD_USCOREEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__OSD_USCOREEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__OSD_USCOREEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__OSD_USCOREEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__OSD_USCOREEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__OSD_USCOREEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__OSD_USCOREEvent(soap, tag ? tag : "ns2:OSD_Event", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OSD_USCOREEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OSD_USCOREEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OSD_USCOREEvent * SOAP_FMAC4 soap_get_ns2__OSD_USCOREEvent(struct soap *soap, ns2__OSD_USCOREEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OSD_USCOREEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CurrentObjectListEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CurrentObjectListEvent::skip = 0;
	/* transient soap skipped */
}

void ns2__CurrentObjectListEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__CurrentObjectListEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CurrentObjectListEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CurrentObjectListEvent(struct soap *soap, const char *tag, int id, const ns2__CurrentObjectListEvent *a, const char *type)
{
	soap_set_attr(soap, "skip", soap_unsignedInt2s(soap, ((ns2__CurrentObjectListEvent*)a)->skip), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CurrentObjectListEvent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CurrentObjectListEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CurrentObjectListEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CurrentObjectListEvent * SOAP_FMAC4 soap_in_ns2__CurrentObjectListEvent(struct soap *soap, const char *tag, ns2__CurrentObjectListEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CurrentObjectListEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CurrentObjectListEvent, sizeof(ns2__CurrentObjectListEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CurrentObjectListEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CurrentObjectListEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "skip", 0), &((ns2__CurrentObjectListEvent*)a)->skip))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CurrentObjectListEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CurrentObjectListEvent, SOAP_TYPE_ns2__CurrentObjectListEvent, sizeof(ns2__CurrentObjectListEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CurrentObjectListEvent * SOAP_FMAC2 soap_instantiate_ns2__CurrentObjectListEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CurrentObjectListEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CurrentObjectListEvent *p;
	size_t k = sizeof(ns2__CurrentObjectListEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CurrentObjectListEvent);
		if (p)
			((ns2__CurrentObjectListEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CurrentObjectListEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CurrentObjectListEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CurrentObjectListEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CurrentObjectListEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CurrentObjectListEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CurrentObjectListEvent(soap, tag ? tag : "ns2:CurrentObjectListEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CurrentObjectListEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CurrentObjectListEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CurrentObjectListEvent * SOAP_FMAC4 soap_get_ns2__CurrentObjectListEvent(struct soap *soap, ns2__CurrentObjectListEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CurrentObjectListEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__OneTimeEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns2__OneTimeEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__OneTimeEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OneTimeEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OneTimeEvent(struct soap *soap, const char *tag, int id, const ns2__OneTimeEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OneTimeEvent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OneTimeEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OneTimeEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OneTimeEvent * SOAP_FMAC4 soap_in_ns2__OneTimeEvent(struct soap *soap, const char *tag, ns2__OneTimeEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OneTimeEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OneTimeEvent, sizeof(ns2__OneTimeEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__OneTimeEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__OneTimeEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OneTimeEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OneTimeEvent, SOAP_TYPE_ns2__OneTimeEvent, sizeof(ns2__OneTimeEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__OneTimeEvent * SOAP_FMAC2 soap_instantiate_ns2__OneTimeEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OneTimeEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__OneTimeEvent *p;
	size_t k = sizeof(ns2__OneTimeEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__OneTimeEvent);
		if (p)
			((ns2__OneTimeEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__OneTimeEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__OneTimeEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__OneTimeEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__OneTimeEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__OneTimeEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__OneTimeEvent(soap, tag ? tag : "ns2:OneTimeEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OneTimeEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OneTimeEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OneTimeEvent * SOAP_FMAC4 soap_get_ns2__OneTimeEvent(struct soap *soap, ns2__OneTimeEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OneTimeEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DigitalInputEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DigitalInputEvent::__sizeevent = 0;
	this->ns2__DigitalInputEvent::event = NULL;
	/* transient soap skipped */
}

void ns2__DigitalInputEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->ns2__DigitalInputEvent::event)
	{	int i;
		for (i = 0; i < (int)this->ns2__DigitalInputEvent::__sizeevent; i++)
		{
			soap_embedded(soap, this->ns2__DigitalInputEvent::event + i, SOAP_TYPE_ns2__DigitalInputEventType);
		}
	}
#endif
}

int ns2__DigitalInputEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DigitalInputEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DigitalInputEvent(struct soap *soap, const char *tag, int id, const ns2__DigitalInputEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DigitalInputEvent), type))
		return soap->error;
	if (a->ns2__DigitalInputEvent::event)
	{	int i;
		for (i = 0; i < (int)a->ns2__DigitalInputEvent::__sizeevent; i++)
			if (soap_out_ns2__DigitalInputEventType(soap, "ns2:event", -1, a->ns2__DigitalInputEvent::event + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__DigitalInputEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DigitalInputEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DigitalInputEvent * SOAP_FMAC4 soap_in_ns2__DigitalInputEvent(struct soap *soap, const char *tag, ns2__DigitalInputEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DigitalInputEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DigitalInputEvent, sizeof(ns2__DigitalInputEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DigitalInputEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DigitalInputEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	struct soap_blist *soap_blist_event1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns2:event", 1, NULL))
			{	if (a->ns2__DigitalInputEvent::event == NULL)
				{	if (soap_blist_event1 == NULL)
						soap_blist_event1 = soap_new_block(soap);
					a->ns2__DigitalInputEvent::event = (enum ns2__DigitalInputEventType *)soap_push_block_max(soap, soap_blist_event1, sizeof(enum ns2__DigitalInputEventType));
					if (a->ns2__DigitalInputEvent::event == NULL)
						return NULL;
					soap_default_ns2__DigitalInputEventType(soap, a->ns2__DigitalInputEvent::event);
				}
				soap_revert(soap);
				if (soap_in_ns2__DigitalInputEventType(soap, "ns2:event", a->ns2__DigitalInputEvent::event, "ns2:DigitalInputEventType"))
				{	a->ns2__DigitalInputEvent::__sizeevent++;
					a->ns2__DigitalInputEvent::event = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__DigitalInputEvent::event)
			soap_pop_block(soap, soap_blist_event1);
		if (a->ns2__DigitalInputEvent::__sizeevent)
		{	a->ns2__DigitalInputEvent::event = (enum ns2__DigitalInputEventType *)soap_save_block(soap, soap_blist_event1, NULL, 1);
		}
		else
		{	a->ns2__DigitalInputEvent::event = NULL;
			if (soap_blist_event1)
				soap_end_block(soap, soap_blist_event1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__DigitalInputEvent::__sizeevent < 1 || a->ns2__DigitalInputEvent::__sizeevent > 16))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__DigitalInputEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DigitalInputEvent, SOAP_TYPE_ns2__DigitalInputEvent, sizeof(ns2__DigitalInputEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DigitalInputEvent * SOAP_FMAC2 soap_instantiate_ns2__DigitalInputEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DigitalInputEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DigitalInputEvent *p;
	size_t k = sizeof(ns2__DigitalInputEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DigitalInputEvent);
		if (p)
			((ns2__DigitalInputEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DigitalInputEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DigitalInputEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DigitalInputEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DigitalInputEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DigitalInputEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__DigitalInputEvent(soap, tag ? tag : "ns2:DigitalInputEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DigitalInputEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DigitalInputEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DigitalInputEvent * SOAP_FMAC4 soap_get_ns2__DigitalInputEvent(struct soap *soap, ns2__DigitalInputEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DigitalInputEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ClearZoneEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__ClearZoneEventType(soap, &this->ns2__ClearZoneEvent::clear_USCOREzone_USCOREevent_USCOREtype);
	/* transient soap skipped */
}

void ns2__ClearZoneEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__ClearZoneEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ClearZoneEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ClearZoneEvent(struct soap *soap, const char *tag, int id, const ns2__ClearZoneEvent *a, const char *type)
{
	soap_set_attr(soap, "clear_zone_event_type", soap_ns2__ClearZoneEventType2s(soap, ((ns2__ClearZoneEvent*)a)->clear_USCOREzone_USCOREevent_USCOREtype), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ClearZoneEvent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ClearZoneEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ClearZoneEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ClearZoneEvent * SOAP_FMAC4 soap_in_ns2__ClearZoneEvent(struct soap *soap, const char *tag, ns2__ClearZoneEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ClearZoneEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ClearZoneEvent, sizeof(ns2__ClearZoneEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ClearZoneEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ClearZoneEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__ClearZoneEventType(soap, soap_attr_value(soap, "clear_zone_event_type", 1), &((ns2__ClearZoneEvent*)a)->clear_USCOREzone_USCOREevent_USCOREtype))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ClearZoneEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ClearZoneEvent, SOAP_TYPE_ns2__ClearZoneEvent, sizeof(ns2__ClearZoneEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ClearZoneEvent * SOAP_FMAC2 soap_instantiate_ns2__ClearZoneEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ClearZoneEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ClearZoneEvent *p;
	size_t k = sizeof(ns2__ClearZoneEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ClearZoneEvent);
		if (p)
			((ns2__ClearZoneEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ClearZoneEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ClearZoneEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ClearZoneEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ClearZoneEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ClearZoneEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ClearZoneEvent(soap, tag ? tag : "ns2:ClearZoneEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ClearZoneEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ClearZoneEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ClearZoneEvent * SOAP_FMAC4 soap_get_ns2__ClearZoneEvent(struct soap *soap, ns2__ClearZoneEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ClearZoneEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FillEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__FillEventType(soap, &this->ns2__FillEvent::fill_USCOREevent_USCOREtype);
	this->ns2__FillEvent::threshold = NULL;
	/* transient soap skipped */
}

void ns2__FillEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__FillEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FillEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FillEvent(struct soap *soap, const char *tag, int id, const ns2__FillEvent *a, const char *type)
{
	soap_set_attr(soap, "fill_event_type", soap_ns2__FillEventType2s(soap, ((ns2__FillEvent*)a)->fill_USCOREevent_USCOREtype), 1);
	if (((ns2__FillEvent*)a)->threshold)
		soap_set_attr(soap, "threshold", soap_unsignedInt2s(soap, *((ns2__FillEvent*)a)->threshold), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FillEvent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FillEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FillEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FillEvent * SOAP_FMAC4 soap_in_ns2__FillEvent(struct soap *soap, const char *tag, ns2__FillEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FillEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FillEvent, sizeof(ns2__FillEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FillEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FillEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__FillEventType(soap, soap_attr_value(soap, "fill_event_type", 1), &((ns2__FillEvent*)a)->fill_USCOREevent_USCOREtype))
		return NULL;
	{	const char *t = soap_attr_value(soap, "threshold", 0);
		if (t)
		{
			if (!(((ns2__FillEvent*)a)->threshold = (unsigned int *)soap_malloc(soap, sizeof(unsigned int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2unsignedInt(soap, t, ((ns2__FillEvent*)a)->threshold))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FillEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FillEvent, SOAP_TYPE_ns2__FillEvent, sizeof(ns2__FillEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FillEvent * SOAP_FMAC2 soap_instantiate_ns2__FillEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FillEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FillEvent *p;
	size_t k = sizeof(ns2__FillEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FillEvent);
		if (p)
			((ns2__FillEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FillEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FillEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FillEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FillEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FillEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__FillEvent(soap, tag ? tag : "ns2:FillEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FillEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FillEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FillEvent * SOAP_FMAC4 soap_get_ns2__FillEvent(struct soap *soap, ns2__FillEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FillEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ZoneChannelsEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns2__ZoneChannelsEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__ZoneChannelsEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ZoneChannelsEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ZoneChannelsEvent(struct soap *soap, const char *tag, int id, const ns2__ZoneChannelsEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ZoneChannelsEvent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ZoneChannelsEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ZoneChannelsEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ZoneChannelsEvent * SOAP_FMAC4 soap_in_ns2__ZoneChannelsEvent(struct soap *soap, const char *tag, ns2__ZoneChannelsEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ZoneChannelsEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ZoneChannelsEvent, sizeof(ns2__ZoneChannelsEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ZoneChannelsEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ZoneChannelsEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ZoneChannelsEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ZoneChannelsEvent, SOAP_TYPE_ns2__ZoneChannelsEvent, sizeof(ns2__ZoneChannelsEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ZoneChannelsEvent * SOAP_FMAC2 soap_instantiate_ns2__ZoneChannelsEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ZoneChannelsEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ZoneChannelsEvent *p;
	size_t k = sizeof(ns2__ZoneChannelsEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ZoneChannelsEvent);
		if (p)
			((ns2__ZoneChannelsEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ZoneChannelsEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ZoneChannelsEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ZoneChannelsEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ZoneChannelsEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ZoneChannelsEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__ZoneChannelsEvent(soap, tag ? tag : "ns2:ZoneChannelsEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ZoneChannelsEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ZoneChannelsEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ZoneChannelsEvent * SOAP_FMAC4 soap_get_ns2__ZoneChannelsEvent(struct soap *soap, ns2__ZoneChannelsEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ZoneChannelsEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CountChannelsEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns2__CountChannelsEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__CountChannelsEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CountChannelsEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CountChannelsEvent(struct soap *soap, const char *tag, int id, const ns2__CountChannelsEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CountChannelsEvent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CountChannelsEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CountChannelsEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CountChannelsEvent * SOAP_FMAC4 soap_in_ns2__CountChannelsEvent(struct soap *soap, const char *tag, ns2__CountChannelsEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CountChannelsEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CountChannelsEvent, sizeof(ns2__CountChannelsEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CountChannelsEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CountChannelsEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CountChannelsEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CountChannelsEvent, SOAP_TYPE_ns2__CountChannelsEvent, sizeof(ns2__CountChannelsEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CountChannelsEvent * SOAP_FMAC2 soap_instantiate_ns2__CountChannelsEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CountChannelsEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CountChannelsEvent *p;
	size_t k = sizeof(ns2__CountChannelsEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CountChannelsEvent);
		if (p)
			((ns2__CountChannelsEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CountChannelsEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CountChannelsEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CountChannelsEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CountChannelsEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CountChannelsEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CountChannelsEvent(soap, tag ? tag : "ns2:CountChannelsEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CountChannelsEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CountChannelsEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CountChannelsEvent * SOAP_FMAC4 soap_get_ns2__CountChannelsEvent(struct soap *soap, ns2__CountChannelsEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CountChannelsEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CountEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__CountEventType(soap, &this->ns2__CountEvent::count_USCOREevent_USCOREtype);
	this->ns2__CountEvent::delta = 1;
	/* transient soap skipped */
}

void ns2__CountEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__CountEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CountEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CountEvent(struct soap *soap, const char *tag, int id, const ns2__CountEvent *a, const char *type)
{
	soap_set_attr(soap, "count_event_type", soap_ns2__CountEventType2s(soap, ((ns2__CountEvent*)a)->count_USCOREevent_USCOREtype), 1);
	soap_set_attr(soap, "delta", soap_unsignedInt2s(soap, ((ns2__CountEvent*)a)->delta), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CountEvent), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CountEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CountEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CountEvent * SOAP_FMAC4 soap_in_ns2__CountEvent(struct soap *soap, const char *tag, ns2__CountEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CountEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CountEvent, sizeof(ns2__CountEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CountEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CountEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__CountEventType(soap, soap_attr_value(soap, "count_event_type", 1), &((ns2__CountEvent*)a)->count_USCOREevent_USCOREtype))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "delta", 0), &((ns2__CountEvent*)a)->delta))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CountEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CountEvent, SOAP_TYPE_ns2__CountEvent, sizeof(ns2__CountEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CountEvent * SOAP_FMAC2 soap_instantiate_ns2__CountEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CountEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CountEvent *p;
	size_t k = sizeof(ns2__CountEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CountEvent);
		if (p)
			((ns2__CountEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CountEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CountEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CountEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CountEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CountEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__CountEvent(soap, tag ? tag : "ns2:CountEvent", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CountEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CountEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CountEvent * SOAP_FMAC4 soap_get_ns2__CountEvent(struct soap *soap, ns2__CountEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CountEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DigitalOutputElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__DigitalOutputActivity(soap, &this->ns2__DigitalOutputElement::activity);
	/* transient soap skipped */
}

void ns2__DigitalOutputElement::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__DigitalOutputElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DigitalOutputElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DigitalOutputElement(struct soap *soap, const char *tag, int id, const ns2__DigitalOutputElement *a, const char *type)
{
	soap_set_attr(soap, "activity", soap_ns2__DigitalOutputActivity2s(soap, ((ns2__DigitalOutputElement*)a)->activity), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DigitalOutputElement), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DigitalOutputElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DigitalOutputElement(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DigitalOutputElement * SOAP_FMAC4 soap_in_ns2__DigitalOutputElement(struct soap *soap, const char *tag, ns2__DigitalOutputElement *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DigitalOutputElement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DigitalOutputElement, sizeof(ns2__DigitalOutputElement), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DigitalOutputElement)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DigitalOutputElement *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__DigitalOutputActivity(soap, soap_attr_value(soap, "activity", 1), &((ns2__DigitalOutputElement*)a)->activity))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DigitalOutputElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DigitalOutputElement, SOAP_TYPE_ns2__DigitalOutputElement, sizeof(ns2__DigitalOutputElement), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DigitalOutputElement * SOAP_FMAC2 soap_instantiate_ns2__DigitalOutputElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DigitalOutputElement(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DigitalOutputElement *p;
	size_t k = sizeof(ns2__DigitalOutputElement);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DigitalOutputElement);
		if (p)
			((ns2__DigitalOutputElement*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DigitalOutputElement, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DigitalOutputElement*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DigitalOutputElement location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DigitalOutputElement, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DigitalOutputElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__DigitalOutputElement(soap, tag ? tag : "ns2:DigitalOutputElement", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DigitalOutputElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DigitalOutputElement(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DigitalOutputElement * SOAP_FMAC4 soap_get_ns2__DigitalOutputElement(struct soap *soap, ns2__DigitalOutputElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DigitalOutputElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DigitalInputElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__DigitalInputValue(soap, &this->ns2__DigitalInputElement::value);
	/* transient soap skipped */
}

void ns2__DigitalInputElement::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__DigitalInputElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DigitalInputElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DigitalInputElement(struct soap *soap, const char *tag, int id, const ns2__DigitalInputElement *a, const char *type)
{
	soap_set_attr(soap, "value", soap_ns2__DigitalInputValue2s(soap, ((ns2__DigitalInputElement*)a)->value), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DigitalInputElement), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DigitalInputElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DigitalInputElement(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DigitalInputElement * SOAP_FMAC4 soap_in_ns2__DigitalInputElement(struct soap *soap, const char *tag, ns2__DigitalInputElement *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DigitalInputElement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DigitalInputElement, sizeof(ns2__DigitalInputElement), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DigitalInputElement)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DigitalInputElement *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__DigitalInputValue(soap, soap_attr_value(soap, "value", 1), &((ns2__DigitalInputElement*)a)->value))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DigitalInputElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DigitalInputElement, SOAP_TYPE_ns2__DigitalInputElement, sizeof(ns2__DigitalInputElement), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DigitalInputElement * SOAP_FMAC2 soap_instantiate_ns2__DigitalInputElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DigitalInputElement(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DigitalInputElement *p;
	size_t k = sizeof(ns2__DigitalInputElement);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DigitalInputElement);
		if (p)
			((ns2__DigitalInputElement*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DigitalInputElement, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DigitalInputElement*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DigitalInputElement location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DigitalInputElement, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DigitalInputElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns2__DigitalInputElement(soap, tag ? tag : "ns2:DigitalInputElement", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DigitalInputElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DigitalInputElement(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DigitalInputElement * SOAP_FMAC4 soap_get_ns2__DigitalInputElement(struct soap *soap, ns2__DigitalInputElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DigitalInputElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__decimal(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__wstring, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::wstring *p;
	size_t k = sizeof(std::wstring);
	if (n < 0)
	{	p = SOAP_NEW(std::wstring);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::wstring, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::wstring location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__wstring, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	if (soap_out_std__wstring(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	if (n < 0)
	{	p = SOAP_NEW(xsd__base64Binary);
		if (p)
			((xsd__base64Binary*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(xsd__base64Binary, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Error(struct soap *soap, struct __ns1__Error *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__error_USCOREmessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Error(struct soap *soap, const struct __ns1__Error *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__ErrorContainer(soap, &a->ns2__error_USCOREmessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Error(struct soap *soap, const char *tag, int id, const struct __ns1__Error *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__ErrorContainer(soap, "ns2:error_message", -1, &a->ns2__error_USCOREmessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Error * SOAP_FMAC4 soap_in___ns1__Error(struct soap *soap, const char *tag, struct __ns1__Error *a, const char *type)
{
	size_t soap_flag_ns2__error_USCOREmessage = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Error *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Error, sizeof(struct __ns1__Error), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Error(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__error_USCOREmessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ErrorContainer(soap, "ns2:error_message", &a->ns2__error_USCOREmessage, "ns2:ErrorContainer"))
				{	soap_flag_ns2__error_USCOREmessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Error * SOAP_FMAC2 soap_instantiate___ns1__Error(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Error(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Error *p;
	size_t k = sizeof(struct __ns1__Error);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Error);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Error, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Error location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__Error, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Error(struct soap *soap, const struct __ns1__Error *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Error(soap, tag ? tag : "-ns1:Error", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Error * SOAP_FMAC4 soap_get___ns1__Error(struct soap *soap, struct __ns1__Error *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Error(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Notification(struct soap *soap, struct __ns1__Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__notification_USCOREmessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Notification(struct soap *soap, const struct __ns1__Notification *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__NotificationContainer(soap, &a->ns2__notification_USCOREmessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Notification(struct soap *soap, const char *tag, int id, const struct __ns1__Notification *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTons2__NotificationContainer(soap, "ns2:notification_message", -1, &a->ns2__notification_USCOREmessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Notification * SOAP_FMAC4 soap_in___ns1__Notification(struct soap *soap, const char *tag, struct __ns1__Notification *a, const char *type)
{
	size_t soap_flag_ns2__notification_USCOREmessage = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Notification *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Notification, sizeof(struct __ns1__Notification), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Notification(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__notification_USCOREmessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NotificationContainer(soap, "ns2:notification_message", &a->ns2__notification_USCOREmessage, "ns2:NotificationContainer"))
				{	soap_flag_ns2__notification_USCOREmessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Notification * SOAP_FMAC2 soap_instantiate___ns1__Notification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Notification(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Notification *p;
	size_t k = sizeof(struct __ns1__Notification);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Notification);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Notification, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Notification location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__Notification, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Notification(struct soap *soap, const struct __ns1__Notification *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Notification(soap, tag ? tag : "-ns1:Notification", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Notification * SOAP_FMAC4 soap_get___ns1__Notification(struct soap *soap, struct __ns1__Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_TaskContainer(struct soap *soap, int choice, const union _ns2__union_TaskContainer *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns2__union_TaskContainer_task_USCORErequest_USCOREupdate:
		soap_serialize_PointerTons2__TaskRequestUpdate(soap, &a->task_USCORErequest_USCOREupdate);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCORErequest_USCOREparameters:
		soap_serialize_PointerTons2__TaskRequestParameters(soap, &a->task_USCORErequest_USCOREparameters);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCORElogfiles:
		soap_serialize_PointerTons2__TaskSubscribeLogfiles(soap, &a->task_USCOREsubscribe_USCORElogfiles);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREerror_USCORElog:
		soap_serialize_PointerTons2__TaskSubscribeErrorLog(soap, &a->task_USCOREsubscribe_USCOREerror_USCORElog);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREset_USCOREdigital_USCOREoutput:
		soap_serialize_PointerTons2__TaskSetDigitalOutput(soap, &a->task_USCOREset_USCOREdigital_USCOREoutput);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREset_USCOREdate_USCOREtime:
		soap_serialize_PointerTons2__TaskSetDateTime(soap, &a->task_USCOREset_USCOREdate_USCOREtime);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREcounting:
		soap_serialize_PointerTons2__TaskSubscribeCounting(soap, &a->task_USCOREsubscribe_USCOREcounting);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREfill:
		soap_serialize_PointerTons2__TaskSubscribeFill(soap, &a->task_USCOREsubscribe_USCOREfill);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREdigital_USCOREinput:
		soap_serialize_PointerTons2__TaskSubscribeDigitalInput(soap, &a->task_USCOREsubscribe_USCOREdigital_USCOREinput);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREcamera_USCOREimages:
		soap_serialize_PointerTons2__TaskSubscribeCameraImages(soap, &a->task_USCOREsubscribe_USCOREcamera_USCOREimages);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREsend_USCOREparameters:
		soap_serialize_PointerTons2__TaskSubscribeSendParameters(soap, &a->task_USCOREsubscribe_USCOREsend_USCOREparameters);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREvideo_USCOREstore:
		soap_serialize_PointerTons2__TaskSubscribeVideoStore(soap, &a->task_USCOREsubscribe_USCOREvideo_USCOREstore);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREalive:
		soap_serialize_PointerTons2__TaskSubscribeAlive(soap, &a->task_USCOREsubscribe_USCOREalive);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREobjlist:
		soap_serialize_PointerTons2__TaskSubscribeObjectList(soap, &a->task_USCOREsubscribe_USCOREobjlist);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREreboot_USCOREnow:
		soap_serialize_PointerTons2__TaskRebootNow(soap, &a->task_USCOREreboot_USCOREnow);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREclear_USCOREzone:
		soap_serialize_PointerTons2__TaskSubscribeClearZone(soap, &a->task_USCOREsubscribe_USCOREclear_USCOREzone);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREcount_USCOREchannels:
		soap_serialize_PointerTons2__TaskSubscribeCountChannels(soap, &a->task_USCOREsubscribe_USCOREcount_USCOREchannels);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREzone_USCOREchannels:
		soap_serialize_PointerTons2__TaskSubscribeZoneChannels(soap, &a->task_USCOREsubscribe_USCOREzone_USCOREchannels);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREfeatures_USCOREinfo:
		soap_serialize_PointerTons2__TaskSubscribeFeaturesInfo(soap, &a->task_USCOREsubscribe_USCOREfeatures_USCOREinfo);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREdelete_USCOREall_USCOREtasks:
		soap_serialize_PointerTons2__TaskDeleteAllTasks(soap, &a->task_USCOREdelete_USCOREall_USCOREtasks);
		break;
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREdelete_USCOREall_USCOREnotifications:
		soap_serialize_PointerTons2__TaskDeleteAllNotifications(soap, &a->task_USCOREdelete_USCOREall_USCOREnotifications);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_TaskContainer(struct soap *soap, int choice, const union _ns2__union_TaskContainer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_TaskContainer_task_USCORErequest_USCOREupdate:
		return soap_out_PointerTons2__TaskRequestUpdate(soap, "ns2:task_request_update", -1, &a->task_USCORErequest_USCOREupdate, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCORErequest_USCOREparameters:
		return soap_out_PointerTons2__TaskRequestParameters(soap, "ns2:task_request_parameters", -1, &a->task_USCORErequest_USCOREparameters, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCORElogfiles:
		return soap_out_PointerTons2__TaskSubscribeLogfiles(soap, "ns2:task_subscribe_logfiles", -1, &a->task_USCOREsubscribe_USCORElogfiles, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREerror_USCORElog:
		return soap_out_PointerTons2__TaskSubscribeErrorLog(soap, "ns2:task_subscribe_error_log", -1, &a->task_USCOREsubscribe_USCOREerror_USCORElog, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREset_USCOREdigital_USCOREoutput:
		return soap_out_PointerTons2__TaskSetDigitalOutput(soap, "ns2:task_set_digital_output", -1, &a->task_USCOREset_USCOREdigital_USCOREoutput, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREset_USCOREdate_USCOREtime:
		return soap_out_PointerTons2__TaskSetDateTime(soap, "ns2:task_set_date_time", -1, &a->task_USCOREset_USCOREdate_USCOREtime, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREcounting:
		return soap_out_PointerTons2__TaskSubscribeCounting(soap, "ns2:task_subscribe_counting", -1, &a->task_USCOREsubscribe_USCOREcounting, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREfill:
		return soap_out_PointerTons2__TaskSubscribeFill(soap, "ns2:task_subscribe_fill", -1, &a->task_USCOREsubscribe_USCOREfill, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREdigital_USCOREinput:
		return soap_out_PointerTons2__TaskSubscribeDigitalInput(soap, "ns2:task_subscribe_digital_input", -1, &a->task_USCOREsubscribe_USCOREdigital_USCOREinput, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREcamera_USCOREimages:
		return soap_out_PointerTons2__TaskSubscribeCameraImages(soap, "ns2:task_subscribe_camera_images", -1, &a->task_USCOREsubscribe_USCOREcamera_USCOREimages, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREsend_USCOREparameters:
		return soap_out_PointerTons2__TaskSubscribeSendParameters(soap, "ns2:task_subscribe_send_parameters", -1, &a->task_USCOREsubscribe_USCOREsend_USCOREparameters, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREvideo_USCOREstore:
		return soap_out_PointerTons2__TaskSubscribeVideoStore(soap, "ns2:task_subscribe_video_store", -1, &a->task_USCOREsubscribe_USCOREvideo_USCOREstore, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREalive:
		return soap_out_PointerTons2__TaskSubscribeAlive(soap, "ns2:task_subscribe_alive", -1, &a->task_USCOREsubscribe_USCOREalive, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREobjlist:
		return soap_out_PointerTons2__TaskSubscribeObjectList(soap, "ns2:task_subscribe_objlist", -1, &a->task_USCOREsubscribe_USCOREobjlist, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREreboot_USCOREnow:
		return soap_out_PointerTons2__TaskRebootNow(soap, "ns2:task_reboot_now", -1, &a->task_USCOREreboot_USCOREnow, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREclear_USCOREzone:
		return soap_out_PointerTons2__TaskSubscribeClearZone(soap, "ns2:task_subscribe_clear_zone", -1, &a->task_USCOREsubscribe_USCOREclear_USCOREzone, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREcount_USCOREchannels:
		return soap_out_PointerTons2__TaskSubscribeCountChannels(soap, "ns2:task_subscribe_count_channels", -1, &a->task_USCOREsubscribe_USCOREcount_USCOREchannels, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREzone_USCOREchannels:
		return soap_out_PointerTons2__TaskSubscribeZoneChannels(soap, "ns2:task_subscribe_zone_channels", -1, &a->task_USCOREsubscribe_USCOREzone_USCOREchannels, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREfeatures_USCOREinfo:
		return soap_out_PointerTons2__TaskSubscribeFeaturesInfo(soap, "ns2:task_subscribe_features_info", -1, &a->task_USCOREsubscribe_USCOREfeatures_USCOREinfo, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREdelete_USCOREall_USCOREtasks:
		return soap_out_PointerTons2__TaskDeleteAllTasks(soap, "ns2:task_delete_all_tasks", -1, &a->task_USCOREdelete_USCOREall_USCOREtasks, "");
	case SOAP_UNION__ns2__union_TaskContainer_task_USCOREdelete_USCOREall_USCOREnotifications:
		return soap_out_PointerTons2__TaskDeleteAllNotifications(soap, "ns2:task_delete_all_notifications", -1, &a->task_USCOREdelete_USCOREall_USCOREnotifications, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_TaskContainer * SOAP_FMAC4 soap_in__ns2__union_TaskContainer(struct soap *soap, int *choice, union _ns2__union_TaskContainer *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->task_USCORErequest_USCOREupdate = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskRequestUpdate(soap, "ns2:task_request_update", &a->task_USCORErequest_USCOREupdate, "ns2:TaskRequestUpdate"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCORErequest_USCOREupdate;
		return a;
	}
	a->task_USCORErequest_USCOREparameters = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskRequestParameters(soap, "ns2:task_request_parameters", &a->task_USCORErequest_USCOREparameters, "ns2:TaskRequestParameters"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCORErequest_USCOREparameters;
		return a;
	}
	a->task_USCOREsubscribe_USCORElogfiles = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeLogfiles(soap, "ns2:task_subscribe_logfiles", &a->task_USCOREsubscribe_USCORElogfiles, "ns2:TaskSubscribeLogfiles"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCORElogfiles;
		return a;
	}
	a->task_USCOREsubscribe_USCOREerror_USCORElog = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeErrorLog(soap, "ns2:task_subscribe_error_log", &a->task_USCOREsubscribe_USCOREerror_USCORElog, "ns2:TaskSubscribeErrorLog"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREerror_USCORElog;
		return a;
	}
	a->task_USCOREset_USCOREdigital_USCOREoutput = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSetDigitalOutput(soap, "ns2:task_set_digital_output", &a->task_USCOREset_USCOREdigital_USCOREoutput, "ns2:TaskSetDigitalOutput"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREset_USCOREdigital_USCOREoutput;
		return a;
	}
	a->task_USCOREset_USCOREdate_USCOREtime = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSetDateTime(soap, "ns2:task_set_date_time", &a->task_USCOREset_USCOREdate_USCOREtime, "ns2:TaskSetDateTime"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREset_USCOREdate_USCOREtime;
		return a;
	}
	a->task_USCOREsubscribe_USCOREcounting = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeCounting(soap, "ns2:task_subscribe_counting", &a->task_USCOREsubscribe_USCOREcounting, "ns2:TaskSubscribeCounting"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREcounting;
		return a;
	}
	a->task_USCOREsubscribe_USCOREfill = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeFill(soap, "ns2:task_subscribe_fill", &a->task_USCOREsubscribe_USCOREfill, "ns2:TaskSubscribeFill"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREfill;
		return a;
	}
	a->task_USCOREsubscribe_USCOREdigital_USCOREinput = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeDigitalInput(soap, "ns2:task_subscribe_digital_input", &a->task_USCOREsubscribe_USCOREdigital_USCOREinput, "ns2:TaskSubscribeDigitalInput"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREdigital_USCOREinput;
		return a;
	}
	a->task_USCOREsubscribe_USCOREcamera_USCOREimages = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeCameraImages(soap, "ns2:task_subscribe_camera_images", &a->task_USCOREsubscribe_USCOREcamera_USCOREimages, "ns2:TaskSubscribeCameraImages"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREcamera_USCOREimages;
		return a;
	}
	a->task_USCOREsubscribe_USCOREsend_USCOREparameters = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeSendParameters(soap, "ns2:task_subscribe_send_parameters", &a->task_USCOREsubscribe_USCOREsend_USCOREparameters, "ns2:TaskSubscribeSendParameters"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREsend_USCOREparameters;
		return a;
	}
	a->task_USCOREsubscribe_USCOREvideo_USCOREstore = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeVideoStore(soap, "ns2:task_subscribe_video_store", &a->task_USCOREsubscribe_USCOREvideo_USCOREstore, "ns2:TaskSubscribeVideoStore"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREvideo_USCOREstore;
		return a;
	}
	a->task_USCOREsubscribe_USCOREalive = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeAlive(soap, "ns2:task_subscribe_alive", &a->task_USCOREsubscribe_USCOREalive, "ns2:TaskSubscribeAlive"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREalive;
		return a;
	}
	a->task_USCOREsubscribe_USCOREobjlist = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeObjectList(soap, "ns2:task_subscribe_objlist", &a->task_USCOREsubscribe_USCOREobjlist, "ns2:TaskSubscribeObjectList"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREobjlist;
		return a;
	}
	a->task_USCOREreboot_USCOREnow = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskRebootNow(soap, "ns2:task_reboot_now", &a->task_USCOREreboot_USCOREnow, "ns2:TaskRebootNow"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREreboot_USCOREnow;
		return a;
	}
	a->task_USCOREsubscribe_USCOREclear_USCOREzone = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeClearZone(soap, "ns2:task_subscribe_clear_zone", &a->task_USCOREsubscribe_USCOREclear_USCOREzone, "ns2:TaskSubscribeClearZone"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREclear_USCOREzone;
		return a;
	}
	a->task_USCOREsubscribe_USCOREcount_USCOREchannels = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeCountChannels(soap, "ns2:task_subscribe_count_channels", &a->task_USCOREsubscribe_USCOREcount_USCOREchannels, "ns2:TaskSubscribeCountChannels"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREcount_USCOREchannels;
		return a;
	}
	a->task_USCOREsubscribe_USCOREzone_USCOREchannels = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeZoneChannels(soap, "ns2:task_subscribe_zone_channels", &a->task_USCOREsubscribe_USCOREzone_USCOREchannels, "ns2:TaskSubscribeZoneChannels"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREzone_USCOREchannels;
		return a;
	}
	a->task_USCOREsubscribe_USCOREfeatures_USCOREinfo = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskSubscribeFeaturesInfo(soap, "ns2:task_subscribe_features_info", &a->task_USCOREsubscribe_USCOREfeatures_USCOREinfo, "ns2:TaskSubscribeFeaturesInfo"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREsubscribe_USCOREfeatures_USCOREinfo;
		return a;
	}
	a->task_USCOREdelete_USCOREall_USCOREtasks = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskDeleteAllTasks(soap, "ns2:task_delete_all_tasks", &a->task_USCOREdelete_USCOREall_USCOREtasks, "ns2:TaskDeleteAllTasks"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREdelete_USCOREall_USCOREtasks;
		return a;
	}
	a->task_USCOREdelete_USCOREall_USCOREnotifications = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TaskDeleteAllNotifications(soap, "ns2:task_delete_all_notifications", &a->task_USCOREdelete_USCOREall_USCOREnotifications, "ns2:TaskDeleteAllNotifications"))
	{	*choice = SOAP_UNION__ns2__union_TaskContainer_task_USCOREdelete_USCOREall_USCOREnotifications;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_NotificationContainer(struct soap *soap, int choice, const union _ns2__union_NotificationContainer *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns2__union_NotificationContainer_count_USCOREnotification:
		soap_serialize_PointerTons2__CountNotification(soap, &a->count_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_fill_USCOREnotification:
		soap_serialize_PointerTons2__FillNotification(soap, &a->fill_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_digital_USCOREinput_USCOREnotification:
		soap_serialize_PointerTons2__DigitalInputNotification(soap, &a->digital_USCOREinput_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_camera_USCOREimages_USCOREnotification:
		soap_serialize_PointerTons2__CameraImagesNotification(soap, &a->camera_USCOREimages_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_parameter_USCOREnotification:
		soap_serialize_PointerTons2__ParameterNotification(soap, &a->parameter_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_logfiles_USCOREnotification:
		soap_serialize_PointerTons2__LogfilesNotification(soap, &a->logfiles_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_error_USCORElogfiles_USCOREnotification:
		soap_serialize_PointerTons2__ErrorLogfilesNotification(soap, &a->error_USCORElogfiles_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_alive_USCOREnotification:
		soap_serialize_PointerTons2__AliveNotification(soap, &a->alive_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_curr_USCOREobjlist_USCOREnotification:
		soap_serialize_PointerTons2__CurrentObjectListNotification(soap, &a->curr_USCOREobjlist_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_hist_USCOREobjlist_USCOREnotification:
		soap_serialize_PointerTons2__HistoricObjectListNotification(soap, &a->hist_USCOREobjlist_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_startup_USCOREnotification:
		soap_serialize_PointerTons2__StartupNotification(soap, &a->startup_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_clear_USCOREzone_USCOREnotification:
		soap_serialize_PointerTons2__ClearZoneNotification(soap, &a->clear_USCOREzone_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_count_USCOREchannels_USCOREnotification:
		soap_serialize_PointerTons2__CountChannelsNotification(soap, &a->count_USCOREchannels_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_zone_USCOREchannels_USCOREnotification:
		soap_serialize_PointerTons2__ZoneChannelsNotification(soap, &a->zone_USCOREchannels_USCOREnotification);
		break;
	case SOAP_UNION__ns2__union_NotificationContainer_features_USCOREinfo_USCOREnotification:
		soap_serialize_PointerTons2__FeatureInfoNotification(soap, &a->features_USCOREinfo_USCOREnotification);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_NotificationContainer(struct soap *soap, int choice, const union _ns2__union_NotificationContainer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_NotificationContainer_count_USCOREnotification:
		return soap_out_PointerTons2__CountNotification(soap, "ns2:count_notification", -1, &a->count_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_fill_USCOREnotification:
		return soap_out_PointerTons2__FillNotification(soap, "ns2:fill_notification", -1, &a->fill_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_digital_USCOREinput_USCOREnotification:
		return soap_out_PointerTons2__DigitalInputNotification(soap, "ns2:digital_input_notification", -1, &a->digital_USCOREinput_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_camera_USCOREimages_USCOREnotification:
		return soap_out_PointerTons2__CameraImagesNotification(soap, "ns2:camera_images_notification", -1, &a->camera_USCOREimages_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_parameter_USCOREnotification:
		return soap_out_PointerTons2__ParameterNotification(soap, "ns2:parameter_notification", -1, &a->parameter_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_logfiles_USCOREnotification:
		return soap_out_PointerTons2__LogfilesNotification(soap, "ns2:logfiles_notification", -1, &a->logfiles_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_error_USCORElogfiles_USCOREnotification:
		return soap_out_PointerTons2__ErrorLogfilesNotification(soap, "ns2:error_logfiles_notification", -1, &a->error_USCORElogfiles_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_alive_USCOREnotification:
		return soap_out_PointerTons2__AliveNotification(soap, "ns2:alive_notification", -1, &a->alive_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_curr_USCOREobjlist_USCOREnotification:
		return soap_out_PointerTons2__CurrentObjectListNotification(soap, "ns2:curr_objlist_notification", -1, &a->curr_USCOREobjlist_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_hist_USCOREobjlist_USCOREnotification:
		return soap_out_PointerTons2__HistoricObjectListNotification(soap, "ns2:hist_objlist_notification", -1, &a->hist_USCOREobjlist_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_startup_USCOREnotification:
		return soap_out_PointerTons2__StartupNotification(soap, "ns2:startup_notification", -1, &a->startup_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_clear_USCOREzone_USCOREnotification:
		return soap_out_PointerTons2__ClearZoneNotification(soap, "ns2:clear_zone_notification", -1, &a->clear_USCOREzone_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_count_USCOREchannels_USCOREnotification:
		return soap_out_PointerTons2__CountChannelsNotification(soap, "ns2:count_channels_notification", -1, &a->count_USCOREchannels_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_zone_USCOREchannels_USCOREnotification:
		return soap_out_PointerTons2__ZoneChannelsNotification(soap, "ns2:zone_channels_notification", -1, &a->zone_USCOREchannels_USCOREnotification, "");
	case SOAP_UNION__ns2__union_NotificationContainer_features_USCOREinfo_USCOREnotification:
		return soap_out_PointerTons2__FeatureInfoNotification(soap, "ns2:features_info_notification", -1, &a->features_USCOREinfo_USCOREnotification, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_NotificationContainer * SOAP_FMAC4 soap_in__ns2__union_NotificationContainer(struct soap *soap, int *choice, union _ns2__union_NotificationContainer *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->count_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CountNotification(soap, "ns2:count_notification", &a->count_USCOREnotification, "ns2:CountNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_count_USCOREnotification;
		return a;
	}
	a->fill_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__FillNotification(soap, "ns2:fill_notification", &a->fill_USCOREnotification, "ns2:FillNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_fill_USCOREnotification;
		return a;
	}
	a->digital_USCOREinput_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__DigitalInputNotification(soap, "ns2:digital_input_notification", &a->digital_USCOREinput_USCOREnotification, "ns2:DigitalInputNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_digital_USCOREinput_USCOREnotification;
		return a;
	}
	a->camera_USCOREimages_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CameraImagesNotification(soap, "ns2:camera_images_notification", &a->camera_USCOREimages_USCOREnotification, "ns2:CameraImagesNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_camera_USCOREimages_USCOREnotification;
		return a;
	}
	a->parameter_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ParameterNotification(soap, "ns2:parameter_notification", &a->parameter_USCOREnotification, "ns2:ParameterNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_parameter_USCOREnotification;
		return a;
	}
	a->logfiles_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__LogfilesNotification(soap, "ns2:logfiles_notification", &a->logfiles_USCOREnotification, "ns2:LogfilesNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_logfiles_USCOREnotification;
		return a;
	}
	a->error_USCORElogfiles_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ErrorLogfilesNotification(soap, "ns2:error_logfiles_notification", &a->error_USCORElogfiles_USCOREnotification, "ns2:ErrorLogfilesNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_error_USCORElogfiles_USCOREnotification;
		return a;
	}
	a->alive_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__AliveNotification(soap, "ns2:alive_notification", &a->alive_USCOREnotification, "ns2:AliveNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_alive_USCOREnotification;
		return a;
	}
	a->curr_USCOREobjlist_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CurrentObjectListNotification(soap, "ns2:curr_objlist_notification", &a->curr_USCOREobjlist_USCOREnotification, "ns2:CurrentObjectListNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_curr_USCOREobjlist_USCOREnotification;
		return a;
	}
	a->hist_USCOREobjlist_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__HistoricObjectListNotification(soap, "ns2:hist_objlist_notification", &a->hist_USCOREobjlist_USCOREnotification, "ns2:HistoricObjectListNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_hist_USCOREobjlist_USCOREnotification;
		return a;
	}
	a->startup_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__StartupNotification(soap, "ns2:startup_notification", &a->startup_USCOREnotification, "ns2:StartupNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_startup_USCOREnotification;
		return a;
	}
	a->clear_USCOREzone_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ClearZoneNotification(soap, "ns2:clear_zone_notification", &a->clear_USCOREzone_USCOREnotification, "ns2:ClearZoneNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_clear_USCOREzone_USCOREnotification;
		return a;
	}
	a->count_USCOREchannels_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CountChannelsNotification(soap, "ns2:count_channels_notification", &a->count_USCOREchannels_USCOREnotification, "ns2:CountChannelsNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_count_USCOREchannels_USCOREnotification;
		return a;
	}
	a->zone_USCOREchannels_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ZoneChannelsNotification(soap, "ns2:zone_channels_notification", &a->zone_USCOREchannels_USCOREnotification, "ns2:ZoneChannelsNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_zone_USCOREchannels_USCOREnotification;
		return a;
	}
	a->features_USCOREinfo_USCOREnotification = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__FeatureInfoNotification(soap, "ns2:features_info_notification", &a->features_USCOREinfo_USCOREnotification, "ns2:FeatureInfoNotification"))
	{	*choice = SOAP_UNION__ns2__union_NotificationContainer_features_USCOREinfo_USCOREnotification;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_Trigger(struct soap *soap, int choice, const union _ns2__union_Trigger *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns2__union_Trigger_event_USCOREtrigger:
		soap_serialize_PointerTons2__EventTrigger(soap, &a->event_USCOREtrigger);
		break;
	case SOAP_UNION__ns2__union_Trigger_time_USCOREtrigger:
		soap_serialize_PointerTons2__TimeTrigger(soap, &a->time_USCOREtrigger);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_Trigger(struct soap *soap, int choice, const union _ns2__union_Trigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_Trigger_event_USCOREtrigger:
		return soap_out_PointerTons2__EventTrigger(soap, "ns2:event_trigger", -1, &a->event_USCOREtrigger, "");
	case SOAP_UNION__ns2__union_Trigger_time_USCOREtrigger:
		return soap_out_PointerTons2__TimeTrigger(soap, "ns2:time_trigger", -1, &a->time_USCOREtrigger, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_Trigger * SOAP_FMAC4 soap_in__ns2__union_Trigger(struct soap *soap, int *choice, union _ns2__union_Trigger *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->event_USCOREtrigger = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__EventTrigger(soap, "ns2:event_trigger", &a->event_USCOREtrigger, "ns2:EventTrigger"))
	{	*choice = SOAP_UNION__ns2__union_Trigger_event_USCOREtrigger;
		return a;
	}
	a->time_USCOREtrigger = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__TimeTrigger(soap, "ns2:time_trigger", &a->time_USCOREtrigger, "ns2:TimeTrigger"))
	{	*choice = SOAP_UNION__ns2__union_Trigger_time_USCOREtrigger;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_EventTrigger(struct soap *soap, int choice, const union _ns2__union_EventTrigger *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns2__union_EventTrigger_count_USCOREevent:
		soap_serialize_PointerTons2__CountEvent(soap, &a->count_USCOREevent);
		break;
	case SOAP_UNION__ns2__union_EventTrigger_fill_USCOREevent:
		soap_serialize_PointerTons2__FillEvent(soap, &a->fill_USCOREevent);
		break;
	case SOAP_UNION__ns2__union_EventTrigger_digital_USCOREinput_USCOREevent:
		soap_serialize_PointerTons2__DigitalInputEvent(soap, &a->digital_USCOREinput_USCOREevent);
		break;
	case SOAP_UNION__ns2__union_EventTrigger_one_USCOREtime_USCOREevent:
		soap_serialize_PointerTons2__OneTimeEvent(soap, &a->one_USCOREtime_USCOREevent);
		break;
	case SOAP_UNION__ns2__union_EventTrigger_osd_USCOREevent:
		soap_serialize_PointerTons2__OSD_USCOREEvent(soap, &a->osd_USCOREevent);
		break;
	case SOAP_UNION__ns2__union_EventTrigger_current_USCOREobject_USCORElist_USCOREevent:
		soap_serialize_PointerTons2__CurrentObjectListEvent(soap, &a->current_USCOREobject_USCORElist_USCOREevent);
		break;
	case SOAP_UNION__ns2__union_EventTrigger_clear_USCOREzone_USCOREevent:
		soap_serialize_PointerTons2__ClearZoneEvent(soap, &a->clear_USCOREzone_USCOREevent);
		break;
	case SOAP_UNION__ns2__union_EventTrigger_count_USCOREchannels_USCOREevent:
		soap_serialize_PointerTons2__CountChannelsEvent(soap, &a->count_USCOREchannels_USCOREevent);
		break;
	case SOAP_UNION__ns2__union_EventTrigger_zone_USCOREchannels_USCOREevent:
		soap_serialize_PointerTons2__ZoneChannelsEvent(soap, &a->zone_USCOREchannels_USCOREevent);
		break;
	case SOAP_UNION__ns2__union_EventTrigger_feature_USCOREchanged_USCOREevent:
		soap_serialize_PointerTons2__FeatureChangedEvent(soap, &a->feature_USCOREchanged_USCOREevent);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_EventTrigger(struct soap *soap, int choice, const union _ns2__union_EventTrigger *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_EventTrigger_count_USCOREevent:
		return soap_out_PointerTons2__CountEvent(soap, "ns2:count_event", -1, &a->count_USCOREevent, "");
	case SOAP_UNION__ns2__union_EventTrigger_fill_USCOREevent:
		return soap_out_PointerTons2__FillEvent(soap, "ns2:fill_event", -1, &a->fill_USCOREevent, "");
	case SOAP_UNION__ns2__union_EventTrigger_digital_USCOREinput_USCOREevent:
		return soap_out_PointerTons2__DigitalInputEvent(soap, "ns2:digital_input_event", -1, &a->digital_USCOREinput_USCOREevent, "");
	case SOAP_UNION__ns2__union_EventTrigger_one_USCOREtime_USCOREevent:
		return soap_out_PointerTons2__OneTimeEvent(soap, "ns2:one_time_event", -1, &a->one_USCOREtime_USCOREevent, "");
	case SOAP_UNION__ns2__union_EventTrigger_osd_USCOREevent:
		return soap_out_PointerTons2__OSD_USCOREEvent(soap, "ns2:osd_event", -1, &a->osd_USCOREevent, "");
	case SOAP_UNION__ns2__union_EventTrigger_current_USCOREobject_USCORElist_USCOREevent:
		return soap_out_PointerTons2__CurrentObjectListEvent(soap, "ns2:current_object_list_event", -1, &a->current_USCOREobject_USCORElist_USCOREevent, "");
	case SOAP_UNION__ns2__union_EventTrigger_clear_USCOREzone_USCOREevent:
		return soap_out_PointerTons2__ClearZoneEvent(soap, "ns2:clear_zone_event", -1, &a->clear_USCOREzone_USCOREevent, "");
	case SOAP_UNION__ns2__union_EventTrigger_count_USCOREchannels_USCOREevent:
		return soap_out_PointerTons2__CountChannelsEvent(soap, "ns2:count_channels_event", -1, &a->count_USCOREchannels_USCOREevent, "");
	case SOAP_UNION__ns2__union_EventTrigger_zone_USCOREchannels_USCOREevent:
		return soap_out_PointerTons2__ZoneChannelsEvent(soap, "ns2:zone_channels_event", -1, &a->zone_USCOREchannels_USCOREevent, "");
	case SOAP_UNION__ns2__union_EventTrigger_feature_USCOREchanged_USCOREevent:
		return soap_out_PointerTons2__FeatureChangedEvent(soap, "ns2:feature_changed_event", -1, &a->feature_USCOREchanged_USCOREevent, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_EventTrigger * SOAP_FMAC4 soap_in__ns2__union_EventTrigger(struct soap *soap, int *choice, union _ns2__union_EventTrigger *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->count_USCOREevent = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CountEvent(soap, "ns2:count_event", &a->count_USCOREevent, "ns2:CountEvent"))
	{	*choice = SOAP_UNION__ns2__union_EventTrigger_count_USCOREevent;
		return a;
	}
	a->fill_USCOREevent = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__FillEvent(soap, "ns2:fill_event", &a->fill_USCOREevent, "ns2:FillEvent"))
	{	*choice = SOAP_UNION__ns2__union_EventTrigger_fill_USCOREevent;
		return a;
	}
	a->digital_USCOREinput_USCOREevent = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__DigitalInputEvent(soap, "ns2:digital_input_event", &a->digital_USCOREinput_USCOREevent, "ns2:DigitalInputEvent"))
	{	*choice = SOAP_UNION__ns2__union_EventTrigger_digital_USCOREinput_USCOREevent;
		return a;
	}
	a->one_USCOREtime_USCOREevent = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__OneTimeEvent(soap, "ns2:one_time_event", &a->one_USCOREtime_USCOREevent, "ns2:OneTimeEvent"))
	{	*choice = SOAP_UNION__ns2__union_EventTrigger_one_USCOREtime_USCOREevent;
		return a;
	}
	a->osd_USCOREevent = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__OSD_USCOREEvent(soap, "ns2:osd_event", &a->osd_USCOREevent, "ns2:OSD_Event"))
	{	*choice = SOAP_UNION__ns2__union_EventTrigger_osd_USCOREevent;
		return a;
	}
	a->current_USCOREobject_USCORElist_USCOREevent = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CurrentObjectListEvent(soap, "ns2:current_object_list_event", &a->current_USCOREobject_USCORElist_USCOREevent, "ns2:CurrentObjectListEvent"))
	{	*choice = SOAP_UNION__ns2__union_EventTrigger_current_USCOREobject_USCORElist_USCOREevent;
		return a;
	}
	a->clear_USCOREzone_USCOREevent = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ClearZoneEvent(soap, "ns2:clear_zone_event", &a->clear_USCOREzone_USCOREevent, "ns2:ClearZoneEvent"))
	{	*choice = SOAP_UNION__ns2__union_EventTrigger_clear_USCOREzone_USCOREevent;
		return a;
	}
	a->count_USCOREchannels_USCOREevent = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CountChannelsEvent(soap, "ns2:count_channels_event", &a->count_USCOREchannels_USCOREevent, "ns2:CountChannelsEvent"))
	{	*choice = SOAP_UNION__ns2__union_EventTrigger_count_USCOREchannels_USCOREevent;
		return a;
	}
	a->zone_USCOREchannels_USCOREevent = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ZoneChannelsEvent(soap, "ns2:zone_channels_event", &a->zone_USCOREchannels_USCOREevent, "ns2:ZoneChannelsEvent"))
	{	*choice = SOAP_UNION__ns2__union_EventTrigger_zone_USCOREchannels_USCOREevent;
		return a;
	}
	a->feature_USCOREchanged_USCOREevent = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__FeatureChangedEvent(soap, "ns2:feature_changed_event", &a->feature_USCOREchanged_USCOREevent, "ns2:FeatureChangedEvent"))
	{	*choice = SOAP_UNION__ns2__union_EventTrigger_feature_USCOREchanged_USCOREevent;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ErrorContainer(struct soap *soap, ns2__ErrorContainer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ErrorContainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ErrorContainer(struct soap *soap, const char *tag, int id, ns2__ErrorContainer *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ErrorContainer, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ErrorContainer ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__ErrorContainer ** SOAP_FMAC4 soap_in_PointerTons2__ErrorContainer(struct soap *soap, const char *tag, ns2__ErrorContainer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ErrorContainer **)soap_malloc(soap, sizeof(ns2__ErrorContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ErrorContainer *)soap_instantiate_ns2__ErrorContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ErrorContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ErrorContainer, sizeof(ns2__ErrorContainer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ErrorContainer(struct soap *soap, ns2__ErrorContainer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ErrorContainer(soap, tag ? tag : "ns2:ErrorContainer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ErrorContainer ** SOAP_FMAC4 soap_get_PointerTons2__ErrorContainer(struct soap *soap, ns2__ErrorContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ErrorContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NotificationContainer(struct soap *soap, ns2__NotificationContainer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NotificationContainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NotificationContainer(struct soap *soap, const char *tag, int id, ns2__NotificationContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NotificationContainer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__NotificationContainer ? type : NULL);
}

SOAP_FMAC3 ns2__NotificationContainer ** SOAP_FMAC4 soap_in_PointerTons2__NotificationContainer(struct soap *soap, const char *tag, ns2__NotificationContainer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NotificationContainer **)soap_malloc(soap, sizeof(ns2__NotificationContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NotificationContainer *)soap_instantiate_ns2__NotificationContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__NotificationContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NotificationContainer, sizeof(ns2__NotificationContainer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NotificationContainer(struct soap *soap, ns2__NotificationContainer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__NotificationContainer(soap, tag ? tag : "ns2:NotificationContainer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NotificationContainer ** SOAP_FMAC4 soap_get_PointerTons2__NotificationContainer(struct soap *soap, ns2__NotificationContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NotificationContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__DigitalInputControl(struct soap *soap, ns2__DigitalInputControl **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__DigitalInputControl))
		soap_serialize_PointerTons2__DigitalInputControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__DigitalInputControl(struct soap *soap, const char *tag, int id, ns2__DigitalInputControl **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__DigitalInputControl, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__DigitalInputControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__DigitalInputControl *** SOAP_FMAC4 soap_in_PointerToPointerTons2__DigitalInputControl(struct soap *soap, const char *tag, ns2__DigitalInputControl ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DigitalInputControl ***)soap_malloc(soap, sizeof(ns2__DigitalInputControl **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__DigitalInputControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__DigitalInputControl ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DigitalInputControl, sizeof(ns2__DigitalInputControl), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__DigitalInputControl(struct soap *soap, ns2__DigitalInputControl **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons2__DigitalInputControl(soap, tag ? tag : "ns2:DigitalInputControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DigitalInputControl *** SOAP_FMAC4 soap_get_PointerToPointerTons2__DigitalInputControl(struct soap *soap, ns2__DigitalInputControl ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__DigitalInputControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DigitalInputControl(struct soap *soap, ns2__DigitalInputControl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DigitalInputControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DigitalInputControl(struct soap *soap, const char *tag, int id, ns2__DigitalInputControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DigitalInputControl, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__DigitalInputControl ? type : NULL);
}

SOAP_FMAC3 ns2__DigitalInputControl ** SOAP_FMAC4 soap_in_PointerTons2__DigitalInputControl(struct soap *soap, const char *tag, ns2__DigitalInputControl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DigitalInputControl **)soap_malloc(soap, sizeof(ns2__DigitalInputControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DigitalInputControl *)soap_instantiate_ns2__DigitalInputControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DigitalInputControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DigitalInputControl, sizeof(ns2__DigitalInputControl), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DigitalInputControl(struct soap *soap, ns2__DigitalInputControl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DigitalInputControl(soap, tag ? tag : "ns2:DigitalInputControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DigitalInputControl ** SOAP_FMAC4 soap_get_PointerTons2__DigitalInputControl(struct soap *soap, ns2__DigitalInputControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DigitalInputControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstring(struct soap *soap, wchar_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wstring);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_wstring);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	a = soap_inwstring(soap, tag, a, type, SOAP_TYPE_wstring, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	if (soap_out_wstring(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ZoneChannelsFeatureInfo(struct soap *soap, ns2__ZoneChannelsFeatureInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ZoneChannelsFeatureInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ZoneChannelsFeatureInfo(struct soap *soap, const char *tag, int id, ns2__ZoneChannelsFeatureInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ZoneChannelsFeatureInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ZoneChannelsFeatureInfo ? type : NULL);
}

SOAP_FMAC3 ns2__ZoneChannelsFeatureInfo ** SOAP_FMAC4 soap_in_PointerTons2__ZoneChannelsFeatureInfo(struct soap *soap, const char *tag, ns2__ZoneChannelsFeatureInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ZoneChannelsFeatureInfo **)soap_malloc(soap, sizeof(ns2__ZoneChannelsFeatureInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ZoneChannelsFeatureInfo *)soap_instantiate_ns2__ZoneChannelsFeatureInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ZoneChannelsFeatureInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ZoneChannelsFeatureInfo, sizeof(ns2__ZoneChannelsFeatureInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ZoneChannelsFeatureInfo(struct soap *soap, ns2__ZoneChannelsFeatureInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ZoneChannelsFeatureInfo(soap, tag ? tag : "ns2:ZoneChannelsFeatureInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ZoneChannelsFeatureInfo ** SOAP_FMAC4 soap_get_PointerTons2__ZoneChannelsFeatureInfo(struct soap *soap, ns2__ZoneChannelsFeatureInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ZoneChannelsFeatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CountChannelsFeatureInfo(struct soap *soap, ns2__CountChannelsFeatureInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CountChannelsFeatureInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CountChannelsFeatureInfo(struct soap *soap, const char *tag, int id, ns2__CountChannelsFeatureInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CountChannelsFeatureInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CountChannelsFeatureInfo ? type : NULL);
}

SOAP_FMAC3 ns2__CountChannelsFeatureInfo ** SOAP_FMAC4 soap_in_PointerTons2__CountChannelsFeatureInfo(struct soap *soap, const char *tag, ns2__CountChannelsFeatureInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CountChannelsFeatureInfo **)soap_malloc(soap, sizeof(ns2__CountChannelsFeatureInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CountChannelsFeatureInfo *)soap_instantiate_ns2__CountChannelsFeatureInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CountChannelsFeatureInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CountChannelsFeatureInfo, sizeof(ns2__CountChannelsFeatureInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CountChannelsFeatureInfo(struct soap *soap, ns2__CountChannelsFeatureInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CountChannelsFeatureInfo(soap, tag ? tag : "ns2:CountChannelsFeatureInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CountChannelsFeatureInfo ** SOAP_FMAC4 soap_get_PointerTons2__CountChannelsFeatureInfo(struct soap *soap, ns2__CountChannelsFeatureInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CountChannelsFeatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Trigger(struct soap *soap, ns2__Trigger *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Trigger))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Trigger(struct soap *soap, const char *tag, int id, ns2__Trigger *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Trigger, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__Trigger ? type : NULL);
}

SOAP_FMAC3 ns2__Trigger ** SOAP_FMAC4 soap_in_PointerTons2__Trigger(struct soap *soap, const char *tag, ns2__Trigger **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Trigger **)soap_malloc(soap, sizeof(ns2__Trigger *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Trigger *)soap_instantiate_ns2__Trigger(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Trigger **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Trigger, sizeof(ns2__Trigger), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Trigger(struct soap *soap, ns2__Trigger *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Trigger(soap, tag ? tag : "ns2:Trigger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Trigger ** SOAP_FMAC4 soap_get_PointerTons2__Trigger(struct soap *soap, ns2__Trigger **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Trigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__DigitalOutputElement(struct soap *soap, ns2__DigitalOutputElement **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__DigitalOutputElement))
		soap_serialize_PointerTons2__DigitalOutputElement(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__DigitalOutputElement(struct soap *soap, const char *tag, int id, ns2__DigitalOutputElement **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__DigitalOutputElement, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__DigitalOutputElement(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__DigitalOutputElement *** SOAP_FMAC4 soap_in_PointerToPointerTons2__DigitalOutputElement(struct soap *soap, const char *tag, ns2__DigitalOutputElement ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DigitalOutputElement ***)soap_malloc(soap, sizeof(ns2__DigitalOutputElement **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__DigitalOutputElement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__DigitalOutputElement ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DigitalOutputElement, sizeof(ns2__DigitalOutputElement), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__DigitalOutputElement(struct soap *soap, ns2__DigitalOutputElement **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons2__DigitalOutputElement(soap, tag ? tag : "ns2:DigitalOutputElement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DigitalOutputElement *** SOAP_FMAC4 soap_get_PointerToPointerTons2__DigitalOutputElement(struct soap *soap, ns2__DigitalOutputElement ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__DigitalOutputElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DigitalOutputElement(struct soap *soap, ns2__DigitalOutputElement *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DigitalOutputElement))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DigitalOutputElement(struct soap *soap, const char *tag, int id, ns2__DigitalOutputElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DigitalOutputElement, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__DigitalOutputElement ? type : NULL);
}

SOAP_FMAC3 ns2__DigitalOutputElement ** SOAP_FMAC4 soap_in_PointerTons2__DigitalOutputElement(struct soap *soap, const char *tag, ns2__DigitalOutputElement **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DigitalOutputElement **)soap_malloc(soap, sizeof(ns2__DigitalOutputElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DigitalOutputElement *)soap_instantiate_ns2__DigitalOutputElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DigitalOutputElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DigitalOutputElement, sizeof(ns2__DigitalOutputElement), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DigitalOutputElement(struct soap *soap, ns2__DigitalOutputElement *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DigitalOutputElement(soap, tag ? tag : "ns2:DigitalOutputElement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DigitalOutputElement ** SOAP_FMAC4 soap_get_PointerTons2__DigitalOutputElement(struct soap *soap, ns2__DigitalOutputElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DigitalOutputElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__CurrentObject(struct soap *soap, ns2__CurrentObject **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__CurrentObject))
		soap_serialize_PointerTons2__CurrentObject(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__CurrentObject(struct soap *soap, const char *tag, int id, ns2__CurrentObject **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__CurrentObject, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__CurrentObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__CurrentObject *** SOAP_FMAC4 soap_in_PointerToPointerTons2__CurrentObject(struct soap *soap, const char *tag, ns2__CurrentObject ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CurrentObject ***)soap_malloc(soap, sizeof(ns2__CurrentObject **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__CurrentObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__CurrentObject ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CurrentObject, sizeof(ns2__CurrentObject), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__CurrentObject(struct soap *soap, ns2__CurrentObject **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons2__CurrentObject(soap, tag ? tag : "ns2:CurrentObject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CurrentObject *** SOAP_FMAC4 soap_get_PointerToPointerTons2__CurrentObject(struct soap *soap, ns2__CurrentObject ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__CurrentObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CurrentObject(struct soap *soap, ns2__CurrentObject *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CurrentObject))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CurrentObject(struct soap *soap, const char *tag, int id, ns2__CurrentObject *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CurrentObject, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CurrentObject ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__CurrentObject ** SOAP_FMAC4 soap_in_PointerTons2__CurrentObject(struct soap *soap, const char *tag, ns2__CurrentObject **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CurrentObject **)soap_malloc(soap, sizeof(ns2__CurrentObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CurrentObject *)soap_instantiate_ns2__CurrentObject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CurrentObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CurrentObject, sizeof(ns2__CurrentObject), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CurrentObject(struct soap *soap, ns2__CurrentObject *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CurrentObject(soap, tag ? tag : "ns2:CurrentObject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CurrentObject ** SOAP_FMAC4 soap_get_PointerTons2__CurrentObject(struct soap *soap, ns2__CurrentObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CurrentObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ClearZoneID(struct soap *soap, ns2__ClearZoneID *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ClearZoneID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ClearZoneID(struct soap *soap, const char *tag, int id, ns2__ClearZoneID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ClearZoneID, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ClearZoneID ? type : NULL);
}

SOAP_FMAC3 ns2__ClearZoneID ** SOAP_FMAC4 soap_in_PointerTons2__ClearZoneID(struct soap *soap, const char *tag, ns2__ClearZoneID **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ClearZoneID **)soap_malloc(soap, sizeof(ns2__ClearZoneID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ClearZoneID *)soap_instantiate_ns2__ClearZoneID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ClearZoneID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ClearZoneID, sizeof(ns2__ClearZoneID), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ClearZoneID(struct soap *soap, ns2__ClearZoneID *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ClearZoneID(soap, tag ? tag : "ns2:ClearZoneID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ClearZoneID ** SOAP_FMAC4 soap_get_PointerTons2__ClearZoneID(struct soap *soap, ns2__ClearZoneID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ClearZoneID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FillRegionID(struct soap *soap, ns2__FillRegionID *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FillRegionID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FillRegionID(struct soap *soap, const char *tag, int id, ns2__FillRegionID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FillRegionID, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__FillRegionID ? type : NULL);
}

SOAP_FMAC3 ns2__FillRegionID ** SOAP_FMAC4 soap_in_PointerTons2__FillRegionID(struct soap *soap, const char *tag, ns2__FillRegionID **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FillRegionID **)soap_malloc(soap, sizeof(ns2__FillRegionID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FillRegionID *)soap_instantiate_ns2__FillRegionID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FillRegionID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FillRegionID, sizeof(ns2__FillRegionID), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FillRegionID(struct soap *soap, ns2__FillRegionID *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FillRegionID(soap, tag ? tag : "ns2:FillRegionID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FillRegionID ** SOAP_FMAC4 soap_get_PointerTons2__FillRegionID(struct soap *soap, ns2__FillRegionID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FillRegionID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__ZoneData(struct soap *soap, ns2__ZoneData **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__ZoneData))
		soap_serialize_PointerTons2__ZoneData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__ZoneData(struct soap *soap, const char *tag, int id, ns2__ZoneData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__ZoneData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__ZoneData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__ZoneData *** SOAP_FMAC4 soap_in_PointerToPointerTons2__ZoneData(struct soap *soap, const char *tag, ns2__ZoneData ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ZoneData ***)soap_malloc(soap, sizeof(ns2__ZoneData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__ZoneData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__ZoneData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ZoneData, sizeof(ns2__ZoneData), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__ZoneData(struct soap *soap, ns2__ZoneData **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons2__ZoneData(soap, tag ? tag : "ns2:ZoneData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ZoneData *** SOAP_FMAC4 soap_get_PointerToPointerTons2__ZoneData(struct soap *soap, ns2__ZoneData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__ZoneData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ZoneData(struct soap *soap, ns2__ZoneData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ZoneData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ZoneData(struct soap *soap, const char *tag, int id, ns2__ZoneData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ZoneData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ZoneData ? type : NULL);
}

SOAP_FMAC3 ns2__ZoneData ** SOAP_FMAC4 soap_in_PointerTons2__ZoneData(struct soap *soap, const char *tag, ns2__ZoneData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ZoneData **)soap_malloc(soap, sizeof(ns2__ZoneData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ZoneData *)soap_instantiate_ns2__ZoneData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ZoneData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ZoneData, sizeof(ns2__ZoneData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ZoneData(struct soap *soap, ns2__ZoneData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ZoneData(soap, tag ? tag : "ns2:ZoneData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ZoneData ** SOAP_FMAC4 soap_get_PointerTons2__ZoneData(struct soap *soap, ns2__ZoneData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ZoneData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__CountChannelData(struct soap *soap, ns2__CountChannelData **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__CountChannelData))
		soap_serialize_PointerTons2__CountChannelData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__CountChannelData(struct soap *soap, const char *tag, int id, ns2__CountChannelData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__CountChannelData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__CountChannelData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__CountChannelData *** SOAP_FMAC4 soap_in_PointerToPointerTons2__CountChannelData(struct soap *soap, const char *tag, ns2__CountChannelData ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CountChannelData ***)soap_malloc(soap, sizeof(ns2__CountChannelData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__CountChannelData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__CountChannelData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CountChannelData, sizeof(ns2__CountChannelData), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__CountChannelData(struct soap *soap, ns2__CountChannelData **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons2__CountChannelData(soap, tag ? tag : "ns2:CountChannelData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CountChannelData *** SOAP_FMAC4 soap_get_PointerToPointerTons2__CountChannelData(struct soap *soap, ns2__CountChannelData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__CountChannelData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CountChannelData(struct soap *soap, ns2__CountChannelData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CountChannelData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CountChannelData(struct soap *soap, const char *tag, int id, ns2__CountChannelData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CountChannelData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CountChannelData ? type : NULL);
}

SOAP_FMAC3 ns2__CountChannelData ** SOAP_FMAC4 soap_in_PointerTons2__CountChannelData(struct soap *soap, const char *tag, ns2__CountChannelData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CountChannelData **)soap_malloc(soap, sizeof(ns2__CountChannelData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CountChannelData *)soap_instantiate_ns2__CountChannelData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CountChannelData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CountChannelData, sizeof(ns2__CountChannelData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CountChannelData(struct soap *soap, ns2__CountChannelData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CountChannelData(soap, tag ? tag : "ns2:CountChannelData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CountChannelData ** SOAP_FMAC4 soap_get_PointerTons2__CountChannelData(struct soap *soap, ns2__CountChannelData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CountChannelData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CountingGateID(struct soap *soap, ns2__CountingGateID *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CountingGateID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CountingGateID(struct soap *soap, const char *tag, int id, ns2__CountingGateID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CountingGateID, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CountingGateID ? type : NULL);
}

SOAP_FMAC3 ns2__CountingGateID ** SOAP_FMAC4 soap_in_PointerTons2__CountingGateID(struct soap *soap, const char *tag, ns2__CountingGateID **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CountingGateID **)soap_malloc(soap, sizeof(ns2__CountingGateID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CountingGateID *)soap_instantiate_ns2__CountingGateID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CountingGateID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CountingGateID, sizeof(ns2__CountingGateID), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CountingGateID(struct soap *soap, ns2__CountingGateID *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CountingGateID(soap, tag ? tag : "ns2:CountingGateID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CountingGateID ** SOAP_FMAC4 soap_get_PointerTons2__CountingGateID(struct soap *soap, ns2__CountingGateID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CountingGateID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::wstring *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__HistoricObject(struct soap *soap, ns2__HistoricObject **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__HistoricObject))
		soap_serialize_PointerTons2__HistoricObject(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__HistoricObject(struct soap *soap, const char *tag, int id, ns2__HistoricObject **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__HistoricObject, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__HistoricObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__HistoricObject *** SOAP_FMAC4 soap_in_PointerToPointerTons2__HistoricObject(struct soap *soap, const char *tag, ns2__HistoricObject ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HistoricObject ***)soap_malloc(soap, sizeof(ns2__HistoricObject **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__HistoricObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__HistoricObject ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HistoricObject, sizeof(ns2__HistoricObject), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__HistoricObject(struct soap *soap, ns2__HistoricObject **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons2__HistoricObject(soap, tag ? tag : "ns2:HistoricObject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HistoricObject *** SOAP_FMAC4 soap_get_PointerToPointerTons2__HistoricObject(struct soap *soap, ns2__HistoricObject ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__HistoricObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HistoricObject(struct soap *soap, ns2__HistoricObject *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HistoricObject))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HistoricObject(struct soap *soap, const char *tag, int id, ns2__HistoricObject *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HistoricObject, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__HistoricObject ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__HistoricObject ** SOAP_FMAC4 soap_in_PointerTons2__HistoricObject(struct soap *soap, const char *tag, ns2__HistoricObject **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HistoricObject **)soap_malloc(soap, sizeof(ns2__HistoricObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HistoricObject *)soap_instantiate_ns2__HistoricObject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__HistoricObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HistoricObject, sizeof(ns2__HistoricObject), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HistoricObject(struct soap *soap, ns2__HistoricObject *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__HistoricObject(soap, tag ? tag : "ns2:HistoricObject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HistoricObject ** SOAP_FMAC4 soap_get_PointerTons2__HistoricObject(struct soap *soap, ns2__HistoricObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HistoricObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Coordinate_USCORE2D(struct soap *soap, ns2__Coordinate_USCORE2D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Coordinate_USCORE2D))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Coordinate_USCORE2D(struct soap *soap, const char *tag, int id, ns2__Coordinate_USCORE2D *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Coordinate_USCORE2D, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__Coordinate_USCORE2D ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__Coordinate_USCORE2D ** SOAP_FMAC4 soap_in_PointerTons2__Coordinate_USCORE2D(struct soap *soap, const char *tag, ns2__Coordinate_USCORE2D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Coordinate_USCORE2D **)soap_malloc(soap, sizeof(ns2__Coordinate_USCORE2D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Coordinate_USCORE2D *)soap_instantiate_ns2__Coordinate_USCORE2D(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Coordinate_USCORE2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Coordinate_USCORE2D, sizeof(ns2__Coordinate_USCORE2D), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Coordinate_USCORE2D(struct soap *soap, ns2__Coordinate_USCORE2D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Coordinate_USCORE2D(soap, tag ? tag : "ns2:Coordinate_2D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Coordinate_USCORE2D ** SOAP_FMAC4 soap_get_PointerTons2__Coordinate_USCORE2D(struct soap *soap, ns2__Coordinate_USCORE2D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Coordinate_USCORE2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BinaryData(struct soap *soap, ns2__BinaryData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BinaryData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BinaryData(struct soap *soap, const char *tag, int id, ns2__BinaryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BinaryData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__BinaryData ? type : NULL);
}

SOAP_FMAC3 ns2__BinaryData ** SOAP_FMAC4 soap_in_PointerTons2__BinaryData(struct soap *soap, const char *tag, ns2__BinaryData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BinaryData **)soap_malloc(soap, sizeof(ns2__BinaryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BinaryData *)soap_instantiate_ns2__BinaryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BinaryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BinaryData, sizeof(ns2__BinaryData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BinaryData(struct soap *soap, ns2__BinaryData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BinaryData(soap, tag ? tag : "ns2:BinaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BinaryData ** SOAP_FMAC4 soap_get_PointerTons2__BinaryData(struct soap *soap, ns2__BinaryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__DigitalInputElement(struct soap *soap, ns2__DigitalInputElement **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__DigitalInputElement))
		soap_serialize_PointerTons2__DigitalInputElement(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__DigitalInputElement(struct soap *soap, const char *tag, int id, ns2__DigitalInputElement **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__DigitalInputElement, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__DigitalInputElement(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__DigitalInputElement *** SOAP_FMAC4 soap_in_PointerToPointerTons2__DigitalInputElement(struct soap *soap, const char *tag, ns2__DigitalInputElement ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DigitalInputElement ***)soap_malloc(soap, sizeof(ns2__DigitalInputElement **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__DigitalInputElement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__DigitalInputElement ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DigitalInputElement, sizeof(ns2__DigitalInputElement), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__DigitalInputElement(struct soap *soap, ns2__DigitalInputElement **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons2__DigitalInputElement(soap, tag ? tag : "ns2:DigitalInputElement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DigitalInputElement *** SOAP_FMAC4 soap_get_PointerToPointerTons2__DigitalInputElement(struct soap *soap, ns2__DigitalInputElement ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__DigitalInputElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DigitalInputElement(struct soap *soap, ns2__DigitalInputElement *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DigitalInputElement))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DigitalInputElement(struct soap *soap, const char *tag, int id, ns2__DigitalInputElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DigitalInputElement, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__DigitalInputElement ? type : NULL);
}

SOAP_FMAC3 ns2__DigitalInputElement ** SOAP_FMAC4 soap_in_PointerTons2__DigitalInputElement(struct soap *soap, const char *tag, ns2__DigitalInputElement **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DigitalInputElement **)soap_malloc(soap, sizeof(ns2__DigitalInputElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DigitalInputElement *)soap_instantiate_ns2__DigitalInputElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DigitalInputElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DigitalInputElement, sizeof(ns2__DigitalInputElement), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DigitalInputElement(struct soap *soap, ns2__DigitalInputElement *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DigitalInputElement(soap, tag ? tag : "ns2:DigitalInputElement", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DigitalInputElement ** SOAP_FMAC4 soap_get_PointerTons2__DigitalInputElement(struct soap *soap, ns2__DigitalInputElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DigitalInputElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_TaskContainer(struct soap *soap, __ns2__union_TaskContainer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_TaskContainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_TaskContainer(struct soap *soap, const char *tag, int id, __ns2__union_TaskContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_TaskContainer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE___ns2__union_TaskContainer ? type : NULL);
}

SOAP_FMAC3 __ns2__union_TaskContainer ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_TaskContainer(struct soap *soap, const char *tag, __ns2__union_TaskContainer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns2__union_TaskContainer **)soap_malloc(soap, sizeof(__ns2__union_TaskContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns2__union_TaskContainer *)soap_instantiate___ns2__union_TaskContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (__ns2__union_TaskContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_TaskContainer, sizeof(__ns2__union_TaskContainer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_TaskContainer(struct soap *soap, __ns2__union_TaskContainer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__ns2__union_TaskContainer(soap, tag ? tag : "-ns2:union-TaskContainer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns2__union_TaskContainer ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_TaskContainer(struct soap *soap, __ns2__union_TaskContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_TaskContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskDeleteAllNotifications(struct soap *soap, ns2__TaskDeleteAllNotifications *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskDeleteAllNotifications))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskDeleteAllNotifications(struct soap *soap, const char *tag, int id, ns2__TaskDeleteAllNotifications *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskDeleteAllNotifications, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskDeleteAllNotifications ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskDeleteAllNotifications ** SOAP_FMAC4 soap_in_PointerTons2__TaskDeleteAllNotifications(struct soap *soap, const char *tag, ns2__TaskDeleteAllNotifications **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskDeleteAllNotifications **)soap_malloc(soap, sizeof(ns2__TaskDeleteAllNotifications *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskDeleteAllNotifications *)soap_instantiate_ns2__TaskDeleteAllNotifications(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskDeleteAllNotifications **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskDeleteAllNotifications, sizeof(ns2__TaskDeleteAllNotifications), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskDeleteAllNotifications(struct soap *soap, ns2__TaskDeleteAllNotifications *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskDeleteAllNotifications(soap, tag ? tag : "ns2:TaskDeleteAllNotifications", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskDeleteAllNotifications ** SOAP_FMAC4 soap_get_PointerTons2__TaskDeleteAllNotifications(struct soap *soap, ns2__TaskDeleteAllNotifications **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskDeleteAllNotifications(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskDeleteAllTasks(struct soap *soap, ns2__TaskDeleteAllTasks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskDeleteAllTasks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskDeleteAllTasks(struct soap *soap, const char *tag, int id, ns2__TaskDeleteAllTasks *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskDeleteAllTasks, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskDeleteAllTasks ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskDeleteAllTasks ** SOAP_FMAC4 soap_in_PointerTons2__TaskDeleteAllTasks(struct soap *soap, const char *tag, ns2__TaskDeleteAllTasks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskDeleteAllTasks **)soap_malloc(soap, sizeof(ns2__TaskDeleteAllTasks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskDeleteAllTasks *)soap_instantiate_ns2__TaskDeleteAllTasks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskDeleteAllTasks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskDeleteAllTasks, sizeof(ns2__TaskDeleteAllTasks), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskDeleteAllTasks(struct soap *soap, ns2__TaskDeleteAllTasks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskDeleteAllTasks(soap, tag ? tag : "ns2:TaskDeleteAllTasks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskDeleteAllTasks ** SOAP_FMAC4 soap_get_PointerTons2__TaskDeleteAllTasks(struct soap *soap, ns2__TaskDeleteAllTasks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskDeleteAllTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeFeaturesInfo(struct soap *soap, ns2__TaskSubscribeFeaturesInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeFeaturesInfo(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeFeaturesInfo *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeFeaturesInfo ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeFeaturesInfo(struct soap *soap, const char *tag, ns2__TaskSubscribeFeaturesInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeFeaturesInfo **)soap_malloc(soap, sizeof(ns2__TaskSubscribeFeaturesInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeFeaturesInfo *)soap_instantiate_ns2__TaskSubscribeFeaturesInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeFeaturesInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeFeaturesInfo, sizeof(ns2__TaskSubscribeFeaturesInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeFeaturesInfo(struct soap *soap, ns2__TaskSubscribeFeaturesInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeFeaturesInfo(soap, tag ? tag : "ns2:TaskSubscribeFeaturesInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeFeaturesInfo ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeFeaturesInfo(struct soap *soap, ns2__TaskSubscribeFeaturesInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeFeaturesInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeZoneChannels(struct soap *soap, ns2__TaskSubscribeZoneChannels *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeZoneChannels))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeZoneChannels(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeZoneChannels *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeZoneChannels, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeZoneChannels ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeZoneChannels ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeZoneChannels(struct soap *soap, const char *tag, ns2__TaskSubscribeZoneChannels **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeZoneChannels **)soap_malloc(soap, sizeof(ns2__TaskSubscribeZoneChannels *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeZoneChannels *)soap_instantiate_ns2__TaskSubscribeZoneChannels(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeZoneChannels **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeZoneChannels, sizeof(ns2__TaskSubscribeZoneChannels), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeZoneChannels(struct soap *soap, ns2__TaskSubscribeZoneChannels *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeZoneChannels(soap, tag ? tag : "ns2:TaskSubscribeZoneChannels", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeZoneChannels ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeZoneChannels(struct soap *soap, ns2__TaskSubscribeZoneChannels **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeZoneChannels(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeCountChannels(struct soap *soap, ns2__TaskSubscribeCountChannels *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeCountChannels))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeCountChannels(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeCountChannels *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeCountChannels, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeCountChannels ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeCountChannels ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeCountChannels(struct soap *soap, const char *tag, ns2__TaskSubscribeCountChannels **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeCountChannels **)soap_malloc(soap, sizeof(ns2__TaskSubscribeCountChannels *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeCountChannels *)soap_instantiate_ns2__TaskSubscribeCountChannels(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeCountChannels **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeCountChannels, sizeof(ns2__TaskSubscribeCountChannels), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeCountChannels(struct soap *soap, ns2__TaskSubscribeCountChannels *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeCountChannels(soap, tag ? tag : "ns2:TaskSubscribeCountChannels", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeCountChannels ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeCountChannels(struct soap *soap, ns2__TaskSubscribeCountChannels **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeCountChannels(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeClearZone(struct soap *soap, ns2__TaskSubscribeClearZone *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeClearZone))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeClearZone(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeClearZone *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeClearZone, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeClearZone ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeClearZone ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeClearZone(struct soap *soap, const char *tag, ns2__TaskSubscribeClearZone **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeClearZone **)soap_malloc(soap, sizeof(ns2__TaskSubscribeClearZone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeClearZone *)soap_instantiate_ns2__TaskSubscribeClearZone(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeClearZone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeClearZone, sizeof(ns2__TaskSubscribeClearZone), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeClearZone(struct soap *soap, ns2__TaskSubscribeClearZone *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeClearZone(soap, tag ? tag : "ns2:TaskSubscribeClearZone", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeClearZone ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeClearZone(struct soap *soap, ns2__TaskSubscribeClearZone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeClearZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskRebootNow(struct soap *soap, ns2__TaskRebootNow *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskRebootNow))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskRebootNow(struct soap *soap, const char *tag, int id, ns2__TaskRebootNow *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskRebootNow, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskRebootNow ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskRebootNow ** SOAP_FMAC4 soap_in_PointerTons2__TaskRebootNow(struct soap *soap, const char *tag, ns2__TaskRebootNow **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskRebootNow **)soap_malloc(soap, sizeof(ns2__TaskRebootNow *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskRebootNow *)soap_instantiate_ns2__TaskRebootNow(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskRebootNow **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskRebootNow, sizeof(ns2__TaskRebootNow), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskRebootNow(struct soap *soap, ns2__TaskRebootNow *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskRebootNow(soap, tag ? tag : "ns2:TaskRebootNow", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskRebootNow ** SOAP_FMAC4 soap_get_PointerTons2__TaskRebootNow(struct soap *soap, ns2__TaskRebootNow **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskRebootNow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeObjectList(struct soap *soap, ns2__TaskSubscribeObjectList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeObjectList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeObjectList(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeObjectList *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeObjectList, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeObjectList ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeObjectList ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeObjectList(struct soap *soap, const char *tag, ns2__TaskSubscribeObjectList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeObjectList **)soap_malloc(soap, sizeof(ns2__TaskSubscribeObjectList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeObjectList *)soap_instantiate_ns2__TaskSubscribeObjectList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeObjectList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeObjectList, sizeof(ns2__TaskSubscribeObjectList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeObjectList(struct soap *soap, ns2__TaskSubscribeObjectList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeObjectList(soap, tag ? tag : "ns2:TaskSubscribeObjectList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeObjectList ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeObjectList(struct soap *soap, ns2__TaskSubscribeObjectList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeObjectList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeAlive(struct soap *soap, ns2__TaskSubscribeAlive *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeAlive))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeAlive(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeAlive *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeAlive, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeAlive ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeAlive ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeAlive(struct soap *soap, const char *tag, ns2__TaskSubscribeAlive **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeAlive **)soap_malloc(soap, sizeof(ns2__TaskSubscribeAlive *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeAlive *)soap_instantiate_ns2__TaskSubscribeAlive(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeAlive **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeAlive, sizeof(ns2__TaskSubscribeAlive), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeAlive(struct soap *soap, ns2__TaskSubscribeAlive *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeAlive(soap, tag ? tag : "ns2:TaskSubscribeAlive", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeAlive ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeAlive(struct soap *soap, ns2__TaskSubscribeAlive **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeAlive(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeVideoStore(struct soap *soap, ns2__TaskSubscribeVideoStore *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeVideoStore))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeVideoStore(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeVideoStore *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeVideoStore, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeVideoStore ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeVideoStore ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeVideoStore(struct soap *soap, const char *tag, ns2__TaskSubscribeVideoStore **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeVideoStore **)soap_malloc(soap, sizeof(ns2__TaskSubscribeVideoStore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeVideoStore *)soap_instantiate_ns2__TaskSubscribeVideoStore(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeVideoStore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeVideoStore, sizeof(ns2__TaskSubscribeVideoStore), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeVideoStore(struct soap *soap, ns2__TaskSubscribeVideoStore *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeVideoStore(soap, tag ? tag : "ns2:TaskSubscribeVideoStore", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeVideoStore ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeVideoStore(struct soap *soap, ns2__TaskSubscribeVideoStore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeVideoStore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeSendParameters(struct soap *soap, ns2__TaskSubscribeSendParameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeSendParameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeSendParameters(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeSendParameters *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeSendParameters, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeSendParameters ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeSendParameters ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeSendParameters(struct soap *soap, const char *tag, ns2__TaskSubscribeSendParameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeSendParameters **)soap_malloc(soap, sizeof(ns2__TaskSubscribeSendParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeSendParameters *)soap_instantiate_ns2__TaskSubscribeSendParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeSendParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeSendParameters, sizeof(ns2__TaskSubscribeSendParameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeSendParameters(struct soap *soap, ns2__TaskSubscribeSendParameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeSendParameters(soap, tag ? tag : "ns2:TaskSubscribeSendParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeSendParameters ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeSendParameters(struct soap *soap, ns2__TaskSubscribeSendParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeSendParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeCameraImages(struct soap *soap, ns2__TaskSubscribeCameraImages *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeCameraImages))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeCameraImages(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeCameraImages *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeCameraImages, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeCameraImages ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeCameraImages ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeCameraImages(struct soap *soap, const char *tag, ns2__TaskSubscribeCameraImages **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeCameraImages **)soap_malloc(soap, sizeof(ns2__TaskSubscribeCameraImages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeCameraImages *)soap_instantiate_ns2__TaskSubscribeCameraImages(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeCameraImages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeCameraImages, sizeof(ns2__TaskSubscribeCameraImages), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeCameraImages(struct soap *soap, ns2__TaskSubscribeCameraImages *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeCameraImages(soap, tag ? tag : "ns2:TaskSubscribeCameraImages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeCameraImages ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeCameraImages(struct soap *soap, ns2__TaskSubscribeCameraImages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeCameraImages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeDigitalInput(struct soap *soap, ns2__TaskSubscribeDigitalInput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeDigitalInput))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeDigitalInput(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeDigitalInput *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeDigitalInput, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeDigitalInput ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeDigitalInput ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeDigitalInput(struct soap *soap, const char *tag, ns2__TaskSubscribeDigitalInput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeDigitalInput **)soap_malloc(soap, sizeof(ns2__TaskSubscribeDigitalInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeDigitalInput *)soap_instantiate_ns2__TaskSubscribeDigitalInput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeDigitalInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeDigitalInput, sizeof(ns2__TaskSubscribeDigitalInput), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeDigitalInput(struct soap *soap, ns2__TaskSubscribeDigitalInput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeDigitalInput(soap, tag ? tag : "ns2:TaskSubscribeDigitalInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeDigitalInput ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeDigitalInput(struct soap *soap, ns2__TaskSubscribeDigitalInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeDigitalInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeFill(struct soap *soap, ns2__TaskSubscribeFill *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeFill))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeFill(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeFill *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeFill, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeFill ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeFill ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeFill(struct soap *soap, const char *tag, ns2__TaskSubscribeFill **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeFill **)soap_malloc(soap, sizeof(ns2__TaskSubscribeFill *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeFill *)soap_instantiate_ns2__TaskSubscribeFill(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeFill **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeFill, sizeof(ns2__TaskSubscribeFill), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeFill(struct soap *soap, ns2__TaskSubscribeFill *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeFill(soap, tag ? tag : "ns2:TaskSubscribeFill", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeFill ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeFill(struct soap *soap, ns2__TaskSubscribeFill **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeFill(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeCounting(struct soap *soap, ns2__TaskSubscribeCounting *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeCounting))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeCounting(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeCounting *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeCounting, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeCounting ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeCounting ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeCounting(struct soap *soap, const char *tag, ns2__TaskSubscribeCounting **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeCounting **)soap_malloc(soap, sizeof(ns2__TaskSubscribeCounting *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeCounting *)soap_instantiate_ns2__TaskSubscribeCounting(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeCounting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeCounting, sizeof(ns2__TaskSubscribeCounting), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeCounting(struct soap *soap, ns2__TaskSubscribeCounting *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeCounting(soap, tag ? tag : "ns2:TaskSubscribeCounting", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeCounting ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeCounting(struct soap *soap, ns2__TaskSubscribeCounting **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeCounting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSetDateTime(struct soap *soap, ns2__TaskSetDateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSetDateTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSetDateTime(struct soap *soap, const char *tag, int id, ns2__TaskSetDateTime *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSetDateTime, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSetDateTime ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSetDateTime ** SOAP_FMAC4 soap_in_PointerTons2__TaskSetDateTime(struct soap *soap, const char *tag, ns2__TaskSetDateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSetDateTime **)soap_malloc(soap, sizeof(ns2__TaskSetDateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSetDateTime *)soap_instantiate_ns2__TaskSetDateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSetDateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSetDateTime, sizeof(ns2__TaskSetDateTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSetDateTime(struct soap *soap, ns2__TaskSetDateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSetDateTime(soap, tag ? tag : "ns2:TaskSetDateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSetDateTime ** SOAP_FMAC4 soap_get_PointerTons2__TaskSetDateTime(struct soap *soap, ns2__TaskSetDateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSetDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSetDigitalOutput(struct soap *soap, ns2__TaskSetDigitalOutput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSetDigitalOutput))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSetDigitalOutput(struct soap *soap, const char *tag, int id, ns2__TaskSetDigitalOutput *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSetDigitalOutput, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSetDigitalOutput ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSetDigitalOutput ** SOAP_FMAC4 soap_in_PointerTons2__TaskSetDigitalOutput(struct soap *soap, const char *tag, ns2__TaskSetDigitalOutput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSetDigitalOutput **)soap_malloc(soap, sizeof(ns2__TaskSetDigitalOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSetDigitalOutput *)soap_instantiate_ns2__TaskSetDigitalOutput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSetDigitalOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSetDigitalOutput, sizeof(ns2__TaskSetDigitalOutput), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSetDigitalOutput(struct soap *soap, ns2__TaskSetDigitalOutput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSetDigitalOutput(soap, tag ? tag : "ns2:TaskSetDigitalOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSetDigitalOutput ** SOAP_FMAC4 soap_get_PointerTons2__TaskSetDigitalOutput(struct soap *soap, ns2__TaskSetDigitalOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSetDigitalOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeErrorLog(struct soap *soap, ns2__TaskSubscribeErrorLog *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeErrorLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeErrorLog(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeErrorLog *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeErrorLog, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeErrorLog ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeErrorLog ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeErrorLog(struct soap *soap, const char *tag, ns2__TaskSubscribeErrorLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeErrorLog **)soap_malloc(soap, sizeof(ns2__TaskSubscribeErrorLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeErrorLog *)soap_instantiate_ns2__TaskSubscribeErrorLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeErrorLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeErrorLog, sizeof(ns2__TaskSubscribeErrorLog), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeErrorLog(struct soap *soap, ns2__TaskSubscribeErrorLog *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeErrorLog(soap, tag ? tag : "ns2:TaskSubscribeErrorLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeErrorLog ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeErrorLog(struct soap *soap, ns2__TaskSubscribeErrorLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeErrorLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskSubscribeLogfiles(struct soap *soap, ns2__TaskSubscribeLogfiles *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskSubscribeLogfiles))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskSubscribeLogfiles(struct soap *soap, const char *tag, int id, ns2__TaskSubscribeLogfiles *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskSubscribeLogfiles, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskSubscribeLogfiles ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskSubscribeLogfiles ** SOAP_FMAC4 soap_in_PointerTons2__TaskSubscribeLogfiles(struct soap *soap, const char *tag, ns2__TaskSubscribeLogfiles **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskSubscribeLogfiles **)soap_malloc(soap, sizeof(ns2__TaskSubscribeLogfiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskSubscribeLogfiles *)soap_instantiate_ns2__TaskSubscribeLogfiles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskSubscribeLogfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskSubscribeLogfiles, sizeof(ns2__TaskSubscribeLogfiles), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskSubscribeLogfiles(struct soap *soap, ns2__TaskSubscribeLogfiles *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskSubscribeLogfiles(soap, tag ? tag : "ns2:TaskSubscribeLogfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskSubscribeLogfiles ** SOAP_FMAC4 soap_get_PointerTons2__TaskSubscribeLogfiles(struct soap *soap, ns2__TaskSubscribeLogfiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskSubscribeLogfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskRequestParameters(struct soap *soap, ns2__TaskRequestParameters *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskRequestParameters))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskRequestParameters(struct soap *soap, const char *tag, int id, ns2__TaskRequestParameters *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskRequestParameters, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskRequestParameters ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskRequestParameters ** SOAP_FMAC4 soap_in_PointerTons2__TaskRequestParameters(struct soap *soap, const char *tag, ns2__TaskRequestParameters **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskRequestParameters **)soap_malloc(soap, sizeof(ns2__TaskRequestParameters *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskRequestParameters *)soap_instantiate_ns2__TaskRequestParameters(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskRequestParameters **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskRequestParameters, sizeof(ns2__TaskRequestParameters), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskRequestParameters(struct soap *soap, ns2__TaskRequestParameters *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskRequestParameters(soap, tag ? tag : "ns2:TaskRequestParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskRequestParameters ** SOAP_FMAC4 soap_get_PointerTons2__TaskRequestParameters(struct soap *soap, ns2__TaskRequestParameters **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskRequestParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaskRequestUpdate(struct soap *soap, ns2__TaskRequestUpdate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaskRequestUpdate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaskRequestUpdate(struct soap *soap, const char *tag, int id, ns2__TaskRequestUpdate *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaskRequestUpdate, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TaskRequestUpdate ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__TaskRequestUpdate ** SOAP_FMAC4 soap_in_PointerTons2__TaskRequestUpdate(struct soap *soap, const char *tag, ns2__TaskRequestUpdate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaskRequestUpdate **)soap_malloc(soap, sizeof(ns2__TaskRequestUpdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaskRequestUpdate *)soap_instantiate_ns2__TaskRequestUpdate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaskRequestUpdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaskRequestUpdate, sizeof(ns2__TaskRequestUpdate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaskRequestUpdate(struct soap *soap, ns2__TaskRequestUpdate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaskRequestUpdate(soap, tag ? tag : "ns2:TaskRequestUpdate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaskRequestUpdate ** SOAP_FMAC4 soap_get_PointerTons2__TaskRequestUpdate(struct soap *soap, ns2__TaskRequestUpdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaskRequestUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FeatureInfoNotification(struct soap *soap, ns2__FeatureInfoNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FeatureInfoNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FeatureInfoNotification(struct soap *soap, const char *tag, int id, ns2__FeatureInfoNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FeatureInfoNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__FeatureInfoNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__FeatureInfoNotification ** SOAP_FMAC4 soap_in_PointerTons2__FeatureInfoNotification(struct soap *soap, const char *tag, ns2__FeatureInfoNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FeatureInfoNotification **)soap_malloc(soap, sizeof(ns2__FeatureInfoNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FeatureInfoNotification *)soap_instantiate_ns2__FeatureInfoNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FeatureInfoNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FeatureInfoNotification, sizeof(ns2__FeatureInfoNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FeatureInfoNotification(struct soap *soap, ns2__FeatureInfoNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FeatureInfoNotification(soap, tag ? tag : "ns2:FeatureInfoNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FeatureInfoNotification ** SOAP_FMAC4 soap_get_PointerTons2__FeatureInfoNotification(struct soap *soap, ns2__FeatureInfoNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FeatureInfoNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ZoneChannelsNotification(struct soap *soap, ns2__ZoneChannelsNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ZoneChannelsNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ZoneChannelsNotification(struct soap *soap, const char *tag, int id, ns2__ZoneChannelsNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ZoneChannelsNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ZoneChannelsNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__ZoneChannelsNotification ** SOAP_FMAC4 soap_in_PointerTons2__ZoneChannelsNotification(struct soap *soap, const char *tag, ns2__ZoneChannelsNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ZoneChannelsNotification **)soap_malloc(soap, sizeof(ns2__ZoneChannelsNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ZoneChannelsNotification *)soap_instantiate_ns2__ZoneChannelsNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ZoneChannelsNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ZoneChannelsNotification, sizeof(ns2__ZoneChannelsNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ZoneChannelsNotification(struct soap *soap, ns2__ZoneChannelsNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ZoneChannelsNotification(soap, tag ? tag : "ns2:ZoneChannelsNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ZoneChannelsNotification ** SOAP_FMAC4 soap_get_PointerTons2__ZoneChannelsNotification(struct soap *soap, ns2__ZoneChannelsNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ZoneChannelsNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CountChannelsNotification(struct soap *soap, ns2__CountChannelsNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CountChannelsNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CountChannelsNotification(struct soap *soap, const char *tag, int id, ns2__CountChannelsNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CountChannelsNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CountChannelsNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__CountChannelsNotification ** SOAP_FMAC4 soap_in_PointerTons2__CountChannelsNotification(struct soap *soap, const char *tag, ns2__CountChannelsNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CountChannelsNotification **)soap_malloc(soap, sizeof(ns2__CountChannelsNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CountChannelsNotification *)soap_instantiate_ns2__CountChannelsNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CountChannelsNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CountChannelsNotification, sizeof(ns2__CountChannelsNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CountChannelsNotification(struct soap *soap, ns2__CountChannelsNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CountChannelsNotification(soap, tag ? tag : "ns2:CountChannelsNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CountChannelsNotification ** SOAP_FMAC4 soap_get_PointerTons2__CountChannelsNotification(struct soap *soap, ns2__CountChannelsNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CountChannelsNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ClearZoneNotification(struct soap *soap, ns2__ClearZoneNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ClearZoneNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ClearZoneNotification(struct soap *soap, const char *tag, int id, ns2__ClearZoneNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ClearZoneNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ClearZoneNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__ClearZoneNotification ** SOAP_FMAC4 soap_in_PointerTons2__ClearZoneNotification(struct soap *soap, const char *tag, ns2__ClearZoneNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ClearZoneNotification **)soap_malloc(soap, sizeof(ns2__ClearZoneNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ClearZoneNotification *)soap_instantiate_ns2__ClearZoneNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ClearZoneNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ClearZoneNotification, sizeof(ns2__ClearZoneNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ClearZoneNotification(struct soap *soap, ns2__ClearZoneNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ClearZoneNotification(soap, tag ? tag : "ns2:ClearZoneNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ClearZoneNotification ** SOAP_FMAC4 soap_get_PointerTons2__ClearZoneNotification(struct soap *soap, ns2__ClearZoneNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ClearZoneNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__StartupNotification(struct soap *soap, ns2__StartupNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__StartupNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__StartupNotification(struct soap *soap, const char *tag, int id, ns2__StartupNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__StartupNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__StartupNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__StartupNotification ** SOAP_FMAC4 soap_in_PointerTons2__StartupNotification(struct soap *soap, const char *tag, ns2__StartupNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__StartupNotification **)soap_malloc(soap, sizeof(ns2__StartupNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__StartupNotification *)soap_instantiate_ns2__StartupNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__StartupNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__StartupNotification, sizeof(ns2__StartupNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__StartupNotification(struct soap *soap, ns2__StartupNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__StartupNotification(soap, tag ? tag : "ns2:StartupNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__StartupNotification ** SOAP_FMAC4 soap_get_PointerTons2__StartupNotification(struct soap *soap, ns2__StartupNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__StartupNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HistoricObjectListNotification(struct soap *soap, ns2__HistoricObjectListNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HistoricObjectListNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HistoricObjectListNotification(struct soap *soap, const char *tag, int id, ns2__HistoricObjectListNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HistoricObjectListNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__HistoricObjectListNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__HistoricObjectListNotification ** SOAP_FMAC4 soap_in_PointerTons2__HistoricObjectListNotification(struct soap *soap, const char *tag, ns2__HistoricObjectListNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HistoricObjectListNotification **)soap_malloc(soap, sizeof(ns2__HistoricObjectListNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HistoricObjectListNotification *)soap_instantiate_ns2__HistoricObjectListNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__HistoricObjectListNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HistoricObjectListNotification, sizeof(ns2__HistoricObjectListNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HistoricObjectListNotification(struct soap *soap, ns2__HistoricObjectListNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__HistoricObjectListNotification(soap, tag ? tag : "ns2:HistoricObjectListNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HistoricObjectListNotification ** SOAP_FMAC4 soap_get_PointerTons2__HistoricObjectListNotification(struct soap *soap, ns2__HistoricObjectListNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HistoricObjectListNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CurrentObjectListNotification(struct soap *soap, ns2__CurrentObjectListNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CurrentObjectListNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CurrentObjectListNotification(struct soap *soap, const char *tag, int id, ns2__CurrentObjectListNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CurrentObjectListNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CurrentObjectListNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__CurrentObjectListNotification ** SOAP_FMAC4 soap_in_PointerTons2__CurrentObjectListNotification(struct soap *soap, const char *tag, ns2__CurrentObjectListNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CurrentObjectListNotification **)soap_malloc(soap, sizeof(ns2__CurrentObjectListNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CurrentObjectListNotification *)soap_instantiate_ns2__CurrentObjectListNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CurrentObjectListNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CurrentObjectListNotification, sizeof(ns2__CurrentObjectListNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CurrentObjectListNotification(struct soap *soap, ns2__CurrentObjectListNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CurrentObjectListNotification(soap, tag ? tag : "ns2:CurrentObjectListNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CurrentObjectListNotification ** SOAP_FMAC4 soap_get_PointerTons2__CurrentObjectListNotification(struct soap *soap, ns2__CurrentObjectListNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CurrentObjectListNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AliveNotification(struct soap *soap, ns2__AliveNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AliveNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AliveNotification(struct soap *soap, const char *tag, int id, ns2__AliveNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AliveNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__AliveNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__AliveNotification ** SOAP_FMAC4 soap_in_PointerTons2__AliveNotification(struct soap *soap, const char *tag, ns2__AliveNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AliveNotification **)soap_malloc(soap, sizeof(ns2__AliveNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AliveNotification *)soap_instantiate_ns2__AliveNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AliveNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AliveNotification, sizeof(ns2__AliveNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AliveNotification(struct soap *soap, ns2__AliveNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AliveNotification(soap, tag ? tag : "ns2:AliveNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AliveNotification ** SOAP_FMAC4 soap_get_PointerTons2__AliveNotification(struct soap *soap, ns2__AliveNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AliveNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ErrorLogfilesNotification(struct soap *soap, ns2__ErrorLogfilesNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ErrorLogfilesNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ErrorLogfilesNotification(struct soap *soap, const char *tag, int id, ns2__ErrorLogfilesNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ErrorLogfilesNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ErrorLogfilesNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__ErrorLogfilesNotification ** SOAP_FMAC4 soap_in_PointerTons2__ErrorLogfilesNotification(struct soap *soap, const char *tag, ns2__ErrorLogfilesNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ErrorLogfilesNotification **)soap_malloc(soap, sizeof(ns2__ErrorLogfilesNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ErrorLogfilesNotification *)soap_instantiate_ns2__ErrorLogfilesNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ErrorLogfilesNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ErrorLogfilesNotification, sizeof(ns2__ErrorLogfilesNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ErrorLogfilesNotification(struct soap *soap, ns2__ErrorLogfilesNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ErrorLogfilesNotification(soap, tag ? tag : "ns2:ErrorLogfilesNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ErrorLogfilesNotification ** SOAP_FMAC4 soap_get_PointerTons2__ErrorLogfilesNotification(struct soap *soap, ns2__ErrorLogfilesNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ErrorLogfilesNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LogfilesNotification(struct soap *soap, ns2__LogfilesNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LogfilesNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LogfilesNotification(struct soap *soap, const char *tag, int id, ns2__LogfilesNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LogfilesNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__LogfilesNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__LogfilesNotification ** SOAP_FMAC4 soap_in_PointerTons2__LogfilesNotification(struct soap *soap, const char *tag, ns2__LogfilesNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LogfilesNotification **)soap_malloc(soap, sizeof(ns2__LogfilesNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LogfilesNotification *)soap_instantiate_ns2__LogfilesNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__LogfilesNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LogfilesNotification, sizeof(ns2__LogfilesNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LogfilesNotification(struct soap *soap, ns2__LogfilesNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__LogfilesNotification(soap, tag ? tag : "ns2:LogfilesNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LogfilesNotification ** SOAP_FMAC4 soap_get_PointerTons2__LogfilesNotification(struct soap *soap, ns2__LogfilesNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LogfilesNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParameterNotification(struct soap *soap, ns2__ParameterNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParameterNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParameterNotification(struct soap *soap, const char *tag, int id, ns2__ParameterNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParameterNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ParameterNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__ParameterNotification ** SOAP_FMAC4 soap_in_PointerTons2__ParameterNotification(struct soap *soap, const char *tag, ns2__ParameterNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParameterNotification **)soap_malloc(soap, sizeof(ns2__ParameterNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParameterNotification *)soap_instantiate_ns2__ParameterNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ParameterNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParameterNotification, sizeof(ns2__ParameterNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParameterNotification(struct soap *soap, ns2__ParameterNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ParameterNotification(soap, tag ? tag : "ns2:ParameterNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParameterNotification ** SOAP_FMAC4 soap_get_PointerTons2__ParameterNotification(struct soap *soap, ns2__ParameterNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParameterNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CameraImagesNotification(struct soap *soap, ns2__CameraImagesNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CameraImagesNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CameraImagesNotification(struct soap *soap, const char *tag, int id, ns2__CameraImagesNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CameraImagesNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CameraImagesNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__CameraImagesNotification ** SOAP_FMAC4 soap_in_PointerTons2__CameraImagesNotification(struct soap *soap, const char *tag, ns2__CameraImagesNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CameraImagesNotification **)soap_malloc(soap, sizeof(ns2__CameraImagesNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CameraImagesNotification *)soap_instantiate_ns2__CameraImagesNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CameraImagesNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CameraImagesNotification, sizeof(ns2__CameraImagesNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CameraImagesNotification(struct soap *soap, ns2__CameraImagesNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CameraImagesNotification(soap, tag ? tag : "ns2:CameraImagesNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CameraImagesNotification ** SOAP_FMAC4 soap_get_PointerTons2__CameraImagesNotification(struct soap *soap, ns2__CameraImagesNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CameraImagesNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DigitalInputNotification(struct soap *soap, ns2__DigitalInputNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DigitalInputNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DigitalInputNotification(struct soap *soap, const char *tag, int id, ns2__DigitalInputNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DigitalInputNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__DigitalInputNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__DigitalInputNotification ** SOAP_FMAC4 soap_in_PointerTons2__DigitalInputNotification(struct soap *soap, const char *tag, ns2__DigitalInputNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DigitalInputNotification **)soap_malloc(soap, sizeof(ns2__DigitalInputNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DigitalInputNotification *)soap_instantiate_ns2__DigitalInputNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DigitalInputNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DigitalInputNotification, sizeof(ns2__DigitalInputNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DigitalInputNotification(struct soap *soap, ns2__DigitalInputNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DigitalInputNotification(soap, tag ? tag : "ns2:DigitalInputNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DigitalInputNotification ** SOAP_FMAC4 soap_get_PointerTons2__DigitalInputNotification(struct soap *soap, ns2__DigitalInputNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DigitalInputNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FillNotification(struct soap *soap, ns2__FillNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FillNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FillNotification(struct soap *soap, const char *tag, int id, ns2__FillNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FillNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__FillNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__FillNotification ** SOAP_FMAC4 soap_in_PointerTons2__FillNotification(struct soap *soap, const char *tag, ns2__FillNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FillNotification **)soap_malloc(soap, sizeof(ns2__FillNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FillNotification *)soap_instantiate_ns2__FillNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FillNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FillNotification, sizeof(ns2__FillNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FillNotification(struct soap *soap, ns2__FillNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FillNotification(soap, tag ? tag : "ns2:FillNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FillNotification ** SOAP_FMAC4 soap_get_PointerTons2__FillNotification(struct soap *soap, ns2__FillNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FillNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CountNotification(struct soap *soap, ns2__CountNotification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CountNotification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CountNotification(struct soap *soap, const char *tag, int id, ns2__CountNotification *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CountNotification, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CountNotification ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__CountNotification ** SOAP_FMAC4 soap_in_PointerTons2__CountNotification(struct soap *soap, const char *tag, ns2__CountNotification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CountNotification **)soap_malloc(soap, sizeof(ns2__CountNotification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CountNotification *)soap_instantiate_ns2__CountNotification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CountNotification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CountNotification, sizeof(ns2__CountNotification), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CountNotification(struct soap *soap, ns2__CountNotification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CountNotification(soap, tag ? tag : "ns2:CountNotification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CountNotification ** SOAP_FMAC4 soap_get_PointerTons2__CountNotification(struct soap *soap, ns2__CountNotification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CountNotification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Coordinate_USCORE3D(struct soap *soap, ns2__Coordinate_USCORE3D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Coordinate_USCORE3D))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Coordinate_USCORE3D(struct soap *soap, const char *tag, int id, ns2__Coordinate_USCORE3D *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Coordinate_USCORE3D, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__Coordinate_USCORE3D ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns2__Coordinate_USCORE3D ** SOAP_FMAC4 soap_in_PointerTons2__Coordinate_USCORE3D(struct soap *soap, const char *tag, ns2__Coordinate_USCORE3D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Coordinate_USCORE3D **)soap_malloc(soap, sizeof(ns2__Coordinate_USCORE3D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Coordinate_USCORE3D *)soap_instantiate_ns2__Coordinate_USCORE3D(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Coordinate_USCORE3D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Coordinate_USCORE3D, sizeof(ns2__Coordinate_USCORE3D), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Coordinate_USCORE3D(struct soap *soap, ns2__Coordinate_USCORE3D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Coordinate_USCORE3D(soap, tag ? tag : "ns2:Coordinate_3D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Coordinate_USCORE3D ** SOAP_FMAC4 soap_get_PointerTons2__Coordinate_USCORE3D(struct soap *soap, ns2__Coordinate_USCORE3D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Coordinate_USCORE3D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__ZoneChannelFeatureInfo(struct soap *soap, ns2__ZoneChannelFeatureInfo **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__ZoneChannelFeatureInfo))
		soap_serialize_PointerTons2__ZoneChannelFeatureInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__ZoneChannelFeatureInfo(struct soap *soap, const char *tag, int id, ns2__ZoneChannelFeatureInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__ZoneChannelFeatureInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__ZoneChannelFeatureInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__ZoneChannelFeatureInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons2__ZoneChannelFeatureInfo(struct soap *soap, const char *tag, ns2__ZoneChannelFeatureInfo ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ZoneChannelFeatureInfo ***)soap_malloc(soap, sizeof(ns2__ZoneChannelFeatureInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__ZoneChannelFeatureInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__ZoneChannelFeatureInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ZoneChannelFeatureInfo, sizeof(ns2__ZoneChannelFeatureInfo), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__ZoneChannelFeatureInfo(struct soap *soap, ns2__ZoneChannelFeatureInfo **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons2__ZoneChannelFeatureInfo(soap, tag ? tag : "ns2:ZoneChannelFeatureInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ZoneChannelFeatureInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons2__ZoneChannelFeatureInfo(struct soap *soap, ns2__ZoneChannelFeatureInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__ZoneChannelFeatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ZoneChannelFeatureInfo(struct soap *soap, ns2__ZoneChannelFeatureInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ZoneChannelFeatureInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ZoneChannelFeatureInfo(struct soap *soap, const char *tag, int id, ns2__ZoneChannelFeatureInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ZoneChannelFeatureInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ZoneChannelFeatureInfo ? type : NULL);
}

SOAP_FMAC3 ns2__ZoneChannelFeatureInfo ** SOAP_FMAC4 soap_in_PointerTons2__ZoneChannelFeatureInfo(struct soap *soap, const char *tag, ns2__ZoneChannelFeatureInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ZoneChannelFeatureInfo **)soap_malloc(soap, sizeof(ns2__ZoneChannelFeatureInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ZoneChannelFeatureInfo *)soap_instantiate_ns2__ZoneChannelFeatureInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ZoneChannelFeatureInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ZoneChannelFeatureInfo, sizeof(ns2__ZoneChannelFeatureInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ZoneChannelFeatureInfo(struct soap *soap, ns2__ZoneChannelFeatureInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ZoneChannelFeatureInfo(soap, tag ? tag : "ns2:ZoneChannelFeatureInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ZoneChannelFeatureInfo ** SOAP_FMAC4 soap_get_PointerTons2__ZoneChannelFeatureInfo(struct soap *soap, ns2__ZoneChannelFeatureInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ZoneChannelFeatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__CountChannelFeatureInfo(struct soap *soap, ns2__CountChannelFeatureInfo **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__CountChannelFeatureInfo))
		soap_serialize_PointerTons2__CountChannelFeatureInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__CountChannelFeatureInfo(struct soap *soap, const char *tag, int id, ns2__CountChannelFeatureInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__CountChannelFeatureInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__CountChannelFeatureInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__CountChannelFeatureInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons2__CountChannelFeatureInfo(struct soap *soap, const char *tag, ns2__CountChannelFeatureInfo ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CountChannelFeatureInfo ***)soap_malloc(soap, sizeof(ns2__CountChannelFeatureInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__CountChannelFeatureInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__CountChannelFeatureInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CountChannelFeatureInfo, sizeof(ns2__CountChannelFeatureInfo), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__CountChannelFeatureInfo(struct soap *soap, ns2__CountChannelFeatureInfo **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons2__CountChannelFeatureInfo(soap, tag ? tag : "ns2:CountChannelFeatureInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CountChannelFeatureInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons2__CountChannelFeatureInfo(struct soap *soap, ns2__CountChannelFeatureInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__CountChannelFeatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CountChannelFeatureInfo(struct soap *soap, ns2__CountChannelFeatureInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CountChannelFeatureInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CountChannelFeatureInfo(struct soap *soap, const char *tag, int id, ns2__CountChannelFeatureInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CountChannelFeatureInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CountChannelFeatureInfo ? type : NULL);
}

SOAP_FMAC3 ns2__CountChannelFeatureInfo ** SOAP_FMAC4 soap_in_PointerTons2__CountChannelFeatureInfo(struct soap *soap, const char *tag, ns2__CountChannelFeatureInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CountChannelFeatureInfo **)soap_malloc(soap, sizeof(ns2__CountChannelFeatureInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CountChannelFeatureInfo *)soap_instantiate_ns2__CountChannelFeatureInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CountChannelFeatureInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CountChannelFeatureInfo, sizeof(ns2__CountChannelFeatureInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CountChannelFeatureInfo(struct soap *soap, ns2__CountChannelFeatureInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CountChannelFeatureInfo(soap, tag ? tag : "ns2:CountChannelFeatureInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CountChannelFeatureInfo ** SOAP_FMAC4 soap_get_PointerTons2__CountChannelFeatureInfo(struct soap *soap, ns2__CountChannelFeatureInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CountChannelFeatureInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ObjectClassName(struct soap *soap, std::wstring *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ObjectClassName))
		soap_serialize_ns2__ObjectClassName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ObjectClassName(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ObjectClassName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ObjectClassName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTons2__ObjectClassName(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ObjectClassName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ObjectClassName, sizeof(std::wstring), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ObjectClassName(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ObjectClassName(soap, tag ? tag : "ns2:ObjectClassName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTons2__ObjectClassName(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ObjectClassName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MeasuringChannelName(struct soap *soap, std::wstring *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MeasuringChannelName))
		soap_serialize_ns2__MeasuringChannelName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MeasuringChannelName(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MeasuringChannelName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__MeasuringChannelName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTons2__MeasuringChannelName(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__MeasuringChannelName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MeasuringChannelName, sizeof(std::wstring), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MeasuringChannelName(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__MeasuringChannelName(soap, tag ? tag : "ns2:MeasuringChannelName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTons2__MeasuringChannelName(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MeasuringChannelName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TimeTrigger(struct soap *soap, ns2__TimeTrigger *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TimeTrigger))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TimeTrigger(struct soap *soap, const char *tag, int id, ns2__TimeTrigger *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TimeTrigger, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__TimeTrigger ? type : NULL);
}

SOAP_FMAC3 ns2__TimeTrigger ** SOAP_FMAC4 soap_in_PointerTons2__TimeTrigger(struct soap *soap, const char *tag, ns2__TimeTrigger **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TimeTrigger **)soap_malloc(soap, sizeof(ns2__TimeTrigger *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TimeTrigger *)soap_instantiate_ns2__TimeTrigger(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TimeTrigger **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TimeTrigger, sizeof(ns2__TimeTrigger), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TimeTrigger(struct soap *soap, ns2__TimeTrigger *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TimeTrigger(soap, tag ? tag : "ns2:TimeTrigger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TimeTrigger ** SOAP_FMAC4 soap_get_PointerTons2__TimeTrigger(struct soap *soap, ns2__TimeTrigger **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TimeTrigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EventTrigger(struct soap *soap, ns2__EventTrigger *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EventTrigger))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EventTrigger(struct soap *soap, const char *tag, int id, ns2__EventTrigger *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EventTrigger, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__EventTrigger ? type : NULL);
}

SOAP_FMAC3 ns2__EventTrigger ** SOAP_FMAC4 soap_in_PointerTons2__EventTrigger(struct soap *soap, const char *tag, ns2__EventTrigger **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EventTrigger **)soap_malloc(soap, sizeof(ns2__EventTrigger *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EventTrigger *)soap_instantiate_ns2__EventTrigger(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__EventTrigger **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EventTrigger, sizeof(ns2__EventTrigger), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EventTrigger(struct soap *soap, ns2__EventTrigger *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__EventTrigger(soap, tag ? tag : "ns2:EventTrigger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EventTrigger ** SOAP_FMAC4 soap_get_PointerTons2__EventTrigger(struct soap *soap, ns2__EventTrigger **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EventTrigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, LONG64 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(LONG64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ClockTime(struct soap *soap, ns2__ClockTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ClockTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ClockTime(struct soap *soap, const char *tag, int id, ns2__ClockTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ClockTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ClockTime ? type : NULL);
}

SOAP_FMAC3 ns2__ClockTime ** SOAP_FMAC4 soap_in_PointerTons2__ClockTime(struct soap *soap, const char *tag, ns2__ClockTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ClockTime **)soap_malloc(soap, sizeof(ns2__ClockTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ClockTime *)soap_instantiate_ns2__ClockTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ClockTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ClockTime, sizeof(ns2__ClockTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ClockTime(struct soap *soap, ns2__ClockTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ClockTime(soap, tag ? tag : "ns2:ClockTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ClockTime ** SOAP_FMAC4 soap_get_PointerTons2__ClockTime(struct soap *soap, ns2__ClockTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ClockTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Date(struct soap *soap, ns2__Date *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Date))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Date(struct soap *soap, const char *tag, int id, ns2__Date *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Date, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__Date ? type : NULL);
}

SOAP_FMAC3 ns2__Date ** SOAP_FMAC4 soap_in_PointerTons2__Date(struct soap *soap, const char *tag, ns2__Date **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Date **)soap_malloc(soap, sizeof(ns2__Date *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Date *)soap_instantiate_ns2__Date(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Date **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Date, sizeof(ns2__Date), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Date(struct soap *soap, ns2__Date *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Date(soap, tag ? tag : "ns2:Date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Date ** SOAP_FMAC4 soap_get_PointerTons2__Date(struct soap *soap, ns2__Date **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DayOfMonth(struct soap *soap, unsigned int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns2__DayOfMonth);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DayOfMonth(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DayOfMonth, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DayOfMonth(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTons2__DayOfMonth(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DayOfMonth(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DayOfMonth, sizeof(unsigned int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DayOfMonth(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DayOfMonth(soap, tag ? tag : "ns2:DayOfMonth", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTons2__DayOfMonth(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DayOfMonth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DayOfWeek(struct soap *soap, enum ns2__DayOfWeek *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns2__DayOfWeek);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DayOfWeek(struct soap *soap, const char *tag, int id, enum ns2__DayOfWeek *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DayOfWeek, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DayOfWeek(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__DayOfWeek ** SOAP_FMAC4 soap_in_PointerTons2__DayOfWeek(struct soap *soap, const char *tag, enum ns2__DayOfWeek **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__DayOfWeek **)soap_malloc(soap, sizeof(enum ns2__DayOfWeek *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DayOfWeek(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__DayOfWeek **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DayOfWeek, sizeof(enum ns2__DayOfWeek), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DayOfWeek(struct soap *soap, enum ns2__DayOfWeek *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DayOfWeek(soap, tag ? tag : "ns2:DayOfWeek", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DayOfWeek ** SOAP_FMAC4 soap_get_PointerTons2__DayOfWeek(struct soap *soap, enum ns2__DayOfWeek **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DayOfWeek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FeatureChangedEvent(struct soap *soap, ns2__FeatureChangedEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FeatureChangedEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FeatureChangedEvent(struct soap *soap, const char *tag, int id, ns2__FeatureChangedEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FeatureChangedEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__FeatureChangedEvent ? type : NULL);
}

SOAP_FMAC3 ns2__FeatureChangedEvent ** SOAP_FMAC4 soap_in_PointerTons2__FeatureChangedEvent(struct soap *soap, const char *tag, ns2__FeatureChangedEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FeatureChangedEvent **)soap_malloc(soap, sizeof(ns2__FeatureChangedEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FeatureChangedEvent *)soap_instantiate_ns2__FeatureChangedEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FeatureChangedEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FeatureChangedEvent, sizeof(ns2__FeatureChangedEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FeatureChangedEvent(struct soap *soap, ns2__FeatureChangedEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FeatureChangedEvent(soap, tag ? tag : "ns2:FeatureChangedEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FeatureChangedEvent ** SOAP_FMAC4 soap_get_PointerTons2__FeatureChangedEvent(struct soap *soap, ns2__FeatureChangedEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FeatureChangedEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ZoneChannelsEvent(struct soap *soap, ns2__ZoneChannelsEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ZoneChannelsEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ZoneChannelsEvent(struct soap *soap, const char *tag, int id, ns2__ZoneChannelsEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ZoneChannelsEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ZoneChannelsEvent ? type : NULL);
}

SOAP_FMAC3 ns2__ZoneChannelsEvent ** SOAP_FMAC4 soap_in_PointerTons2__ZoneChannelsEvent(struct soap *soap, const char *tag, ns2__ZoneChannelsEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ZoneChannelsEvent **)soap_malloc(soap, sizeof(ns2__ZoneChannelsEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ZoneChannelsEvent *)soap_instantiate_ns2__ZoneChannelsEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ZoneChannelsEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ZoneChannelsEvent, sizeof(ns2__ZoneChannelsEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ZoneChannelsEvent(struct soap *soap, ns2__ZoneChannelsEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ZoneChannelsEvent(soap, tag ? tag : "ns2:ZoneChannelsEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ZoneChannelsEvent ** SOAP_FMAC4 soap_get_PointerTons2__ZoneChannelsEvent(struct soap *soap, ns2__ZoneChannelsEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ZoneChannelsEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CountChannelsEvent(struct soap *soap, ns2__CountChannelsEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CountChannelsEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CountChannelsEvent(struct soap *soap, const char *tag, int id, ns2__CountChannelsEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CountChannelsEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CountChannelsEvent ? type : NULL);
}

SOAP_FMAC3 ns2__CountChannelsEvent ** SOAP_FMAC4 soap_in_PointerTons2__CountChannelsEvent(struct soap *soap, const char *tag, ns2__CountChannelsEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CountChannelsEvent **)soap_malloc(soap, sizeof(ns2__CountChannelsEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CountChannelsEvent *)soap_instantiate_ns2__CountChannelsEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CountChannelsEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CountChannelsEvent, sizeof(ns2__CountChannelsEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CountChannelsEvent(struct soap *soap, ns2__CountChannelsEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CountChannelsEvent(soap, tag ? tag : "ns2:CountChannelsEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CountChannelsEvent ** SOAP_FMAC4 soap_get_PointerTons2__CountChannelsEvent(struct soap *soap, ns2__CountChannelsEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CountChannelsEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ClearZoneEvent(struct soap *soap, ns2__ClearZoneEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ClearZoneEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ClearZoneEvent(struct soap *soap, const char *tag, int id, ns2__ClearZoneEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ClearZoneEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__ClearZoneEvent ? type : NULL);
}

SOAP_FMAC3 ns2__ClearZoneEvent ** SOAP_FMAC4 soap_in_PointerTons2__ClearZoneEvent(struct soap *soap, const char *tag, ns2__ClearZoneEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ClearZoneEvent **)soap_malloc(soap, sizeof(ns2__ClearZoneEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ClearZoneEvent *)soap_instantiate_ns2__ClearZoneEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ClearZoneEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ClearZoneEvent, sizeof(ns2__ClearZoneEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ClearZoneEvent(struct soap *soap, ns2__ClearZoneEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ClearZoneEvent(soap, tag ? tag : "ns2:ClearZoneEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ClearZoneEvent ** SOAP_FMAC4 soap_get_PointerTons2__ClearZoneEvent(struct soap *soap, ns2__ClearZoneEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ClearZoneEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CurrentObjectListEvent(struct soap *soap, ns2__CurrentObjectListEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CurrentObjectListEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CurrentObjectListEvent(struct soap *soap, const char *tag, int id, ns2__CurrentObjectListEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CurrentObjectListEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CurrentObjectListEvent ? type : NULL);
}

SOAP_FMAC3 ns2__CurrentObjectListEvent ** SOAP_FMAC4 soap_in_PointerTons2__CurrentObjectListEvent(struct soap *soap, const char *tag, ns2__CurrentObjectListEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CurrentObjectListEvent **)soap_malloc(soap, sizeof(ns2__CurrentObjectListEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CurrentObjectListEvent *)soap_instantiate_ns2__CurrentObjectListEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CurrentObjectListEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CurrentObjectListEvent, sizeof(ns2__CurrentObjectListEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CurrentObjectListEvent(struct soap *soap, ns2__CurrentObjectListEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CurrentObjectListEvent(soap, tag ? tag : "ns2:CurrentObjectListEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CurrentObjectListEvent ** SOAP_FMAC4 soap_get_PointerTons2__CurrentObjectListEvent(struct soap *soap, ns2__CurrentObjectListEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CurrentObjectListEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OSD_USCOREEvent(struct soap *soap, ns2__OSD_USCOREEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OSD_USCOREEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OSD_USCOREEvent(struct soap *soap, const char *tag, int id, ns2__OSD_USCOREEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OSD_USCOREEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__OSD_USCOREEvent ? type : NULL);
}

SOAP_FMAC3 ns2__OSD_USCOREEvent ** SOAP_FMAC4 soap_in_PointerTons2__OSD_USCOREEvent(struct soap *soap, const char *tag, ns2__OSD_USCOREEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OSD_USCOREEvent **)soap_malloc(soap, sizeof(ns2__OSD_USCOREEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OSD_USCOREEvent *)soap_instantiate_ns2__OSD_USCOREEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__OSD_USCOREEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OSD_USCOREEvent, sizeof(ns2__OSD_USCOREEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OSD_USCOREEvent(struct soap *soap, ns2__OSD_USCOREEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__OSD_USCOREEvent(soap, tag ? tag : "ns2:OSD_Event", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OSD_USCOREEvent ** SOAP_FMAC4 soap_get_PointerTons2__OSD_USCOREEvent(struct soap *soap, ns2__OSD_USCOREEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OSD_USCOREEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OneTimeEvent(struct soap *soap, ns2__OneTimeEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OneTimeEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OneTimeEvent(struct soap *soap, const char *tag, int id, ns2__OneTimeEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OneTimeEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__OneTimeEvent ? type : NULL);
}

SOAP_FMAC3 ns2__OneTimeEvent ** SOAP_FMAC4 soap_in_PointerTons2__OneTimeEvent(struct soap *soap, const char *tag, ns2__OneTimeEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OneTimeEvent **)soap_malloc(soap, sizeof(ns2__OneTimeEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OneTimeEvent *)soap_instantiate_ns2__OneTimeEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__OneTimeEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OneTimeEvent, sizeof(ns2__OneTimeEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OneTimeEvent(struct soap *soap, ns2__OneTimeEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__OneTimeEvent(soap, tag ? tag : "ns2:OneTimeEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OneTimeEvent ** SOAP_FMAC4 soap_get_PointerTons2__OneTimeEvent(struct soap *soap, ns2__OneTimeEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OneTimeEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DigitalInputEvent(struct soap *soap, ns2__DigitalInputEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DigitalInputEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DigitalInputEvent(struct soap *soap, const char *tag, int id, ns2__DigitalInputEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DigitalInputEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__DigitalInputEvent ? type : NULL);
}

SOAP_FMAC3 ns2__DigitalInputEvent ** SOAP_FMAC4 soap_in_PointerTons2__DigitalInputEvent(struct soap *soap, const char *tag, ns2__DigitalInputEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DigitalInputEvent **)soap_malloc(soap, sizeof(ns2__DigitalInputEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DigitalInputEvent *)soap_instantiate_ns2__DigitalInputEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DigitalInputEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DigitalInputEvent, sizeof(ns2__DigitalInputEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DigitalInputEvent(struct soap *soap, ns2__DigitalInputEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DigitalInputEvent(soap, tag ? tag : "ns2:DigitalInputEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DigitalInputEvent ** SOAP_FMAC4 soap_get_PointerTons2__DigitalInputEvent(struct soap *soap, ns2__DigitalInputEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DigitalInputEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FillEvent(struct soap *soap, ns2__FillEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FillEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FillEvent(struct soap *soap, const char *tag, int id, ns2__FillEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FillEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__FillEvent ? type : NULL);
}

SOAP_FMAC3 ns2__FillEvent ** SOAP_FMAC4 soap_in_PointerTons2__FillEvent(struct soap *soap, const char *tag, ns2__FillEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FillEvent **)soap_malloc(soap, sizeof(ns2__FillEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FillEvent *)soap_instantiate_ns2__FillEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FillEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FillEvent, sizeof(ns2__FillEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FillEvent(struct soap *soap, ns2__FillEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FillEvent(soap, tag ? tag : "ns2:FillEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FillEvent ** SOAP_FMAC4 soap_get_PointerTons2__FillEvent(struct soap *soap, ns2__FillEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FillEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CountEvent(struct soap *soap, ns2__CountEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CountEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CountEvent(struct soap *soap, const char *tag, int id, ns2__CountEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CountEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns2__CountEvent ? type : NULL);
}

SOAP_FMAC3 ns2__CountEvent ** SOAP_FMAC4 soap_in_PointerTons2__CountEvent(struct soap *soap, const char *tag, ns2__CountEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CountEvent **)soap_malloc(soap, sizeof(ns2__CountEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CountEvent *)soap_instantiate_ns2__CountEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CountEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CountEvent, sizeof(ns2__CountEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CountEvent(struct soap *soap, ns2__CountEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CountEvent(soap, tag ? tag : "ns2:CountEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CountEvent ** SOAP_FMAC4 soap_get_PointerTons2__CountEvent(struct soap *soap, ns2__CountEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CountEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DigitalInputEventType(struct soap *soap, enum ns2__DigitalInputEventType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_ns2__DigitalInputEventType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DigitalInputEventType(struct soap *soap, const char *tag, int id, enum ns2__DigitalInputEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DigitalInputEventType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DigitalInputEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__DigitalInputEventType ** SOAP_FMAC4 soap_in_PointerTons2__DigitalInputEventType(struct soap *soap, const char *tag, enum ns2__DigitalInputEventType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__DigitalInputEventType **)soap_malloc(soap, sizeof(enum ns2__DigitalInputEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DigitalInputEventType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__DigitalInputEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DigitalInputEventType, sizeof(enum ns2__DigitalInputEventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DigitalInputEventType(struct soap *soap, enum ns2__DigitalInputEventType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DigitalInputEventType(soap, tag ? tag : "ns2:DigitalInputEventType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DigitalInputEventType ** SOAP_FMAC4 soap_get_PointerTons2__DigitalInputEventType(struct soap *soap, enum ns2__DigitalInputEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DigitalInputEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
//---- 我手工Add 5个函数-------------------------------
SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__duration(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
	*a = 0;
}
SOAP_FMAC3 const char * SOAP_FMAC4 soap_xsd__duration2s(struct soap *soap, LONG64 a)
{
	LONG64 d;
	int k, h, m, s, f;
	if (a < 0)
	{
		soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), "-P");
		k = 2;
		a = -a;
	}
	else
	{
		soap_strcpy(soap->tmpbuf, sizeof(soap->tmpbuf), "P");
		k = 1;
	}
	f = a % 1000;
	a /= 1000;
	s = a % 60;
	a /= 60;
	m = a % 60;
	a /= 60;
	h = a % 24;
	d = a / 24;
	if (d)
		(SOAP_SNPRINTF(soap->tmpbuf + k, sizeof(soap->tmpbuf) - k, 21), SOAP_LONG_FORMAT "D", d);
	if (h || m || s || f)
	{
		if (d)
			k = strlen(soap->tmpbuf);
		if (f)
			(SOAP_SNPRINTF(soap->tmpbuf + k, sizeof(soap->tmpbuf) - k, 14), "T%02dH%02dM%02d.%03dS", h, m, s, f);
		else
			(SOAP_SNPRINTF(soap->tmpbuf + k, sizeof(soap->tmpbuf) - k, 10), "T%02dH%02dM%02dS", h, m, s);
	}
	else if (!d)
		soap_strcpy(soap->tmpbuf + k, sizeof(soap->tmpbuf) - k, "T0S");
	return soap->tmpbuf;
}
SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__duration), type)
		|| soap_string_out(soap, soap_xsd__duration2s(soap, *a), 0))
		return soap->error;
	return soap_element_end_out(soap, tag);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_s2xsd__duration(struct soap *soap, const char *s, LONG64 *a)
{
	LONG64 sign = 1, Y = 0, M = 0, D = 0, H = 0, N = 0, S = 0;
	float f = 0;
	*a = 0;
	if (s)
	{
		if (*s == '-')
		{
			sign = -1;
			s++;
		}
		if (*s != 'P' && *s != 'p')
			return soap->error = SOAP_TYPE;
		s++;
		/* date part */
		while (s && *s)
		{
			char *r = NULL;
			LONG64 n;
			if (*s == 'T' || *s == 't')
			{
				s++;
				break;
			}
			n = soap_strtol(s, &r, 10);
			if (!r)
				return soap->error = SOAP_TYPE;
			s = r;
			switch (*s)
			{
			case 'Y':
			case 'y':
				Y = n;
				break;
			case 'M':
			case 'm':
				M = n;
				break;
			case 'D':
			case 'd':
				D = n;
				break;
			default:
				return soap->error = SOAP_TYPE;
			}
			s++;
		}
		/* time part */
		while (s && *s)
		{
			char *r = NULL;
			LONG64 n;
			n = soap_strtol(s, &r, 10);
			if (!r)
				return soap->error = SOAP_TYPE;
			s = r;
			switch (*s)
			{
			case 'H':
			case 'h':
				H = n;
				break;
			case 'M':
			case 'm':
				N = n;
				break;
			case '.':
				S = n;
#if defined(WITH_C_LOCALE) && defined(HAVE_STRTOD_L)
# ifdef WIN32
				f = (float)_strtod_l(s, NULL, SOAP_LOCALE(soap));
# else
				f = (float)strtod_l(s, NULL, SOAP_LOCALE(soap));
# endif
#elif defined(HAVE_STRTOD)
				f = (float)strtod(s, NULL);
#elif defined(WITH_C_LOCALE) && defined(HAVE_STRTOF_L)
				f = strtof_l((char*)s, NULL, SOAP_LOCALE(soap));
#elif defined(HAVE_STRTOF)
				f = strtof((char*)s, NULL);
#endif
				s = NULL;
				continue;
			case 'S':
			case 's':
				S = n;
				break;
			default:
				return soap->error = SOAP_TYPE;
			}
			s++;
		}
		/* convert Y-M-D H:N:S.f to signed long long int milliseconds */
		*a = sign * ((((((((((((Y * 12) + M) * 30) + D) * 24) + H) * 60) + N) * 60) + S) * 1000) + (LONG64)(1000.0 * f + 0.5));
	}
	return soap->error;
}
SOAP_FMAC1 LONG64 * SOAP_FMAC2 soap_in_xsd__duration(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type
		&& soap_match_att(soap, soap->type, type)
		&& soap_match_att(soap, soap->type, ":duration"))
	{
		soap->error = SOAP_TYPE;
		soap_revert(soap);
		return NULL;
	}
	a = (LONG64*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__duration, sizeof(LONG64), NULL, NULL, NULL, NULL);
	if (*soap->href)
		a = (LONG64*)soap_id_forward(soap, soap->href, a, 0, SOAP_TYPE_xsd__duration, 0, sizeof(LONG64), 0, NULL, NULL);
	else if (a)
	{
		if (soap_s2xsd__duration(soap, soap_value(soap), a))
			return NULL;
	}
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return a;
}
//------End---------------
#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
